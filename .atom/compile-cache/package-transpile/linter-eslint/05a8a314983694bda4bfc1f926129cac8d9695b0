'use strict';
'use babel';

// eslint-disable-next-line import/no-extraneous-dependencies, import/extensions

var _atom = require('atom');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// Dependencies
// NOTE: We are not directly requiring these in order to reduce the time it
// takes to require this file as that causes delays in Atom loading this package
let path;
let helpers;
let workerHelpers;
let isConfigAtHomeRoot;

// Configuration
const scopes = [];
let showRule;
let lintHtmlFiles;
let ignoredRulesWhenModified;
let ignoredRulesWhenFixing;
let disableWhenNoEslintConfig;
let ignoreFixableRulesWhileTyping;

// Internal variables
const idleCallbacks = new Set();

// Internal functions
const idsToIgnoredRules = ruleIds => ruleIds.reduce((ids, id) => {
  // eslint-disable-next-line no-param-reassign
  ids[id] = 0; // 0 is the severity to turn off a rule
  return ids;
}, {});

// Worker still hasn't initialized, since the queued idle callbacks are
// done in order, waiting on a newly queued idle callback will ensure that
// the worker has been initialized
const waitOnIdle = (() => {
  var _ref = _asyncToGenerator(function* () {
    return new Promise(function (resolve) {
      const callbackID = window.requestIdleCallback(function () {
        idleCallbacks.delete(callbackID);
        resolve();
      });
      idleCallbacks.add(callbackID);
    });
  });

  return function waitOnIdle() {
    return _ref.apply(this, arguments);
  };
})();

const validScope = editor => editor.getCursors().some(cursor => cursor.getScopeDescriptor().getScopesArray().some(scope => scopes.includes(scope)));

module.exports = {
  activate() {
    var _this = this;

    let callbackID;
    const installLinterEslintDeps = () => {
      idleCallbacks.delete(callbackID);
      if (!atom.inSpecMode()) {
        require('atom-package-deps').install('linter-eslint');
      }
    };
    callbackID = window.requestIdleCallback(installLinterEslintDeps);
    idleCallbacks.add(callbackID);

    this.subscriptions = new _atom.CompositeDisposable();
    this.worker = null;

    /**
     * FIXME: Deprecated eslintRulesDir{String} option in favor of
     * eslintRulesDirs{Array<String>}. Remove in the next major release,
     * in v8.5.0, or after 2018-04.
     */
    const oldRulesdir = atom.config.get('linter-eslint.eslintRulesDir');
    if (oldRulesdir) {
      const rulesDirs = atom.config.get('linter-eslint.eslintRulesDirs');
      if (rulesDirs.length === 0) {
        atom.config.set('linter-eslint.eslintRulesDirs', [oldRulesdir]);
      }
      atom.config.unset('linter-eslint.eslintRulesDir');
    }

    const embeddedScope = 'source.js.embedded.html';
    this.subscriptions.add(atom.config.observe('linter-eslint.lintHtmlFiles', value => {
      lintHtmlFiles = value;
      if (lintHtmlFiles) {
        scopes.push(embeddedScope);
      } else if (scopes.indexOf(embeddedScope) !== -1) {
        scopes.splice(scopes.indexOf(embeddedScope), 1);
      }
    }));

    this.subscriptions.add(atom.config.observe('linter-eslint.scopes', value => {
      // Remove any old scopes
      scopes.splice(0, scopes.length);
      // Add the current scopes
      Array.prototype.push.apply(scopes, value);
      // Ensure HTML linting still works if the setting is updated
      if (lintHtmlFiles && !scopes.includes(embeddedScope)) {
        scopes.push(embeddedScope);
      }
    }));

    this.subscriptions.add(atom.workspace.observeTextEditors(editor => {
      editor.onDidSave(_asyncToGenerator(function* () {
        if (validScope(editor) && atom.config.get('linter-eslint.fixOnSave')) {
          yield _this.fixJob(true);
        }
      }));
    }));

    this.subscriptions.add(atom.commands.add('atom-text-editor', {
      'linter-eslint:debug': (() => {
        var _ref3 = _asyncToGenerator(function* () {
          if (!helpers) {
            helpers = require('./helpers');
          }
          if (!_this.worker) {
            yield waitOnIdle();
          }
          const debugString = yield helpers.generateDebugString(_this.worker);
          const notificationOptions = { detail: debugString, dismissable: true };
          atom.notifications.addInfo('linter-eslint debugging information', notificationOptions);
        });

        return function linterEslintDebug() {
          return _ref3.apply(this, arguments);
        };
      })()
    }));

    this.subscriptions.add(atom.commands.add('atom-text-editor', {
      'linter-eslint:fix-file': (() => {
        var _ref4 = _asyncToGenerator(function* () {
          yield _this.fixJob();
        });

        return function linterEslintFixFile() {
          return _ref4.apply(this, arguments);
        };
      })()
    }));

    this.subscriptions.add(atom.config.observe('linter-eslint.showRuleIdInMessage', value => {
      showRule = value;
    }));

    this.subscriptions.add(atom.config.observe('linter-eslint.disableWhenNoEslintConfig', value => {
      disableWhenNoEslintConfig = value;
    }));

    this.subscriptions.add(atom.config.observe('linter-eslint.rulesToSilenceWhileTyping', ids => {
      ignoredRulesWhenModified = idsToIgnoredRules(ids);
    }));

    this.subscriptions.add(atom.config.observe('linter-eslint.rulesToDisableWhileFixing', ids => {
      ignoredRulesWhenFixing = idsToIgnoredRules(ids);
    }));

    this.subscriptions.add(atom.config.observe('linter-eslint.ignoreFixableRulesWhileTyping', value => {
      ignoreFixableRulesWhileTyping = value;
    }));

    this.subscriptions.add(atom.contextMenu.add({
      'atom-text-editor:not(.mini), .overlayer': [{
        label: 'ESLint Fix',
        command: 'linter-eslint:fix-file',
        shouldDisplay: evt => {
          const activeEditor = atom.workspace.getActiveTextEditor();
          if (!activeEditor) {
            return false;
          }
          // Black magic!
          // Compares the private component property of the active TextEditor
          //   against the components of the elements
          const evtIsActiveEditor = evt.path.some(elem =>
          // Atom v1.19.0+
          elem.component && activeEditor.component && elem.component === activeEditor.component);
          // Only show if it was the active editor and it is a valid scope
          return evtIsActiveEditor && validScope(activeEditor);
        }
      }]
    }));

    const initializeESLintWorker = () => {
      this.worker = new _atom.Task(require.resolve('./worker.js'));
    };
    // Initialize the worker during an idle time
    window.requestIdleCallback(initializeESLintWorker);
  },

  deactivate() {
    if (this.worker !== null) {
      this.worker.terminate();
      this.worker = null;
    }
    idleCallbacks.forEach(callbackID => window.cancelIdleCallback(callbackID));
    idleCallbacks.clear();
    this.subscriptions.dispose();
  },

  provideLinter() {
    var _this2 = this;

    return {
      name: 'ESLint',
      grammarScopes: scopes,
      scope: 'file',
      lintsOnChange: true,
      lint: (() => {
        var _ref5 = _asyncToGenerator(function* (textEditor) {
          if (!atom.workspace.isTextEditor(textEditor)) {
            // If we somehow get fed an invalid TextEditor just immediately return
            return null;
          }

          const filePath = textEditor.getPath();
          if (!filePath) {
            // The editor currently has no path, we can't report messages back to
            // Linter so just return null
            return null;
          }

          if (filePath.includes('://')) {
            // If the path is a URL (Nuclide remote file) return a message
            // telling the user we are unable to work on remote files.
            return helpers.generateUserMessage(textEditor, {
              severity: 'warning',
              excerpt: 'Remote file open, linter-eslint is disabled for this file.'
            });
          }

          const text = textEditor.getText();

          if (!helpers) {
            helpers = require('./helpers');
          }

          let rules = {};
          if (textEditor.isModified() && Object.keys(ignoredRulesWhenModified).length > 0) {
            rules = ignoredRulesWhenModified;
          }
          if (textEditor.isModified() && ignoreFixableRulesWhileTyping) {
            // Note that this list will only contain rules after the first lint job
            rules = idsToIgnoredRules(helpers.getFixableRules());
          }

          if (!_this2.worker) {
            yield waitOnIdle();
          }

          let response;
          try {
            response = yield helpers.sendJob(_this2.worker, {
              type: 'lint',
              contents: text,
              config: atom.config.get('linter-eslint'),
              rules,
              filePath,
              projectPath: atom.project.relativizePath(filePath)[0] || ''
            });
            if (textEditor.getText() !== text) {
              /*
              The editor text has been modified since the lint was triggered,
              as we can't be sure that the results will map properly back to
              the new contents, simply return `null` to tell the
              `provideLinter` consumer not to update the saved results.
              */
              return null;
            }
            return helpers.processJobResponse(response, textEditor, showRule, _this2.worker);
          } catch (error) {
            return helpers.handleError(textEditor, error);
          }
        });

        return function lint(_x) {
          return _ref5.apply(this, arguments);
        };
      })()
    };
  },

  fixJob() {
    var _arguments = arguments,
        _this3 = this;

    return _asyncToGenerator(function* () {
      let isSave = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : false;

      const textEditor = atom.workspace.getActiveTextEditor();

      if (!textEditor || !atom.workspace.isTextEditor(textEditor)) {
        // Silently return if the TextEditor is invalid
        return;
      }

      if (textEditor.isModified()) {
        // Abort for invalid or unsaved text editors
        const message = 'Linter-ESLint: Please save before fixing';
        atom.notifications.addError(message);
      }

      if (!path) {
        path = require('path');
      }
      if (!isConfigAtHomeRoot) {
        isConfigAtHomeRoot = require('./is-config-at-home-root');
      }
      if (!workerHelpers) {
        workerHelpers = require('./worker-helpers');
      }

      const filePath = textEditor.getPath();
      const fileDir = path.dirname(filePath);
      const projectPath = atom.project.relativizePath(filePath)[0];

      // Get the text from the editor, so we can use executeOnText
      const text = textEditor.getText();
      // Do not try to make fixes on an empty file
      if (text.length === 0) {
        return;
      }

      // Do not try to fix if linting should be disabled
      const configPath = workerHelpers.getConfigPath(fileDir);
      const noProjectConfig = configPath === null || isConfigAtHomeRoot(configPath);
      if (noProjectConfig && disableWhenNoEslintConfig) {
        return;
      }

      let rules = {};
      if (Object.keys(ignoredRulesWhenFixing).length > 0) {
        rules = ignoredRulesWhenFixing;
      }

      if (!helpers) {
        helpers = require('./helpers');
      }
      if (!_this3.worker) {
        yield waitOnIdle();
      }

      try {
        const response = yield helpers.sendJob(_this3.worker, {
          type: 'fix',
          config: atom.config.get('linter-eslint'),
          contents: text,
          rules,
          filePath,
          projectPath
        });
        if (!isSave) {
          atom.notifications.addSuccess(response);
        }
      } catch (err) {
        atom.notifications.addWarning(err.message);
      }
    })();
  }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1haW4uanMiXSwibmFtZXMiOlsicGF0aCIsImhlbHBlcnMiLCJ3b3JrZXJIZWxwZXJzIiwiaXNDb25maWdBdEhvbWVSb290Iiwic2NvcGVzIiwic2hvd1J1bGUiLCJsaW50SHRtbEZpbGVzIiwiaWdub3JlZFJ1bGVzV2hlbk1vZGlmaWVkIiwiaWdub3JlZFJ1bGVzV2hlbkZpeGluZyIsImRpc2FibGVXaGVuTm9Fc2xpbnRDb25maWciLCJpZ25vcmVGaXhhYmxlUnVsZXNXaGlsZVR5cGluZyIsImlkbGVDYWxsYmFja3MiLCJTZXQiLCJpZHNUb0lnbm9yZWRSdWxlcyIsInJ1bGVJZHMiLCJyZWR1Y2UiLCJpZHMiLCJpZCIsIndhaXRPbklkbGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNhbGxiYWNrSUQiLCJ3aW5kb3ciLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwiZGVsZXRlIiwiYWRkIiwidmFsaWRTY29wZSIsImVkaXRvciIsImdldEN1cnNvcnMiLCJzb21lIiwiY3Vyc29yIiwiZ2V0U2NvcGVEZXNjcmlwdG9yIiwiZ2V0U2NvcGVzQXJyYXkiLCJzY29wZSIsImluY2x1ZGVzIiwibW9kdWxlIiwiZXhwb3J0cyIsImFjdGl2YXRlIiwiaW5zdGFsbExpbnRlckVzbGludERlcHMiLCJhdG9tIiwiaW5TcGVjTW9kZSIsInJlcXVpcmUiLCJpbnN0YWxsIiwic3Vic2NyaXB0aW9ucyIsIndvcmtlciIsIm9sZFJ1bGVzZGlyIiwiY29uZmlnIiwiZ2V0IiwicnVsZXNEaXJzIiwibGVuZ3RoIiwic2V0IiwidW5zZXQiLCJlbWJlZGRlZFNjb3BlIiwib2JzZXJ2ZSIsInZhbHVlIiwicHVzaCIsImluZGV4T2YiLCJzcGxpY2UiLCJBcnJheSIsInByb3RvdHlwZSIsImFwcGx5Iiwid29ya3NwYWNlIiwib2JzZXJ2ZVRleHRFZGl0b3JzIiwib25EaWRTYXZlIiwiZml4Sm9iIiwiY29tbWFuZHMiLCJkZWJ1Z1N0cmluZyIsImdlbmVyYXRlRGVidWdTdHJpbmciLCJub3RpZmljYXRpb25PcHRpb25zIiwiZGV0YWlsIiwiZGlzbWlzc2FibGUiLCJub3RpZmljYXRpb25zIiwiYWRkSW5mbyIsImNvbnRleHRNZW51IiwibGFiZWwiLCJjb21tYW5kIiwic2hvdWxkRGlzcGxheSIsImV2dCIsImFjdGl2ZUVkaXRvciIsImdldEFjdGl2ZVRleHRFZGl0b3IiLCJldnRJc0FjdGl2ZUVkaXRvciIsImVsZW0iLCJjb21wb25lbnQiLCJpbml0aWFsaXplRVNMaW50V29ya2VyIiwiZGVhY3RpdmF0ZSIsInRlcm1pbmF0ZSIsImZvckVhY2giLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJjbGVhciIsImRpc3Bvc2UiLCJwcm92aWRlTGludGVyIiwibmFtZSIsImdyYW1tYXJTY29wZXMiLCJsaW50c09uQ2hhbmdlIiwibGludCIsInRleHRFZGl0b3IiLCJpc1RleHRFZGl0b3IiLCJmaWxlUGF0aCIsImdldFBhdGgiLCJnZW5lcmF0ZVVzZXJNZXNzYWdlIiwic2V2ZXJpdHkiLCJleGNlcnB0IiwidGV4dCIsImdldFRleHQiLCJydWxlcyIsImlzTW9kaWZpZWQiLCJPYmplY3QiLCJrZXlzIiwiZ2V0Rml4YWJsZVJ1bGVzIiwicmVzcG9uc2UiLCJzZW5kSm9iIiwidHlwZSIsImNvbnRlbnRzIiwicHJvamVjdFBhdGgiLCJwcm9qZWN0IiwicmVsYXRpdml6ZVBhdGgiLCJwcm9jZXNzSm9iUmVzcG9uc2UiLCJlcnJvciIsImhhbmRsZUVycm9yIiwiaXNTYXZlIiwibWVzc2FnZSIsImFkZEVycm9yIiwiZmlsZURpciIsImRpcm5hbWUiLCJjb25maWdQYXRoIiwiZ2V0Q29uZmlnUGF0aCIsIm5vUHJvamVjdENvbmZpZyIsImFkZFN1Y2Nlc3MiLCJlcnIiLCJhZGRXYXJuaW5nIl0sIm1hcHBpbmdzIjoiO0FBQUE7O0FBRUE7O0FBQ0E7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJQSxJQUFKO0FBQ0EsSUFBSUMsT0FBSjtBQUNBLElBQUlDLGFBQUo7QUFDQSxJQUFJQyxrQkFBSjs7QUFFQTtBQUNBLE1BQU1D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QVE2RyxPQUFSLENBQWdCLE9BQUtsRSxNQUFyQixFQUE2QjtBQUNsRG1FLGdCQUFNLEtBRDRDO0FBRWxEakUsa0JBQVFQLEtBQUtPLE1BQUwsQ0FBWUMsR0FBWixDQUFnQixlQUFoQixDQUYwQztBQUdsRGlFLG9CQUFVVixJQUh3QztBQUlsREUsZUFKa0Q7QUFLbERQLGtCQUxrRDtBQU1sRGdCO0FBTmtELFNBQTdCLENBQXZCO0FBUUEsWUFBSSxDQUFDTSxNQUFMLEVBQWE7QUFDWGhGLGVBQUtnQyxhQUFMLENBQW1Cd0QsVUFBbkIsQ0FBOEJsQixRQUE5QjtBQUNEO0FBQ0YsT0FaRCxDQVlFLE9BQU9tQixHQUFQLEVBQVk7QUFDWnpGLGFBQUtnQyxhQUFMLENBQW1CMEQsVUFBbkIsQ0FBOEJELElBQUlSLE9BQWxDO0FBQ0Q7QUFwRTBCO0FBcUU1QjtBQW5TYyxDQUFqQiIsImZpbGUiOiJtYWluLmpzIiwic291cmNlUm9vdCI6Ii9Vc2Vycy90bGFuZGF1L2RvdGZpbGVzLy5hdG9tL3BhY2thZ2VzL2xpbnRlci1lc2xpbnQiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGJhYmVsJ1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzLCBpbXBvcnQvZXh0ZW5zaW9uc1xuaW1wb3J0IHsgQ29tcG9zaXRlRGlzcG9zYWJsZSwgVGFzayB9IGZyb20gJ2F0b20nXG5cbi8vIERlcGVuZGVuY2llc1xuLy8gTk9URTogV2UgYXJlIG5vdCBkaXJlY3RseSByZXF1aXJpbmcgdGhlc2UgaW4gb3JkZXIgdG8gcmVkdWNlIHRoZSB0aW1lIGl0XG4vLyB0YWtlcyB0byByZXF1aXJlIHRoaXMgZmlsZSBhcyB0aGF0IGNhdXNlcyBkZWxheXMgaW4gQXRvbSBsb2FkaW5nIHRoaXMgcGFja2FnZVxubGV0IHBhdGhcbmxldCBoZWxwZXJzXG5sZXQgd29ya2VySGVscGVyc1xubGV0IGlzQ29uZmlnQXRIb21lUm9vdFxuXG4vLyBDb25maWd1cmF0aW9uXG5jb25zdCBzY29wZXMgPSBbXVxubGV0IHNob3dSdWxlXG5sZXQgbGludEh0bWxGaWxlc1xubGV0IGlnbm9yZWRSdWxlc1doZW5Nb2RpZmllZFxubGV0IGlnbm9yZWRSdWxlc1doZW5GaXhpbmdcbmxldCBkaXNhYmxlV2hlbk5vRXNsaW50Q29uZmlnXG5sZXQgaWdub3JlRml4YWJsZVJ1bGVzV2hpbGVUeXBpbmdcblxuLy8gSW50ZXJuYWwgdmFyaWFibGVzXG5jb25zdCBpZGxlQ2FsbGJhY2tzID0gbmV3IFNldCgpXG5cbi8vIEludGVybmFsIGZ1bmN0aW9uc1xuY29uc3QgaWRzVG9JZ25vcmVkUnVsZXMgPSBydWxlSWRzID0+XG4gIHJ1bGVJZHMucmVkdWNlKChpZHMsIGlkKSA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgaWRzW2lkXSA9IDAgLy8gMCBpcyB0aGUgc2V2ZXJpdHkgdG8gdHVybiBvZmYgYSBydWxlXG4gICAgcmV0dXJuIGlkc1xuICB9LCB7fSlcblxuLy8gV29ya2VyIHN0aWxsIGhhc24ndCBpbml0aWFsaXplZCwgc2luY2UgdGhlIHF1ZXVlZCBpZGxlIGNhbGxiYWNrcyBhcmVcbi8vIGRvbmUgaW4gb3JkZXIsIHdhaXRpbmcgb24gYSBuZXdseSBxdWV1ZWQgaWRsZSBjYWxsYmFjayB3aWxsIGVuc3VyZSB0aGF0XG4vLyB0aGUgd29ya2VyIGhhcyBiZWVuIGluaXRpYWxpemVkXG5jb25zdCB3YWl0T25JZGxlID0gYXN5bmMgKCkgPT5cbiAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCBjYWxsYmFja0lEID0gd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgaWRsZUNhbGxiYWNrcy5kZWxldGUoY2FsbGJhY2tJRClcbiAgICAgIHJlc29sdmUoKVxuICAgIH0pXG4gICAgaWRsZUNhbGxiYWNrcy5hZGQoY2FsbGJhY2tJRClcbiAgfSlcblxuY29uc3QgdmFsaWRTY29wZSA9IGVkaXRvciA9PiBlZGl0b3IuZ2V0Q3Vyc29ycygpLnNvbWUoY3Vyc29yID0+XG4gIGN1cnNvci5nZXRTY29wZURlc2NyaXB0b3IoKS5nZXRTY29wZXNBcnJheSgpLnNvbWUoc2NvcGUgPT5cbiAgICBzY29wZXMuaW5jbHVkZXMoc2NvcGUpKSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFjdGl2YXRlKCkge1xuICAgIGxldCBjYWxsYmFja0lEXG4gICAgY29uc3QgaW5zdGFsbExpbnRlckVzbGludERlcHMgPSAoKSA9PiB7XG4gICAgICBpZGxlQ2FsbGJhY2tzLmRlbGV0ZShjYWxsYmFja0lEKVxuICAgICAgaWYgKCFhdG9tLmluU3BlY01vZGUoKSkge1xuICAgICAgICByZXF1aXJlKCdhdG9tLXBhY2thZ2UtZGVwcycpLmluc3RhbGwoJ2xpbnRlci1lc2xpbnQnKVxuICAgICAgfVxuICAgIH1cbiAgICBjYWxsYmFja0lEID0gd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2soaW5zdGFsbExpbnRlckVzbGludERlcHMpXG4gICAgaWRsZUNhbGxiYWNrcy5hZGQoY2FsbGJhY2tJRClcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKClcbiAgICB0aGlzLndvcmtlciA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEZJWE1FOiBEZXByZWNhdGVkIGVzbGludFJ1bGVzRGlye1N0cmluZ30gb3B0aW9uIGluIGZhdm9yIG9mXG4gICAgICogZXNsaW50UnVsZXNEaXJze0FycmF5PFN0cmluZz59LiBSZW1vdmUgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZSxcbiAgICAgKiBpbiB2OC41LjAsIG9yIGFmdGVyIDIwMTgtMDQuXG4gICAgICovXG4gICAgY29uc3Qgb2xkUnVsZXNkaXIgPSBhdG9tLmNvbmZpZy5nZXQoJ2xpbnRlci1lc2xpbnQuZXNsaW50UnVsZXNEaXInKVxuICAgIGlmIChvbGRSdWxlc2Rpcikge1xuICAgICAgY29uc3QgcnVsZXNEaXJzID0gYXRvbS5jb25maWcuZ2V0KCdsaW50ZXItZXNsaW50LmVzbGludFJ1bGVzRGlycycpXG4gICAgICBpZiAocnVsZXNEaXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBhdG9tLmNvbmZpZy5zZXQoJ2xpbnRlci1lc2xpbnQuZXNsaW50UnVsZXNEaXJzJywgW29sZFJ1bGVzZGlyXSlcbiAgICAgIH1cbiAgICAgIGF0b20uY29uZmlnLnVuc2V0KCdsaW50ZXItZXNsaW50LmVzbGludFJ1bGVzRGlyJylcbiAgICB9XG5cbiAgICBjb25zdCBlbWJlZGRlZFNjb3BlID0gJ3NvdXJjZS5qcy5lbWJlZGRlZC5odG1sJ1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQoYXRvbS5jb25maWcub2JzZXJ2ZShcbiAgICAgICdsaW50ZXItZXNsaW50LmxpbnRIdG1sRmlsZXMnLFxuICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgIGxpbnRIdG1sRmlsZXMgPSB2YWx1ZVxuICAgICAgICBpZiAobGludEh0bWxGaWxlcykge1xuICAgICAgICAgIHNjb3Blcy5wdXNoKGVtYmVkZGVkU2NvcGUpXG4gICAgICAgIH0gZWxzZSBpZiAoc2NvcGVzLmluZGV4T2YoZW1iZWRkZWRTY29wZSkgIT09IC0xKSB7XG4gICAgICAgICAgc2NvcGVzLnNwbGljZShzY29wZXMuaW5kZXhPZihlbWJlZGRlZFNjb3BlKSwgMSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICkpXG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKGF0b20uY29uZmlnLm9ic2VydmUoXG4gICAgICAnbGludGVyLWVzbGludC5zY29wZXMnLFxuICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgIC8vIFJlbW92ZSBhbnkgb2xkIHNjb3Blc1xuICAgICAgICBzY29wZXMuc3BsaWNlKDAsIHNjb3Blcy5sZW5ndGgpXG4gICAgICAgIC8vIEFkZCB0aGUgY3VycmVudCBzY29wZXNcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoc2NvcGVzLCB2YWx1ZSlcbiAgICAgICAgLy8gRW5zdXJlIEhUTUwgbGludGluZyBzdGlsbCB3b3JrcyBpZiB0aGUgc2V0dGluZyBpcyB1cGRhdGVkXG4gICAgICAgIGlmIChsaW50SHRtbEZpbGVzICYmICFzY29wZXMuaW5jbHVkZXMoZW1iZWRkZWRTY29wZSkpIHtcbiAgICAgICAgICBzY29wZXMucHVzaChlbWJlZGRlZFNjb3BlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKSlcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQoYXRvbS53b3Jrc3BhY2Uub2JzZXJ2ZVRleHRFZGl0b3JzKChlZGl0b3IpID0+IHtcbiAgICAgIGVkaXRvci5vbkRpZFNhdmUoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAodmFsaWRTY29wZShlZGl0b3IpICYmIGF0b20uY29uZmlnLmdldCgnbGludGVyLWVzbGludC5maXhPblNhdmUnKSkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuZml4Sm9iKHRydWUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSkpXG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKGF0b20uY29tbWFuZHMuYWRkKCdhdG9tLXRleHQtZWRpdG9yJywge1xuICAgICAgJ2xpbnRlci1lc2xpbnQ6ZGVidWcnOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICghaGVscGVycykge1xuICAgICAgICAgIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgICAgICBhd2FpdCB3YWl0T25JZGxlKClcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWJ1Z1N0cmluZyA9IGF3YWl0IGhlbHBlcnMuZ2VuZXJhdGVEZWJ1Z1N0cmluZyh0aGlzLndvcmtlcilcbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uT3B0aW9ucyA9IHsgZGV0YWlsOiBkZWJ1Z1N0cmluZywgZGlzbWlzc2FibGU6IHRydWUgfVxuICAgICAgICBhdG9tLm5vdGlmaWNhdGlvbnMuYWRkSW5mbygnbGludGVyLWVzbGludCBkZWJ1Z2dpbmcgaW5mb3JtYXRpb24nLCBub3RpZmljYXRpb25PcHRpb25zKVxuICAgICAgfVxuICAgIH0pKVxuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChhdG9tLmNvbW1hbmRzLmFkZCgnYXRvbS10ZXh0LWVkaXRvcicsIHtcbiAgICAgICdsaW50ZXItZXNsaW50OmZpeC1maWxlJzogYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCB0aGlzLmZpeEpvYigpXG4gICAgICB9XG4gICAgfSkpXG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKGF0b20uY29uZmlnLm9ic2VydmUoXG4gICAgICAnbGludGVyLWVzbGludC5zaG93UnVsZUlkSW5NZXNzYWdlJyxcbiAgICAgICh2YWx1ZSkgPT4geyBzaG93UnVsZSA9IHZhbHVlIH1cbiAgICApKVxuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChhdG9tLmNvbmZpZy5vYnNlcnZlKFxuICAgICAgJ2xpbnRlci1lc2xpbnQuZGlzYWJsZVdoZW5Ob0VzbGludENvbmZpZycsXG4gICAgICAodmFsdWUpID0+IHsgZGlzYWJsZVdoZW5Ob0VzbGludENvbmZpZyA9IHZhbHVlIH1cbiAgICApKVxuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChhdG9tLmNvbmZpZy5vYnNlcnZlKFxuICAgICAgJ2xpbnRlci1lc2xpbnQucnVsZXNUb1NpbGVuY2VXaGlsZVR5cGluZycsXG4gICAgICAoaWRzKSA9PiB7IGlnbm9yZWRSdWxlc1doZW5Nb2RpZmllZCA9IGlkc1RvSWdub3JlZFJ1bGVzKGlkcykgfVxuICAgICkpXG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKGF0b20uY29uZmlnLm9ic2VydmUoXG4gICAgICAnbGludGVyLWVzbGludC5ydWxlc1RvRGlzYWJsZVdoaWxlRml4aW5nJyxcbiAgICAgIChpZHMpID0+IHsgaWdub3JlZFJ1bGVzV2hlbkZpeGluZyA9IGlkc1RvSWdub3JlZFJ1bGVzKGlkcykgfVxuICAgICkpXG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKGF0b20uY29uZmlnLm9ic2VydmUoXG4gICAgICAnbGludGVyLWVzbGludC5pZ25vcmVGaXhhYmxlUnVsZXNXaGlsZVR5cGluZycsXG4gICAgICAodmFsdWUpID0+IHsgaWdub3JlRml4YWJsZVJ1bGVzV2hpbGVUeXBpbmcgPSB2YWx1ZSB9XG4gICAgKSlcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQoYXRvbS5jb250ZXh0TWVudS5hZGQoe1xuICAgICAgJ2F0b20tdGV4dC1lZGl0b3I6bm90KC5taW5pKSwgLm92ZXJsYXllcic6IFt7XG4gICAgICAgIGxhYmVsOiAnRVNMaW50IEZpeCcsXG4gICAgICAgIGNvbW1hbmQ6ICdsaW50ZXItZXNsaW50OmZpeC1maWxlJyxcbiAgICAgICAgc2hvdWxkRGlzcGxheTogKGV2dCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZUVkaXRvciA9IGF0b20ud29ya3NwYWNlLmdldEFjdGl2ZVRleHRFZGl0b3IoKVxuICAgICAgICAgIGlmICghYWN0aXZlRWRpdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQmxhY2sgbWFnaWMhXG4gICAgICAgICAgLy8gQ29tcGFyZXMgdGhlIHByaXZhdGUgY29tcG9uZW50IHByb3BlcnR5IG9mIHRoZSBhY3RpdmUgVGV4dEVkaXRvclxuICAgICAgICAgIC8vICAgYWdhaW5zdCB0aGUgY29tcG9uZW50cyBvZiB0aGUgZWxlbWVudHNcbiAgICAgICAgICBjb25zdCBldnRJc0FjdGl2ZUVkaXRvciA9IGV2dC5wYXRoLnNvbWUoZWxlbSA9PlxuICAgICAgICAgICAgLy8gQXRvbSB2MS4xOS4wK1xuICAgICAgICAgICAgKGVsZW0uY29tcG9uZW50ICYmIGFjdGl2ZUVkaXRvci5jb21wb25lbnQgJiZcbiAgICAgICAgICAgICAgZWxlbS5jb21wb25lbnQgPT09IGFjdGl2ZUVkaXRvci5jb21wb25lbnQpKVxuICAgICAgICAgIC8vIE9ubHkgc2hvdyBpZiBpdCB3YXMgdGhlIGFjdGl2ZSBlZGl0b3IgYW5kIGl0IGlzIGEgdmFsaWQgc2NvcGVcbiAgICAgICAgICByZXR1cm4gZXZ0SXNBY3RpdmVFZGl0b3IgJiYgdmFsaWRTY29wZShhY3RpdmVFZGl0b3IpXG4gICAgICAgIH1cbiAgICAgIH1dXG4gICAgfSkpXG5cbiAgICBjb25zdCBpbml0aWFsaXplRVNMaW50V29ya2VyID0gKCkgPT4ge1xuICAgICAgdGhpcy53b3JrZXIgPSBuZXcgVGFzayhyZXF1aXJlLnJlc29sdmUoJy4vd29ya2VyLmpzJykpXG4gICAgfVxuICAgIC8vIEluaXRpYWxpemUgdGhlIHdvcmtlciBkdXJpbmcgYW4gaWRsZSB0aW1lXG4gICAgd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2soaW5pdGlhbGl6ZUVTTGludFdvcmtlcilcbiAgfSxcblxuICBkZWFjdGl2YXRlKCkge1xuICAgIGlmICh0aGlzLndvcmtlciAhPT0gbnVsbCkge1xuICAgICAgdGhpcy53b3JrZXIudGVybWluYXRlKClcbiAgICAgIHRoaXMud29ya2VyID0gbnVsbFxuICAgIH1cbiAgICBpZGxlQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2tJRCA9PiB3aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrKGNhbGxiYWNrSUQpKVxuICAgIGlkbGVDYWxsYmFja3MuY2xlYXIoKVxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5kaXNwb3NlKClcbiAgfSxcblxuICBwcm92aWRlTGludGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiAnRVNMaW50JyxcbiAgICAgIGdyYW1tYXJTY29wZXM6IHNjb3BlcyxcbiAgICAgIHNjb3BlOiAnZmlsZScsXG4gICAgICBsaW50c09uQ2hhbmdlOiB0cnVlLFxuICAgICAgbGludDogYXN5bmMgKHRleHRFZGl0b3IpID0+IHtcbiAgICAgICAgaWYgKCFhdG9tLndvcmtzcGFjZS5pc1RleHRFZGl0b3IodGV4dEVkaXRvcikpIHtcbiAgICAgICAgICAvLyBJZiB3ZSBzb21laG93IGdldCBmZWQgYW4gaW52YWxpZCBUZXh0RWRpdG9yIGp1c3QgaW1tZWRpYXRlbHkgcmV0dXJuXG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpbGVQYXRoID0gdGV4dEVkaXRvci5nZXRQYXRoKClcbiAgICAgICAgaWYgKCFmaWxlUGF0aCkge1xuICAgICAgICAgIC8vIFRoZSBlZGl0b3IgY3VycmVudGx5IGhhcyBubyBwYXRoLCB3ZSBjYW4ndCByZXBvcnQgbWVzc2FnZXMgYmFjayB0b1xuICAgICAgICAgIC8vIExpbnRlciBzbyBqdXN0IHJldHVybiBudWxsXG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWxlUGF0aC5pbmNsdWRlcygnOi8vJykpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgcGF0aCBpcyBhIFVSTCAoTnVjbGlkZSByZW1vdGUgZmlsZSkgcmV0dXJuIGEgbWVzc2FnZVxuICAgICAgICAgIC8vIHRlbGxpbmcgdGhlIHVzZXIgd2UgYXJlIHVuYWJsZSB0byB3b3JrIG9uIHJlbW90ZSBmaWxlcy5cbiAgICAgICAgICByZXR1cm4gaGVscGVycy5nZW5lcmF0ZVVzZXJNZXNzYWdlKHRleHRFZGl0b3IsIHtcbiAgICAgICAgICAgIHNldmVyaXR5OiAnd2FybmluZycsXG4gICAgICAgICAgICBleGNlcnB0OiAnUmVtb3RlIGZpbGUgb3BlbiwgbGludGVyLWVzbGludCBpcyBkaXNhYmxlZCBmb3IgdGhpcyBmaWxlLicsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRleHQgPSB0ZXh0RWRpdG9yLmdldFRleHQoKVxuXG4gICAgICAgIGlmICghaGVscGVycykge1xuICAgICAgICAgIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJ1bGVzID0ge31cbiAgICAgICAgaWYgKHRleHRFZGl0b3IuaXNNb2RpZmllZCgpICYmIE9iamVjdC5rZXlzKGlnbm9yZWRSdWxlc1doZW5Nb2RpZmllZCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJ1bGVzID0gaWdub3JlZFJ1bGVzV2hlbk1vZGlmaWVkXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHRFZGl0b3IuaXNNb2RpZmllZCgpICYmIGlnbm9yZUZpeGFibGVSdWxlc1doaWxlVHlwaW5nKSB7XG4gICAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgbGlzdCB3aWxsIG9ubHkgY29udGFpbiBydWxlcyBhZnRlciB0aGUgZmlyc3QgbGludCBqb2JcbiAgICAgICAgICBydWxlcyA9IGlkc1RvSWdub3JlZFJ1bGVzKGhlbHBlcnMuZ2V0Rml4YWJsZVJ1bGVzKCkpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMud29ya2VyKSB7XG4gICAgICAgICAgYXdhaXQgd2FpdE9uSWRsZSgpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzcG9uc2VcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGhlbHBlcnMuc2VuZEpvYih0aGlzLndvcmtlciwge1xuICAgICAgICAgICAgdHlwZTogJ2xpbnQnLFxuICAgICAgICAgICAgY29udGVudHM6IHRleHQsXG4gICAgICAgICAgICBjb25maWc6IGF0b20uY29uZmlnLmdldCgnbGludGVyLWVzbGludCcpLFxuICAgICAgICAgICAgcnVsZXMsXG4gICAgICAgICAgICBmaWxlUGF0aCxcbiAgICAgICAgICAgIHByb2plY3RQYXRoOiBhdG9tLnByb2plY3QucmVsYXRpdml6ZVBhdGgoZmlsZVBhdGgpWzBdIHx8ICcnXG4gICAgICAgICAgfSlcbiAgICAgICAgICBpZiAodGV4dEVkaXRvci5nZXRUZXh0KCkgIT09IHRleHQpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBUaGUgZWRpdG9yIHRleHQgaGFzIGJlZW4gbW9kaWZpZWQgc2luY2UgdGhlIGxpbnQgd2FzIHRyaWdnZXJlZCxcbiAgICAgICAgICAgIGFzIHdlIGNhbid0IGJlIHN1cmUgdGhhdCB0aGUgcmVzdWx0cyB3aWxsIG1hcCBwcm9wZXJseSBiYWNrIHRvXG4gICAgICAgICAgICB0aGUgbmV3IGNvbnRlbnRzLCBzaW1wbHkgcmV0dXJuIGBudWxsYCB0byB0ZWxsIHRoZVxuICAgICAgICAgICAgYHByb3ZpZGVMaW50ZXJgIGNvbnN1bWVyIG5vdCB0byB1cGRhdGUgdGhlIHNhdmVkIHJlc3VsdHMuXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGhlbHBlcnMucHJvY2Vzc0pvYlJlc3BvbnNlKHJlc3BvbnNlLCB0ZXh0RWRpdG9yLCBzaG93UnVsZSwgdGhpcy53b3JrZXIpXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGhlbHBlcnMuaGFuZGxlRXJyb3IodGV4dEVkaXRvciwgZXJyb3IpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYXN5bmMgZml4Sm9iKGlzU2F2ZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgdGV4dEVkaXRvciA9IGF0b20ud29ya3NwYWNlLmdldEFjdGl2ZVRleHRFZGl0b3IoKVxuXG4gICAgaWYgKCF0ZXh0RWRpdG9yIHx8ICFhdG9tLndvcmtzcGFjZS5pc1RleHRFZGl0b3IodGV4dEVkaXRvcikpIHtcbiAgICAgIC8vIFNpbGVudGx5IHJldHVybiBpZiB0aGUgVGV4dEVkaXRvciBpcyBpbnZhbGlkXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGV4dEVkaXRvci5pc01vZGlmaWVkKCkpIHtcbiAgICAgIC8vIEFib3J0IGZvciBpbnZhbGlkIG9yIHVuc2F2ZWQgdGV4dCBlZGl0b3JzXG4gICAgICBjb25zdCBtZXNzYWdlID0gJ0xpbnRlci1FU0xpbnQ6IFBsZWFzZSBzYXZlIGJlZm9yZSBmaXhpbmcnXG4gICAgICBhdG9tLm5vdGlmaWNhdGlvbnMuYWRkRXJyb3IobWVzc2FnZSlcbiAgICB9XG5cbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbiAgICB9XG4gICAgaWYgKCFpc0NvbmZpZ0F0SG9tZVJvb3QpIHtcbiAgICAgIGlzQ29uZmlnQXRIb21lUm9vdCA9IHJlcXVpcmUoJy4vaXMtY29uZmlnLWF0LWhvbWUtcm9vdCcpXG4gICAgfVxuICAgIGlmICghd29ya2VySGVscGVycykge1xuICAgICAgd29ya2VySGVscGVycyA9IHJlcXVpcmUoJy4vd29ya2VyLWhlbHBlcnMnKVxuICAgIH1cblxuICAgIGNvbnN0IGZpbGVQYXRoID0gdGV4dEVkaXRvci5nZXRQYXRoKClcbiAgICBjb25zdCBmaWxlRGlyID0gcGF0aC5kaXJuYW1lKGZpbGVQYXRoKVxuICAgIGNvbnN0IHByb2plY3RQYXRoID0gYXRvbS5wcm9qZWN0LnJlbGF0aXZpemVQYXRoKGZpbGVQYXRoKVswXVxuXG4gICAgLy8gR2V0IHRoZSB0ZXh0IGZyb20gdGhlIGVkaXRvciwgc28gd2UgY2FuIHVzZSBleGVjdXRlT25UZXh0XG4gICAgY29uc3QgdGV4dCA9IHRleHRFZGl0b3IuZ2V0VGV4dCgpXG4gICAgLy8gRG8gbm90IHRyeSB0byBtYWtlIGZpeGVzIG9uIGFuIGVtcHR5IGZpbGVcbiAgICBpZiAodGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIERvIG5vdCB0cnkgdG8gZml4IGlmIGxpbnRpbmcgc2hvdWxkIGJlIGRpc2FibGVkXG4gICAgY29uc3QgY29uZmlnUGF0aCA9IHdvcmtlckhlbHBlcnMuZ2V0Q29uZmlnUGF0aChmaWxlRGlyKVxuICAgIGNvbnN0IG5vUHJvamVjdENvbmZpZyA9IChjb25maWdQYXRoID09PSBudWxsIHx8IGlzQ29uZmlnQXRIb21lUm9vdChjb25maWdQYXRoKSlcbiAgICBpZiAobm9Qcm9qZWN0Q29uZmlnICYmIGRpc2FibGVXaGVuTm9Fc2xpbnRDb25maWcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBydWxlcyA9IHt9XG4gICAgaWYgKE9iamVjdC5rZXlzKGlnbm9yZWRSdWxlc1doZW5GaXhpbmcpLmxlbmd0aCA+IDApIHtcbiAgICAgIHJ1bGVzID0gaWdub3JlZFJ1bGVzV2hlbkZpeGluZ1xuICAgIH1cblxuICAgIGlmICghaGVscGVycykge1xuICAgICAgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpXG4gICAgfVxuICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgIGF3YWl0IHdhaXRPbklkbGUoKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGhlbHBlcnMuc2VuZEpvYih0aGlzLndvcmtlciwge1xuICAgICAgICB0eXBlOiAnZml4JyxcbiAgICAgICAgY29uZmlnOiBhdG9tLmNvbmZpZy5nZXQoJ2xpbnRlci1lc2xpbnQnKSxcbiAgICAgICAgY29udGVudHM6IHRleHQsXG4gICAgICAgIHJ1bGVzLFxuICAgICAgICBmaWxlUGF0aCxcbiAgICAgICAgcHJvamVjdFBhdGhcbiAgICAgIH0pXG4gICAgICBpZiAoIWlzU2F2ZSkge1xuICAgICAgICBhdG9tLm5vdGlmaWNhdGlvbnMuYWRkU3VjY2VzcyhyZXNwb25zZSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGF0b20ubm90aWZpY2F0aW9ucy5hZGRXYXJuaW5nKGVyci5tZXNzYWdlKVxuICAgIH1cbiAgfSxcbn1cbiJdfQ==