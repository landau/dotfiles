{"version":3,"sources":["../src/Parser.js"],"names":[],"mappings":"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","file":"Parser.js","sourcesContent":["/* @flow */\n\nimport {parse} from 'babylon';\n\nimport type {BabylonToken} from './elementTree';\nimport type Program from './elements/types/Program';\nimport type Token from './elements/Token';\nimport {buildTokenList, buildElementTree} from './elementTree';\nimport type BasePlugin from './plugins/BasePlugin';\n\n/**\n * @typedef {Object} CSTParserOptions\n * @property {String} sourceType Type of parsed code: \"module\" or \"script\".\n * @property {Boolean} allowReturnOutsideFunction\n * @property {Boolean} allowImportExportEverywhere\n * @property {Boolean} allowSuperOutsideMethod\n * @property {CSTParserExperimentalFeatureOptions} experimentalFeatures\n * @property {CSTParserLanguageExtensionsOptions} languageExtensions\n */\n\n/**\n * @typedef {Object} CSTParserLanguageExtensionsOptions\n * @property {Boolean} jsx\n * @property {Boolean} flow\n */\n\n/**\n * @typedef {Object} CSTParserExperimentalFeatureOptions\n * @property {Boolean} 'flow'\n * @property {Boolean} 'jsx'\n * @property {Boolean} 'asyncFunctions'\n * @property {Boolean} 'asyncGenerators'\n * @property {Boolean} 'classConstructorCall'\n * @property {Boolean} 'classProperties'\n * @property {Boolean} 'decorators'\n * @property {Boolean} 'doExpressions'\n * @property {Boolean} 'exponentiationOperator'\n * @property {Boolean} 'exportExtensions'\n * @property {Boolean} 'functionBind'\n * @property {Boolean} 'objectRestSpread'\n * @property {Boolean} 'trailingFunctionCommas\n */\n\n// https://developer.apple.com/library/watchos/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/UIAutomation.html\nconst DIRECTIVE_APPLE_INSTRUMENTATION = {\n    type: 'AppleInstrumentationDirective',\n    regexp: /^#([^\\n]+)/gm\n};\n\n// https://www.chromium.org/developers/web-development-style-guide\nconst DIRECTIVE_GRIT = {\n    type: 'GritDirective',\n    regexp: /^\\s*<(\\/?\\s*(?:if|include)(?!\\w)[^]*?)>/gim\n};\n\n// checking for the options passed to the babel parse method\nexport type CSTParserOptions = {\n    sourceType: 'script' | 'module',\n    allowReturnOutsideFunction: boolean,\n    allowImportExportEverywhere: boolean,\n    allowSuperOutsideMethod: boolean,\n    languageExtensions: Object,\n    experimentalFeatures: Object,\n    strictMode: ?boolean,\n    plugins: BasePlugin[]\n};\n\n/**\n * CST Parser.\n */\nexport default class Parser {\n    /**\n     * @param {CSTParserOptions} options\n     */\n    constructor(options?: CSTParserOptions) {\n        this._options = {\n            sourceType: 'module',\n            strictMode: true,\n            experimentalFeatures: {\n                'flow': true,\n                'jsx': true,\n                'asyncFunctions': true,\n                'asyncGenerators': true,\n                'classConstructorCall': true,\n                'classProperties': true,\n                'decorators': true,\n                'doExpressions': true,\n                'exponentiationOperator': true,\n                'exportExtensions': true,\n                'functionBind': true,\n                'objectRestSpread': true,\n                'trailingFunctionCommas': true\n            },\n            languageExtensions: {\n                jsx: true,\n                flow: true\n            },\n            plugins: []\n        };\n\n        if (options) {\n            this.setOptions(options);\n        }\n    }\n\n    _options: CSTParserOptions;\n\n    /**\n     * @returns {CSTParserOptions}\n     */\n    getOptions(): CSTParserOptions {\n        return this._options;\n    }\n\n    /**\n     * @param {CSTParserOptions} newOptions\n     */\n    setOptions(newOptions: CSTParserOptions) {\n        var currentOptions = this._options;\n        var currentExperimentalFeatures = currentOptions.experimentalFeatures;\n        var currentLanguageExtensions = currentOptions.languageExtensions;\n        var newExperimentalFeatures = newOptions.experimentalFeatures;\n        var newLanguageExtensions = newOptions.languageExtensions;\n        this._options = {\n            ...currentOptions,\n            ...newOptions,\n            experimentalFeatures: {\n                ...currentExperimentalFeatures,\n                ...newExperimentalFeatures\n            },\n            languageExtensions: {\n                ...currentLanguageExtensions,\n                ...newLanguageExtensions\n            }\n        };\n    }\n\n    parse(code: string): Program {\n        let ast = this._parseAst(code);\n        let tokens = this._processTokens(ast, code);\n        let program = buildElementTree(ast, tokens);\n        let programPlugins = {};\n        let plugins = this._options.plugins;\n        for (let plugin of plugins) {\n            let api = plugin.createApiForProgram(program);\n            if (api) {\n                var pluginName = plugin.getPluginName();\n                if (pluginName in programPlugins) {\n                    throw new Error(`Plugin \"${pluginName}\" was already registered.`);\n                } else {\n                    programPlugins[pluginName] = api;\n                }\n            }\n        }\n\n        program._acceptPlugins(programPlugins);\n\n        return program;\n    }\n\n    _parseAst(code: string): Program {\n        let options = this._options;\n        let languageExtensions = options.languageExtensions;\n        let directiveInstances = {};\n        let hasDirectives = false;\n        let directiveTypes = [];\n\n        if (languageExtensions.appleInstrumentationDirectives) {\n            directiveTypes.push(DIRECTIVE_APPLE_INSTRUMENTATION);\n        }\n\n        if (languageExtensions.gritDirectives) {\n            directiveTypes.push(DIRECTIVE_GRIT);\n        }\n\n        for (let directive of directiveTypes) {\n            code = code.replace(directive.regexp, function(str, value, pos) {\n                hasDirectives = true;\n                directiveInstances[pos] = {\n                    type: directive.type, value\n                };\n\n                // Cut 4 characters to save correct line/column info for surrounding code\n                return '/*' + str.slice(4) + '*/';\n            });\n        }\n\n        let ast = parse(code, {\n            sourceType: options.sourceType,\n            strictMode: options.strictMode,\n            allowImportExportEverywhere: options.allowImportExportEverywhere,\n            allowReturnOutsideFunction: options.allowReturnOutsideFunction,\n            allowSuperOutsideMethod: options.allowSuperOutsideMethod,\n            plugins: [\n                ...Object.keys(options.experimentalFeatures),\n                ...Object.keys(options.languageExtensions)\n            ]\n        });\n\n        let program = ast.program;\n        program.tokens = ast.tokens;\n\n        if (hasDirectives) {\n            for (let token of program.tokens) {\n                let directiveInstance = directiveInstances[token.start];\n                if (directiveInstances[token.start]) {\n                    token.type = directiveInstance.type;\n                    token.value = directiveInstance.value;\n                }\n            }\n        }\n\n        if (code.substr(0, 2) === '#!') {\n            program.tokens[0].type = 'Hashbang';\n        }\n\n        return program;\n    }\n\n    _processTokens(ast: Object, code: string): Array<BabylonToken> {\n        return buildTokenList(ast.tokens, code);\n    }\n}\n"]}