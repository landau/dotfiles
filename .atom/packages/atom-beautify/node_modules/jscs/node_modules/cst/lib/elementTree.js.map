{"version":3,"sources":["../src/elementTree.js"],"names":[],"mappings":"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","file":"elementTree.js","sourcesContent":["/* @flow */\n\nimport * as babylon from 'babylon';\n\nimport type Program from './elements/types/Program';\nimport type Location from './elements/Element';\n\nimport visitorKeys from './visitorKeys';\nimport elementIndex from './elements/elementIndex';\nimport Token from './elements/Token';\n\nexport type BabylonToken = {\n    type: string,\n    value: string,\n    start: number,\n    end: number,\n    loc?: Location,\n    sourceCode: string\n};\n\n/**\n * Creates CST using AST and token list.\n *\n * @param {Object} ast\n * @param {Array} tokens\n * @returns {Program}\n */\nexport function buildElementTree(ast: Object, tokens: Array<BabylonToken>): Program {\n    var firstToken = tokens[0];\n    ast.start = firstToken.start;\n    ast.end = tokens[tokens.length - 1].end;\n    return ((buildElementTreeItem(ast, {\n        tokens,\n        token: firstToken,\n        pos: 0\n    }): any): Program);\n}\n\ntype ElementTreeItemState = {\n    tokens: Array<BabylonToken>,\n    token: BabylonToken,\n    pos: number\n};\n\n/**\n * @param {Object} ast\n * @param {{tokens: Array, token: Object, pos: Number}} state\n * @returns {Element}\n */\nfunction buildElementTreeItem(ast: Object, state: ElementTreeItemState): ?Element {\n    var elementType = ast.type;\n    let childProps = visitorKeys[elementType];\n\n    if (!childProps) {\n        throw new Error(`Cannot iterate using ${elementType}`);\n    }\n\n    let childElements = [];\n    for (let i = 0; i < childProps.length; i++) {\n        let childAst = ast[childProps[i]];\n        if (childAst) {\n            if (Array.isArray(childAst)) {\n                for (let j = 0; j < childAst.length; j++) {\n                    if (childAst[j] !== null) {\n                        childElements[childElements.length] = childAst[j];\n                    }\n                }\n            } else {\n                childElements[childElements.length] = childAst;\n            }\n        }\n    }\n\n    childElements.sort((ast1, ast2) => {\n        return ast1.start < ast2.start ? -1 : (ast1.start > ast2.start ? 1 : 0);\n    });\n\n    let NodeClass = elementIndex[elementType];\n\n    if (!NodeClass) {\n        throw new Error(`Cannot create ${elementType} instance`);\n    }\n\n    let children = [];\n    let childElementIndex = 0;\n    let childElement = childElements[0];\n    let end = ast.end;\n\n    do {\n        if (childElement && state.token.start === childElement.start) {\n            if (state.token.end > childElement.end) {\n                let EmptyNodeClass = elementIndex[childElement.type];\n                if (!EmptyNodeClass) {\n                    throw new Error(`Cannot create ${childElement.type} instance`);\n                }\n\n                children[children.length] = new EmptyNodeClass([]);\n                childElement = childElements[++childElementIndex];\n            } else {\n                children[children.length] = buildElementTreeItem(childElement, state);\n                childElement = childElements[++childElementIndex];\n\n                if (!state.token ||\n                    (state.token.start === end && (state.token.end !== end || elementType !== 'Program'))\n                ) {\n                    return new NodeClass(children);\n                }\n            }\n        } else {\n            let endOfAstReached = state.token.end === end;\n            let addedTokenType = state.token.type;\n\n            if (endOfAstReached && ast.type === 'Identifier' && addedTokenType === 'Keyword') {\n                state.token.type = addedTokenType = 'Identifier';\n            }\n\n            children[children.length] = Token.createFromToken(state.token);\n\n            state.pos++;\n            state.token = state.tokens[state.pos];\n\n            if (elementType === 'Program' && addedTokenType !== 'EOF') {\n                continue;\n            }\n\n            if (endOfAstReached) {\n                return new NodeClass(children);\n            }\n        }\n    } while (state.token);\n}\n\n/**\n * Build single token list using code tokens, comments and whitespace.\n *\n * @param {Array} codeTokens\n * @param {String} code\n * @returns {Array}\n */\nexport function buildTokenList(codeTokens: Array<BabylonToken>, code: string): Array<BabylonToken> {\n    let prevPos = 0;\n    let result = [];\n\n    for (var i = 0; i < codeTokens.length; i++) {\n        let token = processToken(codeTokens[i], code);\n\n        let pos = token.start;\n        if (prevPos !== pos) {\n            let value = code.substring(prevPos, pos);\n            result[result.length] = {\n                type: 'Whitespace',\n                value,\n                sourceCode: value,\n                start: prevPos,\n                end: pos\n            };\n        }\n        result[result.length] = token;\n\n        prevPos = token.end;\n    }\n\n    return result;\n}\n\n/**\n * Babylon token types.\n */\nlet tt = babylon.tokTypes;\n\n/**\n * Transforms Babylon-style token to Esprima-style token.\n *\n * @param {Object} token\n * @param {String} source\n */\nfunction processToken(token: Object, source: string): BabylonToken {\n    var type = token.type;\n\n    if (type === tt.name) {\n        token.type = 'Identifier';\n    } else if (type === tt.semi || type === tt.comma ||\n        type === tt.parenL || type === tt.parenR ||\n        type === tt.braceL || type === tt.braceR ||\n        type === tt.slash || type === tt.dot ||\n        type === tt.bracketL || type === tt.bracketR ||\n        type === tt.ellipsis || type === tt.arrow ||\n        type === tt.star || type === tt.incDec ||\n        type === tt.colon || type === tt.question ||\n        type === tt.backQuote ||\n        type === tt.dollarBraceL || type === tt.at ||\n        type === tt.logicalOR || type === tt.logicalAND ||\n        type === tt.bitwiseOR || type === tt.bitwiseXOR ||\n        type === tt.bitwiseAND || type === tt.equality ||\n        type === tt.relational || type === tt.bitShift ||\n        type === tt.plusMin || type === tt.modulo ||\n        type === tt.exponent || type === tt.prefix ||\n        type === tt.doubleColon ||\n        type.isAssign) {\n        token.type = 'Punctuator';\n        if (!token.value) {\n            token.sourceCode = token.value = type.label;\n        }\n    } else if (type === tt.template) {\n        token.type = 'Template';\n        token.sourceCode = token.value;\n    } else if (type === tt.jsxTagStart) {\n        token.type = 'Punctuator';\n        token.sourceCode = token.value = '<';\n    } else if (type === tt.jsxTagEnd) {\n        token.type = 'Punctuator';\n        token.sourceCode = token.value = '>';\n    } else if (type === tt.jsxName) {\n        token.type = 'JSXIdentifier';\n    } else if (type === tt.jsxText) {\n        token.type = 'JSXText';\n    } else if (type.keyword === 'null') {\n        token.type = 'Null';\n        token.value = null;\n    } else if (type.keyword === 'false' || type.keyword === 'true') {\n        token.type = 'Boolean';\n        token.value = type.keyword === 'true';\n    } else if (type.keyword) {\n        token.type = 'Keyword';\n    } else if (type === tt.num) {\n        token.type = 'Numeric';\n    } else if (type === tt.string) {\n        token.type = 'String';\n    } else if (type === tt.regexp) {\n        token.type = 'RegularExpression';\n    } else if (type === 'CommentLine') {\n        token.sourceCode = '//' + token.value;\n    } else if (type === 'CommentBlock') {\n        token.sourceCode = '/*' + token.value + '*/';\n    } else if (type === tt.eof) {\n        token.type = 'EOF';\n        token.sourceCode = token.value = '';\n    }\n\n    if (!('sourceCode' in token)) {\n        token.sourceCode = source.slice(token.start, token.end);\n    }\n\n    return token;\n}\n"]}