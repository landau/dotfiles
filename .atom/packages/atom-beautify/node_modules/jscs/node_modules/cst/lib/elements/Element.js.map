{"version":3,"sources":["../../src/elements/Element.js"],"names":[],"mappings":"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","file":"Element.js","sourcesContent":["/* @flow */\n\nimport type Program from './types/Program';\nimport {getLines} from '../utils/lines';\nimport ElementAssert from './ElementAssert';\n\nexport type Position = {\n    line: number,\n    column: number\n};\n\nexport type Location = {\n    start: Position,\n    end: Position\n};\n\nexport type Range = [\n    number,\n    number\n];\n\n/**\n * Base class for Node, Token and Fragment.\n *\n * @name Element\n * @class\n * @abstract\n */\nexport default class Element {\n    /**\n     * @param {String} type\n     * @param {Element[]} children\n     */\n    constructor(type: string, children: Array<Element>) {\n        this.type = type;\n\n        this.firstChild = null;\n        this.lastChild = null;\n        this.parentElement = null;\n        this.nextSibling = null;\n        this.previousSibling = null;\n        this.childElements = [];\n\n        if (children) {\n            for (let i = 0; i < children.length; i++) {\n                if (children[i].parentElement) {\n                    throw new Error('Cannot add element to several parents');\n                }\n            }\n            this._setChildren(children);\n        }\n\n        this.isToken = false;\n        this.isWhitespace = false;\n        this.isCode = true;\n        this.isComment = false;\n        this.isNonCodeToken = this.isComment || this.isWhitespace;\n        this.isNode = false;\n        this.isStatement = false;\n        this.isPattern = false;\n        this.isAssignable = false;\n        this.isFragment = false;\n\n    }\n\n    type: string;\n    firstChild: ?Element;\n    lastChild: ?Element;\n    parentElement: ?Element;\n    nextSibling: ?Element;\n    previousSibling: ?Element;\n    childElements: Array<Element>;\n    _onSetParentElement: ?((parentElement: ?Element) => void);\n\n    isModuleSpecifier: boolean;\n\n    // ==== Traversing =================================================================================================\n\n    /**\n     * Owner Program for this element or null if element does not have Program in its parent hierarchy.\n     *\n     * @returns {Program}\n     */\n    getOwnerProgram(): Program {\n        let element = this;\n        while (element && !element._isProgram) {\n            element = element.parentElement;\n        }\n        return ((element: any): Program);\n    }\n\n    getNextToken() {\n        var element = this;\n        while (element) {\n            if (element.nextSibling) {\n                return element.nextSibling.getFirstToken();\n            }\n\n            element = element.parentElement;\n        }\n\n        return null;\n    }\n\n    getPreviousToken() {\n        var element = this;\n        while (element) {\n            if (element.previousSibling) {\n                return element.previousSibling.getLastToken();\n            }\n\n            element = element.parentElement;\n        }\n\n        return null;\n    }\n\n    /**\n     * Next token (non-whitespace and non-comment). Null if token was not found.\n     *\n     * @returns {Element|null}\n     */\n    getNextCodeToken(): ?Element {\n        let token = this.getNextToken();\n        while (token && !token.isCode) {\n            token = token.getNextToken();\n        }\n        return token;\n    }\n\n    /**\n     * Previous token (non-whitespace and non-comment). Null if token was not found.\n     *\n     * @returns {Element|null}\n     */\n    getPreviousCodeToken(): ?Element {\n        let token = this.getPreviousToken();\n        while (token && !token.isCode) {\n            token = token.getPreviousToken();\n        }\n        return token;\n    }\n\n    /**\n     * Next non-whitespace token. Null if token was not found.\n     *\n     * @returns {Element|null}\n     */\n    getNextNonWhitespaceToken(): ?Element {\n        let token = this.getNextToken();\n        while (token && token.isWhitespace) {\n            token = token.getNextToken();\n        }\n        return token;\n    }\n\n    /**\n     * Previous non-whitespace token. Null if token was not found.\n     *\n     * @returns {Element|null}\n     */\n    getPreviousNonWhitespaceToken(): ?Element {\n        let token = this.getPreviousToken();\n        while (token && token.isWhitespace) {\n            token = token.getPreviousToken();\n        }\n        return token;\n    }\n\n    /**\n     * First token inside element child tree.\n     *\n     * @returns {Element|null}\n     */\n    getFirstToken(): ?Element {\n        let element = this.firstChild;\n        while (element && !element.isToken) {\n            element = element.firstChild;\n        }\n        return element;\n    }\n\n    /**\n     * Last token inside element child tree.\n     *\n     * @returns {Element|null}\n     */\n    getLastToken(): ?Element {\n        let element = this.lastChild;\n        while (element && !element.isToken) {\n            element = element.lastChild;\n        }\n        return element;\n    }\n\n    /**\n     * Calculates and returns Element range.\n     *\n     * @returns {Number[]}\n     */\n    getRange(): Range {\n        let counter = 0;\n\n        let previous = this.getPreviousToken();\n        while (previous) {\n            counter += previous._sourceCodeLength;\n            previous = previous.getPreviousToken();\n        }\n\n        return [counter, counter + this.getSourceCodeLength()];\n    }\n\n    /**\n     * Calculates and returns Element loc.\n     *\n     * @returns {Object}\n     */\n    getLoc(): Location {\n        let prevToken = this.getPreviousToken();\n        let startColumn = 0;\n        let startLine = 1;\n        while (prevToken) {\n            let lines = prevToken._sourceCodeLines;\n            startColumn += lines[lines.length - 1].length;\n            if (lines.length > 1) {\n                while (prevToken) {\n                    startLine += prevToken.getNewlineCount();\n                    prevToken = prevToken.getPreviousToken();\n                }\n                break;\n            }\n            prevToken = prevToken.getPreviousToken();\n        }\n\n        let elementLines = this.getSourceCodeLines();\n        let endLine = startLine + elementLines.length - 1;\n        let endColumn = elementLines[elementLines.length - 1].length;\n\n        if (startLine === endLine) {\n            endColumn += startColumn;\n        }\n\n        return {\n            start: {\n                line: startLine,\n                column: startColumn\n            },\n            end: {\n                line: endLine,\n                column: endColumn\n            }\n        };\n    }\n\n    // ==== Source Code ================================================================================================\n\n    /**\n     * Generated source code length.\n     *\n     * @returns {Number}\n     */\n    getSourceCodeLength(): number {\n        let length = 0;\n        let child = this.firstChild;\n        while (child) {\n            length += child.getSourceCodeLength();\n            child = child.nextSibling;\n        }\n        return length;\n    }\n\n    /**\n     * Generated source code.\n     *\n     * @returns {String}\n     */\n    getSourceCode(): string {\n        let code = '';\n        let child = this.firstChild;\n        while (child) {\n            code += child.getSourceCode();\n            child = child.nextSibling;\n        }\n        return code;\n    }\n\n    /**\n     * Generated source code lines.\n     *\n     * @returns {String[]}\n     */\n    getSourceCodeLines(): Array<string> {\n        return getLines(this.getSourceCode());\n    }\n\n    /**\n     * Generated source code line break count.\n     *\n     * @returns {Number}\n     */\n    getNewlineCount(): number {\n        let count = 0;\n        let child = this.firstChild;\n        while (child) {\n            count += child.getNewlineCount();\n            child = child.nextSibling;\n        }\n        return count;\n    }\n\n    // ==== Child Element Manipulation =================================================================================\n\n    /**\n     * Removes specified element from the element child list.\n     *\n     * @param {Element} element\n     *\n     * @returns {Element}\n     */\n    removeChild(element: Element): Element {\n        if (element.parentElement !== this) {\n            throw new Error('The element to be removed is not a child of this element.');\n        }\n\n        let children = this.childElements.concat();\n        let elementIndex = children.indexOf(element);\n        children.splice(elementIndex, 1);\n\n        this._setChildren(children);\n\n        let ownerProgram = this.getOwnerProgram();\n        if (ownerProgram) {\n            ownerProgram._removeElementsFromProgram([element]);\n        }\n\n        setParentElement(element, null);\n\n        return element;\n    }\n\n    /**\n     * Removes element.\n     */\n    remove() {\n        if (!this.parentElement) {\n            return;\n        }\n\n        this.parentElement.removeChild(this);\n    }\n\n    /**\n     * Appends specified element to the end of the child list.\n     * Accepts multiple nodes using `Fragment`.\n     *\n     * @param {Element} newElement\n     */\n    appendChild(newElement: Element) {\n        let children: Element[];\n        let newElements: Element[];\n        if (newElement.isFragment) {\n            this._ensureCanAdoptFragment(newElement);\n            newElements = newElement.childElements;\n            children = this.childElements.concat(newElement.childElements);\n        } else {\n            if (newElement.parentElement) {\n                throw new Error('Remove element before adding again');\n            }\n            this._ensureCanAdopt(newElement);\n            newElements = [newElement];\n            children = this.childElements.concat(newElement);\n        }\n\n        this._setChildren(children);\n\n        if (newElements) {\n            let ownerProgram = this.getOwnerProgram();\n            if (ownerProgram) {\n                ownerProgram._addElementsToProgram(newElements);\n            }\n        }\n    }\n\n    /**\n     * Prepends specified element to the beginning of the child list.\n     * Accepts multiple nodes using `Fragment`.\n     *\n     * @param {Element} newElement\n     */\n    prependChild(newElement: Element) {\n        let children: Element[];\n        let newElements: Element[];\n        if (newElement.isFragment) {\n            this._ensureCanAdoptFragment(newElement);\n            newElements = newElement.childElements;\n            children = newElement.childElements.concat(this.childElements);\n        } else {\n            if (newElement.parentElement) {\n                throw new Error('Remove element before adding again');\n            }\n            this._ensureCanAdopt(newElement);\n            newElements = [newElement];\n            children = [newElement].concat(this.childElements);\n        }\n\n        this._setChildren(children);\n\n        if (newElements) {\n            let ownerProgram = this.getOwnerProgram();\n            if (ownerProgram) {\n                ownerProgram._addElementsToProgram(newElements);\n            }\n        }\n    }\n\n    /**\n     * Inserts specified element before specified reference child.\n     * Accepts multiple nodes using `Fragment`.\n     *\n     * @param {Element} newElement\n     * @param {Element} referenceChild\n     */\n    insertChildBefore(newElement: Element, referenceChild: Element) {\n        if (referenceChild.parentElement !== this) {\n            throw new Error('Invalid reference child');\n        }\n\n        let index = this.childElements.indexOf(referenceChild);\n        let childrenBefore = this.childElements.slice(0, index);\n        let childrenAfter = this.childElements.slice(index);\n\n        let children: Element[];\n        let newElements: Element[];\n        if (newElement.isFragment) {\n            this._ensureCanAdoptFragment(newElement);\n            newElements = newElement.childElements;\n            children = childrenBefore.concat(newElement.childElements, childrenAfter);\n        } else {\n            if (newElement.parentElement) {\n                throw new Error('Remove element before adding again');\n            }\n\n            this._ensureCanAdopt(newElement);\n            children = childrenBefore.concat(newElement, childrenAfter);\n            newElements = [newElement];\n        }\n\n        this._setChildren(children);\n\n        if (newElements) {\n            let ownerProgram = this.getOwnerProgram();\n            if (ownerProgram) {\n                ownerProgram._addElementsToProgram(newElements);\n            }\n        }\n    }\n\n    /**\n     * Replaces children from `firstRefChild` to `lastRefChild` with specified element.\n     * Accepts multiple replacement nodes using `Fragment`.\n     *\n     * @param {Element} newElement\n     * @param {Element} firstRefChild\n     * @param {Element} lastRefChild\n     */\n    replaceChildren(newElement: Element, firstRefChild: Element, lastRefChild: Element) {\n        if (!firstRefChild || firstRefChild.parentElement !== this) {\n            throw new Error('Invalid first reference child');\n        }\n\n        if (!lastRefChild || lastRefChild.parentElement !== this) {\n            throw new Error('Invalid last reference child');\n        }\n\n        let firstIndex = this.childElements.indexOf(firstRefChild);\n        let lastIndex = this.childElements.indexOf(lastRefChild);\n\n        if (firstIndex > lastIndex) {\n            throw new Error('Invalid reference children order');\n        }\n\n        let childrenBefore = this.childElements.slice(0, firstIndex);\n        let childrenAfter = this.childElements.slice(lastIndex + 1);\n        let replacedChildren = this.childElements.slice(firstIndex, lastIndex + 1);\n\n        let children: Element[];\n        let newElements: Element[];\n        if (newElement.isFragment) {\n            this._ensureCanAdoptFragment(newElement);\n            children = childrenBefore.concat(newElement.childElements, childrenAfter);\n            newElements = newElement.childElements;\n        } else {\n            if (newElement.parentElement) {\n                throw new Error('Remove element before adding again');\n            }\n\n            this._ensureCanAdopt(newElement);\n            children = childrenBefore.concat(newElement, childrenAfter);\n            newElements = [newElement];\n        }\n\n        this._setChildren(children);\n\n        let ownerProgram = this.getOwnerProgram();\n\n        if (ownerProgram) {\n            ownerProgram._removeElementsFromProgram(replacedChildren);\n        }\n\n        for (let i = 0; i < replacedChildren.length; i++) {\n            let replacedChild = replacedChildren[i];\n            replacedChild.previousSibling = null;\n            replacedChild.nextSibling = null;\n            setParentElement(replacedChild, null);\n        }\n\n        if (ownerProgram && newElements) {\n            ownerProgram._addElementsToProgram(newElements);\n        }\n    }\n\n    /**\n     * Removes children from `firstRefChild` to `lastRefChild` with specified element.\n     *\n     * @param {Element} firstRefChild\n     * @param {Element} lastRefChild\n     */\n    removeChildren(firstRefChild: Element, lastRefChild: Element) {\n        if (!firstRefChild || firstRefChild.parentElement !== this) {\n            throw new Error('Invalid first reference child');\n        }\n\n        if (!lastRefChild || lastRefChild.parentElement !== this) {\n            throw new Error('Invalid last reference child');\n        }\n\n        let firstIndex = this.childElements.indexOf(firstRefChild);\n        let lastIndex = this.childElements.indexOf(lastRefChild);\n\n        if (firstIndex > lastIndex) {\n            throw new Error('Invalid reference children order');\n        }\n\n        let children = this.childElements.slice(0, firstIndex).concat(this.childElements.slice(lastIndex + 1));\n        let removedChildren = this.childElements.slice(firstIndex, lastIndex + 1);\n\n        this._setChildren(children);\n\n        let ownerProgram = this.getOwnerProgram();\n\n        if (ownerProgram) {\n            ownerProgram._removeElementsFromProgram(removedChildren);\n        }\n\n        for (let i = 0; i < removedChildren.length; i++) {\n            let removedChild = removedChildren[i];\n            removedChild.previousSibling = null;\n            removedChild.nextSibling = null;\n            setParentElement(removedChild, null);\n        }\n    }\n\n    /**\n     * Replaces child with specified element.\n     * Accepts multiple replacement nodes using `Fragment`.\n     *\n     * @param {Element} newElement\n     * @param {Element} oldElement\n     */\n    replaceChild(newElement: Element, oldElement: Element) {\n        this.replaceChildren(newElement, oldElement, oldElement);\n    }\n\n    /**\n     * Returns array of child element from firstRefChild to lastRefChild (including reference children).\n     *\n     * @param {Element} firstRefChild\n     * @param {Element} lastRefChild\n     * @returns {Array}\n     */\n    getChildrenBetween(firstRefChild: Element, lastRefChild: Element): Array<Element> {\n        if (!firstRefChild || firstRefChild.parentElement !== this) {\n            throw new Error('Invalid first reference child');\n        }\n\n        if (!lastRefChild || lastRefChild.parentElement !== this) {\n            throw new Error('Invalid last reference child');\n        }\n\n        let firstIndex = this.childElements.indexOf(firstRefChild);\n        let lastIndex = this.childElements.indexOf(lastRefChild);\n\n        if (firstIndex > lastIndex) {\n            throw new Error('Invalid reference children order');\n        }\n\n        return this.childElements.slice(firstIndex, lastIndex + 1);\n    }\n\n    /**\n     * Makes sure specified child is not already one of the parents of this element.\n     * Throws error on failure.\n     *\n     * @param {Element} child\n     * @private\n     */\n    _ensureCanAdopt(child: Element) {\n        let element = this;\n        while (element) {\n            if (element === child) {\n                throw new Error('The new child element contains the parent.');\n            }\n            element = element.parentElement;\n        }\n    }\n\n    /**\n     * Calls _ensureCanAdopt for each fragment element.\n     *\n     * @param {Element} fragment\n     * @private\n     */\n    _ensureCanAdoptFragment(fragment: Element) {\n        let fragmentChild = fragment.firstChild;\n        while (fragmentChild) {\n            this._ensureCanAdopt(fragmentChild);\n            fragmentChild = fragmentChild.nextSibling;\n        }\n    }\n\n    /**\n     * Assigns new children. Runs element syntax assertions.\n     *\n     * @param {Element[]} newChildren\n     * @private\n     */\n    _setChildren(newChildren: Element[]) {\n        this._acceptChildren(new ElementAssert(newChildren));\n\n        if (newChildren.length > 0) {\n            let previousChild = newChildren[0];\n            this.firstChild = previousChild;\n            previousChild.previousSibling = null;\n            setParentElement(previousChild, this);\n            if (newChildren.length > 1) {\n                // TODO(flow): error with only `let child;`\n                let child = newChildren[1];\n                for (let i = 1; i < newChildren.length; i++) {\n                    child = newChildren[i];\n                    child.previousSibling = previousChild;\n                    setParentElement(child, this);\n                    previousChild.nextSibling = child;\n                    previousChild = child;\n                }\n                child.nextSibling = null;\n                this.lastChild = child;\n            } else {\n                previousChild.nextSibling = null;\n                this.lastChild = previousChild;\n            }\n        } else {\n            this.firstChild = this.lastChild = null;\n        }\n\n        this.childElements = newChildren;\n    }\n\n    /**\n     * Runs element syntax assertions. Should be implemented for every Node.\n     *\n     * @param {Object} children\n     * @abstract\n     */\n    _acceptChildren(children: ElementAssert): void {\n        // Override\n    }\n\n    /**\n     * Clones current Element structure.\n     *\n     * @returns {Element}\n     */\n    cloneElement(): Element {\n        let clonedChildren: Element[] = new Array(this.childElements.length);\n        for (let i = 0; i < clonedChildren.length; i++) {\n            clonedChildren[i] = this.childElements[i].cloneElement();\n        }\n        let objectToClone = ((this: any): ConcreteElement);\n        return new objectToClone.constructor(clonedChildren);\n    }\n}\n\n/**\n * Artificial class for correct flow behaviour.\n */\nclass ConcreteElement extends Element {\n    constructor(children: Element[]) {\n        super('ConcreteElement', children);\n    }\n}\n\nfunction setParentElement(element: Element, parentElement: ?Element) {\n    element.parentElement = parentElement;\n    if (element._onSetParentElement) {\n        element._onSetParentElement(parentElement);\n    }\n}\n"]}