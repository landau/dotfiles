{"version":3,"sources":["../../src/elements/ElementAssert.js"],"names":[],"mappings":"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","file":"ElementAssert.js","sourcesContent":["/* @flow */\n\nimport type Element from './Element';\n\n/**\n * Element assertion class.\n * Used in specific Node types to check children for syntax correctness.\n *\n */\nexport default class ElementAssert {\n    /**\n     * @param {Element[]} elements\n     */\n    constructor(elements: Array<Element>) {\n        this._elements = elements;\n\n        if (elements.length > 0) {\n            this._navigate(0);\n        }\n    }\n\n    _elements: Array<Element>;\n    currentElement: ?Element;\n    _position: number;\n\n    /**\n     * Asserts that the current element is a token.\n     * Can also check for token type and value.\n     *\n     * @param {String} [tokenType]\n     * @param {String|Object} [tokenValue] if object is given, checks if value of token exists as object key.\n     */\n    assertToken(tokenType: string, tokenValue: string | Object): void {\n        let {isToken, type, value} = this.currentElement || {};\n\n        if (!isToken) {\n            throw new Error(`Token expected but \"${type}\" found`);\n        }\n\n        if (arguments.length > 0 && type !== tokenType) {\n            throw new Error(`Expected token type \"${tokenType}\" but \"${type}\" found`);\n        }\n\n        if (arguments.length === 2) {\n            if (typeof tokenValue === 'object' && tokenValue !== null) {\n                if (!tokenValue[value]) {\n                    throw new Error(`Expected token value (${Object.keys(tokenValue).join(', ')}) but ${value} found`);\n                }\n            } else if (tokenValue !== value) {\n                throw new Error(`Expected token value \"${tokenValue}\" but ${value} found`);\n            }\n        }\n    }\n\n    /**\n     * Asserts that the current element is a node.\n     * Can also check for node type.\n     *\n     * @param {String} nodeType\n     */\n    assertNode(nodeType: string): void {\n        let {isNode, type} = this.currentElement || {};\n\n        if (!isNode) {\n            throw new Error(`Node expected but \"${type}\" found`);\n        }\n\n        if (arguments.length > 0 && type !== nodeType) {\n            throw new Error(`Expected node type \"${nodeType}\" but \"${type}\" found`);\n        }\n    }\n\n    /**\n     * Asserts that the current element is a node.\n     * Can also check if any of the node type are satisfied.\n     *\n     * @param {Array} nodeTypes\n     */\n    assertOneOfNode(nodeTypes: Array<string>): void {\n        let {isNode, type} = this.currentElement || {};\n\n        if (!isNode) {\n            throw new Error(`Node expected but \"${type}\" found`);\n        }\n\n        if (arguments.length > 0 && nodeTypes.indexOf(type) === -1) {\n            throw new Error(`Expected one of node types \"${nodeTypes}\" but \"${type}\" found`);\n        }\n    }\n\n    /**\n     * Asserts that the current element is an expression.\n     */\n    assertExpression(): void {\n        let {isExpression, type} = this.currentElement || {};\n\n        if (!isExpression) {\n            throw new Error(`Expression expected but \"${type}\" found`);\n        }\n    }\n\n    /**\n     * Asserts that the current element is an assignment.\n     */\n    assertAssignable(): void {\n        let {isAssignable, type} = this.currentElement || {};\n\n        if (!isAssignable) {\n            throw new Error(`Expected assignable expression but ${type} found.`);\n        }\n    }\n\n    /**\n     * Asserts that the current element is a pattern.\n     */\n    assertPattern(): void {\n        let {isPattern, type} = this.currentElement || {};\n\n        if (!isPattern) {\n            throw new Error(`Expected pattern but ${type} found.`);\n        }\n    }\n\n    /**\n     * Asserts that the current element is a statement.\n     */\n    assertStatement(): void {\n        let {isStatement, type} = this.currentElement || {};\n\n        if (!isStatement) {\n            throw new Error(`Statement expected but \"${type}\" found`);\n        }\n    }\n\n    /**\n     * Asserts that the current element is a statement.\n     */\n    assertModuleSpecifier(): void {\n        let {isModuleSpecifier, type} = this.currentElement || {};\n\n        if (!isModuleSpecifier) {\n            throw new Error(`ModuleSpecifier expected but \"${type}\" found`);\n        }\n    }\n\n    /**\n     * Asserts that the end of child list was reached.\n     */\n    assertEnd(): void {\n        if (this.currentElement !== undefined) {\n            let {type} = this.currentElement || {};\n            throw new Error(`Expected end of node list but \"${type}\" found`);\n        }\n    }\n\n    /**\n     * Checks if the current element is a token.\n     * Can also check for token type and value.\n     *\n     * @param {String} [tokenType]\n     * @param {String|Object} [tokenValue] if object is given, checks if value of token exists as object key.\n     * @returns {Boolean}\n     */\n    isToken(tokenType: string, tokenValue?: string | Object): boolean {\n        let {isToken, type, value} = this.currentElement || {};\n\n        if (!isToken || (arguments.length > 0 && type !== tokenType)) {\n            return false;\n        }\n\n        if (arguments.length === 2) {\n            if (typeof tokenValue === 'object' && tokenValue !== null) {\n                return Boolean(tokenValue[value]);\n            }\n            return tokenValue === value;\n        }\n\n        return true;\n    }\n\n    /**\n     * Checks if the current element is a node.\n     * Can also check for token type and value.\n     *\n     * @param {String} [nodeType]\n     * @returns {Boolean}\n     */\n    isNode(nodeType: string): boolean {\n        let {isNode, type} = this.currentElement || {};\n\n        return !(!isNode || (arguments.length > 0 && type !== nodeType));\n    }\n\n    /**\n     * Checks if the current element is a statement.\n     *\n     * @returns {Boolean}\n     */\n    isStatement(): boolean {\n        let {isStatement} = this.currentElement || {};\n\n        return isStatement;\n    }\n\n    /**\n     * Checks if current element is token (can also check type and value),\n     * returns current element and move pointer to the next element.\n     *\n     * @param {String} [tokenType]\n     * @param {String|Object} [tokenValue]\n     * @returns {Element|null}\n     */\n    passToken(tokenType: string, tokenValue?: string | Object): ?Element {\n        this.assertToken.apply(this, arguments);\n        let token = this.currentElement;\n        this.moveNext();\n        return token;\n    }\n\n    /**\n     * Checks if current element is a node (can also check type),\n     * returns current element and move pointer to the next element.\n     *\n     * @param {String} [nodeType]\n     * @returns {Element|null}\n     */\n    passNode(nodeType: string): ?Element {\n        this.assertNode.apply(this, arguments);\n        let node = this.currentElement;\n        this.moveNext();\n        return node;\n    }\n\n    /**\n     * Checks if current element is a node (can also check if any types are satisfied),\n     * returns current element and move pointer to the next element.\n     *\n     * @param {Array} [nodeTypes]\n     * @returns {Element|null}\n     */\n    passOneOfNode(nodeTypes: Array<string>): ?Element {\n        this.assertOneOfNode(nodeTypes);\n        let node = this.currentElement;\n        this.moveNext();\n        return node;\n    }\n\n    /**\n     * Checks if current element is an expression,\n     * returns current element and move pointer to the next element.\n     * Ignores parentheses.\n     *\n     * @returns {Element}\n     */\n    passExpression(): Element {\n        return this._passExpressionInParens(expression => expression.isExpression);\n    }\n\n    /**\n     * Checks if current element is an expression or whitespace\n     * returns current element and move pointer to the next element.\n     * Ignores parentheses.\n     *\n     * @returns {Element}\n     */\n    passExpressionOrWhitespace(): Element {\n        return this._passExpressionInParens(expression => expression.isExpression || expression.isWhitespace);\n    }\n\n    /**\n     * Checks if current element is an expression or super,\n     * returns current element and move pointer to the next element.\n     * Ignores parentheses.\n     *\n     * @returns {Element}\n     */\n    passExpressionOrSuper(): Element {\n        return this._passExpressionInParens(expression => expression.isExpression || expression.type === 'Super');\n    }\n\n    /**\n     * Checks if current element is an expression or SpreadElement,\n     * returns current element and move pointer to the next element.\n     * Ignores parentheses.\n     *\n     * @returns {Element}\n     */\n    passExpressionOrSpreadElement(): Element {\n        return this._passExpressionInParens(\n            expression => expression.isExpression || expression.type === 'SpreadElement');\n    }\n\n    /**\n     * Passes expression ignoring parentheses, returns element and move pointer to the next element.\n     *\n     * @param {Function} assertCallback\n     * @returns {Element}\n     * @private\n     */\n    _passExpressionInParens(assertCallback: Function): Element {\n        let openParens = 0;\n\n        while (this.currentElement.type === 'Punctuator' && this.currentElement.value === '(') {\n            openParens++;\n            this.moveNext();\n            this.skipNonCode();\n        }\n\n        let expression = this.currentElement;\n\n        if (!expression) {\n            throw new Error('Could not match an expression');\n        }\n\n        if (!assertCallback(expression)) {\n            throw new Error(`Expression expected but \"${expression.type}\" found`);\n        }\n\n        this.moveNext();\n\n        while (openParens--) {\n            this.skipNonCode();\n            this.assertToken('Punctuator', ')');\n            this.moveNext();\n        }\n\n        return expression;\n    }\n\n    /**\n     * Checks if current element is an assignable, returns current element and move pointer to the next element.\n     * Ignores parentheses.\n     *\n     * @returns {Element}\n     */\n    passAssignable(): Element {\n        return this._passExpressionInParens(expression => expression.isAssignable);\n    }\n\n    /**\n     * Checks if current element is a statement,\n     * returns current element and move pointer to the next element.\n     *\n     * @returns {Element}\n     */\n    passStatement(): Element {\n        this.assertStatement();\n        let result = this.currentElement;\n        this.moveNext();\n        if (!result) {\n            throw new Error('Could not match statement');\n        }\n        return result;\n    }\n\n    /**\n     * Checks if current element is a pattern,\n     * returns current element and move pointer to the next element.\n     *\n     * @returns {Element|null}\n     */\n    passPattern(): Element {\n        this.assertPattern();\n        let result = this.currentElement;\n        this.moveNext();\n        if (!result) {\n            throw new Error('Could not match pattern');\n        }\n        return result;\n    }\n\n    /**\n     * Checks if current element is a module specifier,\n     * returns current element and move pointer to the next element.\n     *\n     * @returns {Element|null}\n     */\n    passModuleSpecifier(): ?Element {\n        this.assertModuleSpecifier();\n        let result = this.currentElement;\n        this.moveNext();\n        return result;\n    }\n\n    /**\n     * Skips comments and whitespace.\n     */\n    skipNonCode() {\n        while (true) {\n            let {isCode} = this.currentElement || {};\n            if (isCode !== false) {\n                break;\n            }\n            this.moveNext();\n        }\n    }\n\n    /**\n     * Skips comments and whitespace on the same line.\n     */\n    skipSameLineNonCode() {\n        while (true) {\n            let {isCode} = this.currentElement || {};\n            if (isCode !== false) {\n                break;\n            }\n\n            if (this.currentElement && this.currentElement.getNewlineCount() > 0) {\n                break;\n            }\n\n            this.moveNext();\n        }\n    }\n\n    /**\n     * Skips a semicolon.\n     */\n    skipSemicolon() {\n        if (this.currentElement && this.currentElement.type === 'Punctuator' && this.currentElement.value === ';') {\n            this.moveNext();\n        }\n    }\n\n    /**\n     * Moves pointer (currentElement) to next element.\n     */\n    moveNext() {\n        this._navigate(this._position + 1);\n    }\n\n    /**\n     * Navigates to specified child position.\n     *\n     * @param {Number} position\n     * @private\n     */\n    _navigate(position: number) {\n        this._position = position;\n        this.currentElement = this._elements[position];\n        this.isEnd = this.currentElement === undefined;\n    }\n}\n"]}