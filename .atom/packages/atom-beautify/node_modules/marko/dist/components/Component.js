'use strict';
/* jshint newcap:false */

var domInsert = require('../runtime/dom-insert');
var defaultCreateOut = require('../runtime/createOut');
var getComponentsContext = require('./ComponentsContext').__;
var componentsUtil = require('./util');
var componentLookup = componentsUtil.a_;
var emitLifecycleEvent = componentsUtil.b_;
var destroyComponentForEl = componentsUtil.c_;
var destroyElRecursive = componentsUtil.d_;
var getElementById = componentsUtil.e_;
var EventEmitter = require('events-light');
var RenderResult = require('../runtime/RenderResult');
var SubscriptionTracker = require('listener-tracker');
var inherit = require('raptor-util/inherit');
var updateManager = require('./update-manager');
var morphdom = require('../morphdom');
var eventDelegation = require('./event-delegation');

var slice = Array.prototype.slice;

var MORPHDOM_SKIP = true;

var COMPONENT_SUBSCRIBE_TO_OPTIONS;
var NON_COMPONENT_SUBSCRIBE_TO_OPTIONS = {
    addDestroyListener: false
};

function outNoop() {
    /* jshint -W040 */return this;
}

var emit = EventEmitter.prototype.emit;

function removeListener(removeEventListenerHandle) {
    removeEventListenerHandle();
}

function checkCompatibleComponent(globalComponentsContext, el) {
    var component = el._w;
    while (component) {
        var id = component.id;
        var newComponentDef = globalComponentsContext.f_[id];
        if (newComponentDef && component.g_ == newComponentDef.h_.g_) {
            break;
        }

        var rootFor = component.i_;
        if (rootFor) {
            component = rootFor;
        } else {
            component.j_();
            break;
        }
    }
}

function handleCustomEventWithMethodListener(component, targetMethodName, args, extraArgs) {
    // Remove the "eventType" argument
    args.push(component);

    if (extraArgs) {
        args = extraArgs.concat(args);
    }

    var targetComponent = componentLookup[component.k_];
    var targetMethod = targetComponent[targetMethodName];
    if (!targetMethod) {
        throw Error('Method not found: ' + targetMethodName);
    }

    targetMethod.apply(targetComponent, args);
}

function getElIdHelper(component, componentElId, index) {
    var id = component.id;

    var elId = componentElId != null ? id + '-' + componentElId : id;

    if (index != null) {
        elId += '[' + index + ']';
    }

    return elId;
}

/**
 * This method is used to process "update_<stateName>" handler functions.
 * If all of the modified state properties have a user provided update handler
 * then a rerender will be bypassed and, instead, the DOM will be updated
 * looping over and invoking the custom update handlers.
 * @return {boolean} Returns true if if the DOM was updated. False, otherwise.
 */
function processUpdateHandlers(component, stateChanges, oldState) {
    var handlerMethod;
    var handlers;

    for (var propName in stateChanges) {
        if (stateChanges.hasOwnProperty(propName)) {
            var handlerMethodName = 'update_' + propName;

            handlerMethod = component[handlerMethodName];
            if (handlerMethod) {
                (handlers || (handlers = [])).push([propName, handlerMethod]);
            } else {
                // This state change does not have a state handler so return false
                // to force a rerender
                return;
            }
        }
    }

    // If we got here then all of the changed state properties have
    // an update handler or there are no state properties that actually
    // changed.
    if (handlers) {
        // Otherwise, there are handlers for all of the changed properties
        // so apply the updates using those handlers

        handlers.forEach(function (handler, i) {
            var propertyName = handler[0];
            handlerMethod = handler[1];

            var newValue = stateChanges[propertyName];
            var oldValue = oldState[propertyName];
            handlerMethod.call(component, newValue, oldValue);
        });

        emitLifecycleEvent(component, 'update');

        component.l_();
    }

    return true;
}

function checkInputChanged(existingComponent, oldInput, newInput) {
    if (oldInput != newInput) {
        if (oldInput == null || newInput == null) {
            return true;
        }

        var oldKeys = Object.keys(oldInput);
        var newKeys = Object.keys(newInput);
        var len = oldKeys.length;
        if (len !== newKeys.length) {
            return true;
        }

        for (var i = 0; i < len; i++) {
            var key = oldKeys[i];
            if (oldInput[key] !== newInput[key]) {
                return true;
            }
        }
    }

    return false;
}

function onNodeDiscarded(node) {
    if (node.nodeType === 1) {
        destroyComponentForEl(node);
    }
}

function onBeforeNodeDiscarded(node) {
    return eventDelegation.m_(node);
}

function onBeforeElUpdated(fromEl, key, globalComponentsContext) {
    if (key) {
        var preserved = globalComponentsContext.n_[key];

        if (preserved === true) {
            // Don't morph elements that are associated with components that are being
            // reused or elements that are being preserved. For components being reused,
            // the morphing will take place when the reused component updates.
            return MORPHDOM_SKIP;
        } else {
            // We may need to destroy a Component associated with the current element
            // if a new UI component was rendered to the same element and the types
            // do not match
            checkCompatibleComponent(globalComponentsContext, fromEl);
        }
    }
}

function onBeforeElChildrenUpdated(el, key, globalComponentsContext) {
    if (key) {
        var preserved = globalComponentsContext.o_[key];
        if (preserved === true) {
            // Don't morph the children since they are preserved
            return MORPHDOM_SKIP;
        }
    }
}

function onNodeAdded(node, globalComponentsContext) {
    eventDelegation.p_(node, globalComponentsContext.q_);
}

var componentProto;

/**
 * Base component type.
 *
 * NOTE: Any methods that are prefixed with an underscore should be considered private!
 */
function Component(id) {
    EventEmitter.call(this);
    this.id = id;
    this.el = null;
    this.r_ = null;
    this.s_ = null;
    this.t_ = null;
    this.u_ = null;
    this.v_ = null; // Used to keep track of bubbling DOM events for components rendered on the server
    this.w_ = null;
    this.k_ = null;
    this.x_ = null;
    this.y_ = undefined;
    this.z_ = false;
    this.A_ = undefined;

    this.B_ = false;
    this.C_ = false;
    this.D_ = false;
    this.E_ = false;

    this.F_ = undefined;
}

Component.prototype = componentProto = {
    G_: true,

    subscribeTo: function (target) {
        if (!target) {
            throw TypeError();
        }

        var subscriptions = this.t_ || (this.t_ = new SubscriptionTracker());

        var subscribeToOptions = target.G_ ? COMPONENT_SUBSCRIBE_TO_OPTIONS : NON_COMPONENT_SUBSCRIBE_TO_OPTIONS;

        return subscriptions.subscribeTo(target, subscribeToOptions);
    },

    emit: function (eventType) {
        var customEvents = this.w_;
        var target;

        if (customEvents && (target = customEvents[eventType])) {
            var targetMethodName = target[0];
            var extraArgs = target[1];
            var args = slice.call(arguments, 1);

            handleCustomEventWithMethodListener(this, targetMethodName, args, extraArgs);
        }

        if (this.listenerCount(eventType)) {
            return emit.apply(this, arguments);
        }
    },
    getElId: function (componentElId, index) {
        return getElIdHelper(this, componentElId, index);
    },
    getEl: function (componentElId, index) {
        var doc = this.F_;

        if (componentElId != null) {
            return getElementById(doc, getElIdHelper(this, componentElId, index));
        } else {
            return this.el || getElementById(doc, getElIdHelper(this));
        }
    },
    getEls: function (id) {
        var els = [];
        var i = 0;
        var el;
        while (el = this.getEl(id, i)) {
            els.push(el);
            i++;
        }
        return els;
    },
    getComponent: function (id, index) {
        return componentLookup[getElIdHelper(this, id, index)];
    },
    getComponents: function (id) {
        var components = [];
        var i = 0;
        var component;
        while (component = componentLookup[getElIdHelper(this, id, i)]) {
            components.push(component);
            i++;
        }
        return components;
    },
    destroy: function () {
        if (this.B_) {
            return;
        }

        var els = this.els;

        this.j_();

        var rootComponents = this.H_;
        if (rootComponents) {
            rootComponents.forEach(function (rootComponent) {
                rootComponent.I_();
            });
        }

        els.forEach(function (el) {
            destroyElRecursive(el);

            var parentNode = el.parentNode;
            if (parentNode) {
                parentNode.removeChild(el);
            }
        });
    },

    j_: function () {
        if (this.B_) {
            return;
        }

        emitLifecycleEvent(this, 'destroy');
        this.B_ = true;

        this.el = null;

        // Unsubscribe from all DOM events
        this.J_();

        var subscriptions = this.t_;
        if (subscriptions) {
            subscriptions.removeAllListeners();
            this.t_ = null;
        }

        delete componentLookup[this.id];
    },

    isDestroyed: function () {
        return this.B_;
    },
    get state() {
        return this.r_;
    },
    set state(newState) {
        var state = this.r_;
        if (!state && !newState) {
            return;
        }

        if (!state) {
            state = this.r_ = new this.K_(this);
        }

        state.L_(newState || {});

        if (state.D_) {
            this.M_();
        }

        if (!newState) {
            this.r_ = null;
        }
    },
    setState: function (name, value) {
        var state = this.r_;

        if (typeof name == 'object') {
            // Merge in the new state with the old state
            var newState = name;
            for (var k in newState) {
                if (newState.hasOwnProperty(k)) {
                    state.N_(k, newState[k], true /* ensure:true */);
                }
            }
        } else {
            state.N_(name, value, true /* ensure:true */);
        }
    },

    setStateDirty: function (name, value) {
        var state = this.r_;

        if (arguments.length == 1) {
            value = state[name];
        }

        state.N_(name, value, true /* ensure:true */, true /* forceDirty:true */);
    },

    replaceState: function (newState) {
        this.r_.L_(newState);
    },

    get input() {
        return this.y_;
    },
    set input(newInput) {
        if (this.E_) {
            this.y_ = newInput;
        } else {
            this.O_(newInput);
        }
    },

    O_: function (newInput, onInput, out) {
        onInput = onInput || this.onInput;
        var updatedInput;

        var oldInput = this.y_;
        this.y_ = undefined;

        if (onInput) {
            // We need to set a flag to preview `this.input = foo` inside
            // onInput causing infinite recursion
            this.E_ = true;
            updatedInput = onInput.call(this, newInput || {}, out);
            this.E_ = false;
        }

        newInput = this.x_ = updatedInput || newInput;

        if (this.D_ = checkInputChanged(this, oldInput, newInput)) {
            this.M_();
        }

        if (this.y_ === undefined) {
            this.y_ = newInput;
        }

        return newInput;
    },

    forceUpdate: function () {
        this.D_ = true;
        this.M_();
    },

    M_: function () {
        if (!this.C_) {
            updateManager.P_(this);
        }
    },

    update: function () {
        if (this.B_ === true || this.Q_ === false) {
            return;
        }

        var input = this.y_;
        var state = this.r_;

        if (this.D_ === false && state !== null && state.D_ === true) {
            if (processUpdateHandlers(this, state.R_, state.S_, state)) {
                state.D_ = false;
            }
        }

        if (this.Q_ === true) {
            // The UI component is still dirty after process state handlers
            // then we should rerender

            if (this.shouldUpdate(input, state) !== false) {
                this.T_(false);
            }
        }

        this.l_();
    },

    get Q_() {
        return this.D_ === true || this.r_ !== null && this.r_.D_ === true;
    },

    l_: function () {
        this.D_ = false;
        this.C_ = false;
        this.x_ = null;
        var state = this.r_;
        if (state) {
            state.l_();
        }
    },

    shouldUpdate: function (newState, newProps) {
        return true;
    },

    b_: function (eventType, eventArg1, eventArg2) {
        emitLifecycleEvent(this, eventType, eventArg1, eventArg2);
    },

    T_: function (isRerenderInBrowser) {
        var self = this;
        var renderer = self.U_;

        if (!renderer) {
            throw TypeError();
        }
        var fromEls = self.V_({});
        var doc = self.F_;
        var input = this.x_ || this.y_;
        var globalData = this.A_;

        updateManager.W_(function () {
            var createOut = renderer.createOut || defaultCreateOut;
            var out = createOut(globalData);
            out.sync();
            out.F_ = self.F_;

            if (isRerenderInBrowser === true) {
                out.e = out.be = out.ee = out.t = out.h = out.w = out.write = out.html = outNoop;
            }

            var componentsContext = getComponentsContext(out);
            var globalComponentsContext = componentsContext.X_;
            globalComponentsContext.Y_ = self;
            globalComponentsContext.Z_ = isRerenderInBrowser;

            renderer(input, out);

            var result = new RenderResult(out);

            if (isRerenderInBrowser !== true) {
                var targetNode = out.___();

                var fromEl;

                var targetEl = targetNode._a_;
                while (targetEl) {
                    var nodeName = targetEl._b_;

                    if (nodeName === 'HTML') {
                        fromEl = document.documentElement;
                    } else if (nodeName === 'BODY') {
                        fromEl = document.body;
                    } else if (nodeName === 'HEAD') {
                        fromEl = document.head;
                    } else {
                        fromEl = fromEls[targetEl.id];
                    }

                    if (fromEl) {
                        morphdom(fromEl, targetEl, globalComponentsContext, onNodeAdded, onBeforeElUpdated, onBeforeNodeDiscarded, onNodeDiscarded, onBeforeElChildrenUpdated);
                    }

                    targetEl = targetEl._c_;
                }
            }

            result.afterInsert(doc);

            out.emit('_d_');
        });

        this.l_();
    },

    V_: function (rootEls) {
        var i, len;

        var componentEls = this.els;

        for (i = 0, len = componentEls.length; i < len; i++) {
            var componentEl = componentEls[i];
            rootEls[componentEl.id] = componentEl;
        }

        var rootComponents = this.H_;
        if (rootComponents) {
            for (i = 0, len = rootComponents.length; i < len; i++) {
                var rootComponent = rootComponents[i];
                rootComponent.V_(rootEls);
            }
        }

        return rootEls;
    },

    J_: function () {
        var eventListenerHandles = this.u_;
        if (eventListenerHandles) {
            eventListenerHandles.forEach(removeListener);
            this.u_ = null;
        }
    },

    get _e_() {
        var state = this.r_;
        return state && state._f_;
    },

    _g_: function (customEvents, scope) {
        var finalCustomEvents = this.w_ = {};
        this.k_ = scope;

        customEvents.forEach(function (customEvent) {
            var eventType = customEvent[0];
            var targetMethodName = customEvent[1];
            var extraArgs = customEvent[2];

            finalCustomEvents[eventType] = [targetMethodName, extraArgs];
        });
    }
};

componentProto.elId = componentProto.getElId;
componentProto._h_ = componentProto.update;
componentProto.I_ = componentProto.destroy;

// Add all of the following DOM methods to Component.prototype:
// - appendTo(referenceEl)
// - replace(referenceEl)
// - replaceChildrenOf(referenceEl)
// - insertBefore(referenceEl)
// - insertAfter(referenceEl)
// - prependTo(referenceEl)
domInsert(componentProto, function getEl(component) {
    var els = this.els;
    var elCount = els.length;
    if (elCount > 1) {
        var fragment = component.F_.createDocumentFragment();
        els.forEach(function (el) {
            fragment.appendChild(el);
        });
        return fragment;
    } else {
        return els[0];
    }
}, function afterInsert(component) {
    return component;
});

inherit(Component, EventEmitter);

module.exports = Component;