'use strict';

var warp10 = require('warp10');
var escapeEndingScriptTagRegExp = /<\//g;

function flattenHelper(components, flattened, typesArray, typesLookup) {
    for (var i = 0, len = components.length; i < len; i++) {
        var componentDef = components[i];
        var id = componentDef.id;
        var component = componentDef.h_;
        var rerenderInBrowser = componentDef._p_;
        var state = component.state;
        var input = component.input;
        var typeName = component.typeName;
        var customEvents = component.w_;
        var scope = component.k_;
        var bubblingDomEvents = component.v_;

        component.r_ = undefined; // We don't use `delete` to avoid V8 deoptimization
        component.y_ = undefined; // We don't use `delete` to avoid V8 deoptimization
        component.typeName = undefined;
        component.id = undefined;
        component.w_ = undefined;
        component.k_ = undefined;
        component.v_ = undefined;
        component._G_ = undefined;

        if (!typeName) {
            continue;
        }

        var typeIndex = typesLookup[typeName];
        if (typeIndex === undefined) {
            typeIndex = typesArray.length;
            typesArray.push(typeName);
            typesLookup[typeName] = typeIndex;
        }

        var children = componentDef._m_;

        if (children !== null) {
            // Depth-first search (children should be initialized before parent)
            flattenHelper(children, flattened, typesArray, typesLookup);
            componentDef._m_ = null;
        }

        var hasProps = false;

        let componentKeys = Object.keys(component);
        for (let i = 0, len = componentKeys.length; i < len; i++) {
            let key = componentKeys[i];

            if (component[key] !== undefined) {
                hasProps = true;
                break;
            }
        }

        var undefinedPropNames;

        if (state) {
            // Update state properties with an `undefined` value to have a `null`
            // value so that the property name will be serialized down to the browser.
            // This ensures that we add the proper getter/setter for the state property.

            let stateKeys = Object.keys(state);
            for (let i = 0, len = stateKeys.length; i < len; i++) {
                let key = stateKeys[i];

                if (state[key] === undefined) {
                    if (undefinedPropNames) {
                        undefinedPropNames.push(key);
                    } else {
                        undefinedPropNames = [key];
                    }
                }
            }
        }

        var extra = {
            b: bubblingDomEvents,
            d: componentDef._n_,
            e: customEvents,
            p: customEvents && scope, // Only serialize scope if we need to attach custom events
            r: componentDef.s_,
            s: state,
            u: undefinedPropNames,
            w: hasProps ? component : undefined,
            _: rerenderInBrowser ? 1 : undefined
        };

        flattened.push([id, // 0 = id
        typeIndex, // 1 = type
        input, // 2 = input
        extra // 3
        ]);
    }
}

function getRenderedComponents(out, shouldIncludeAll) {
    var componentDefs;
    var globalComponentsContext;
    var outGlobal = out.global;

    if (shouldIncludeAll === true) {
        globalComponentsContext = outGlobal._B_;

        if (globalComponentsContext === undefined) {
            return undefined;
        }
    } else {
        let componentsContext = out.data._B_;
        if (componentsContext === undefined) {
            return undefined;
        }
        let rootComponentDef = componentsContext._k_[0];
        componentDefs = rootComponentDef._m_;

        if (componentDefs === null) {
            return undefined;
        }

        rootComponentDef._m_ = null;
    }

    var flattened = [];
    var typesLookup = {};
    var typesArray = [];

    if (shouldIncludeAll === true) {
        let roots = globalComponentsContext.s_;
        for (let i = 0, len = roots.length; i < len; i++) {
            let root = roots[i];
            let children = root._m_;
            if (children !== null) {
                flattenHelper(children, flattened, typesArray, typesLookup);
            }
        }
    } else {
        flattenHelper(componentDefs, flattened, typesArray, typesLookup);
    }

    if (flattened.length === 0) {
        return undefined;
    }

    return { w: flattened, t: typesArray };
}

function writeInitComponentsCode(out, shouldIncludeAll) {
    var renderedComponents = getRenderedComponents(out, shouldIncludeAll);
    if (renderedComponents === undefined) {
        return;
    }

    var cspNonce = out.global.cspNonce;
    var nonceAttr = cspNonce ? ' nonce=' + JSON.stringify(cspNonce) : '';

    out.write('<script' + nonceAttr + '>' + '(function(){var w=window;w.$components=(w.$components||[]).concat(' + warp10.stringify(renderedComponents).replace(escapeEndingScriptTagRegExp, '\\u003C/') + ')||w.$components})()</script>');
}

exports.writeInitComponentsCode = writeInitComponentsCode;

/**
 * Returns an object that can be sent to the browser using JSON.stringify. The parsed object should be
 * passed to require('marko-components').initComponents(...);
 *
 * @param  {ComponentsContext|AsyncWriter} componentsContext A ComponentsContext or an AsyncWriter
 * @return {Object} An object with information about the rendered components that can be serialized to JSON. The object should be treated as opaque
 */
exports.getRenderedComponents = function (out) {
    var renderedComponents = getRenderedComponents(out, true);
    return warp10.stringifyPrepare(renderedComponents);
};