var EventEmitter = require('events-light');
var vdom = require('./vdom');
var VElement = vdom.am_;
var VDocumentFragment = vdom.an_;
var VComment = vdom.ao_;
var VText = vdom.ap_;
var virtualizeHTML = vdom.aq_;
var RenderResult = require('../RenderResult');
var defaultDocument = vdom.ar_;

var FLAG_FINISHED = 1;
var FLAG_LAST_FIRED = 2;

var EVENT_UPDATE = 'update';
var EVENT_FINISH = 'finish';

function State(tree) {
    this.as_ = 1;
    this.at_ = new EventEmitter();
    this.au_ = tree;
    this.av_ = null;
    this.aw_ = 0;
    this.ax_ = 0;
}

function AsyncVDOMBuilder(globalData, parentNode, state) {
    if (!parentNode) {
        parentNode = new VDocumentFragment();
    }

    if (state) {
        state.as_++;
    } else {
        state = new State(parentNode);
    }

    this.data = {};
    this.r_ = state;
    this.ay_ = parentNode;
    this.global = globalData || {};
    this.az_ = [parentNode];
    this.aA_ = false;
    this.aB_ = undefined;
    this._X_ = null; // Component args
}

var proto = AsyncVDOMBuilder.prototype = {
    ai_: true,
    F_: defaultDocument,

    aC_: function (element, childCount, pushToStack) {
        var parent = this.ay_;
        if (parent !== undefined) {
            parent.aD_(element);
            if (pushToStack === true) {
                this.az_.push(element);
                this.ay_ = element;
            }
        }
        return childCount === 0 ? this : element;
    },

    element: function (tagName, attrs, childCount, flags, props) {
        var element = new VElement(tagName, attrs, childCount, flags, props);
        return this.aC_(element, childCount);
    },

    aE_: function (tagName, attrs, childCount, flags, props) {
        var element = VElement.aF_(tagName, attrs, childCount, flags, props);
        return this.aC_(element, childCount);
    },

    n: function (node) {
        // NOTE: We do a shallow clone since we assume the node is being reused
        //       and a node can only have one parent node.
        return this.node(node.aG_());
    },

    node: function (node) {
        var parent = this.ay_;
        if (parent !== undefined) {
            parent.aD_(node);
        }
        return this;
    },

    text: function (text) {
        var type = typeof text;

        if (type != 'string') {
            if (text == null) {
                return;
            } else if (type === 'object') {
                if (text.toHTML) {
                    return this.h(text.toHTML());
                }
            }

            text = text.toString();
        }

        var parent = this.ay_;
        if (parent !== undefined) {
            var lastChild = parent.lastChild;
            if (lastChild && lastChild.aH_) {
                lastChild.ae_ += text;
            } else {
                parent.aD_(new VText(text));
            }
        }
        return this;
    },

    comment: function (comment) {
        return this.node(new VComment(comment));
    },

    html: function (html) {
        if (html != null) {
            var vdomNode = virtualizeHTML(html, this.F_ || document);
            this.node(vdomNode);
        }

        return this;
    },

    beginElement: function (tagName, attrs, childCount, flags, props) {
        var element = new VElement(tagName, attrs, childCount, flags, props);
        this.aC_(element, childCount, true);
        return this;
    },

    aI_: function (tagName, attrs, childCount, flags, props) {
        var element = VElement.aF_(tagName, attrs, childCount, flags, props);
        this.aC_(element, childCount, true);
        return this;
    },

    endElement: function () {
        var stack = this.az_;
        stack.pop();
        this.ay_ = stack[stack.length - 1];
    },

    end: function () {
        var state = this.r_;

        this.ay_ = undefined;

        var remaining = --state.as_;

        if (!(state.ax_ & FLAG_LAST_FIRED) && remaining - state.aw_ === 0) {
            state.ax_ |= FLAG_LAST_FIRED;
            state.aw_ = 0;
            state.at_.emit('last');
        }

        if (remaining === 0) {
            state.ax_ |= FLAG_FINISHED;
            state.at_.emit(EVENT_FINISH, this.aj_());
        }

        return this;
    },

    error: function (e) {
        try {
            this.emit('error', e);
        } finally {
            // If there is no listener for the error event then it will
            // throw a new Error here. In order to ensure that the async fragment
            // is still properly ended we need to put the end() in a `finally`
            // block
            this.end();
        }

        return this;
    },

    beginAsync: function (options) {
        if (this.aA_) {
            throw Error('Not allowed');
        }

        var state = this.r_;

        if (options) {
            if (options.last) {
                state.aw_++;
            }
        }

        var documentFragment = this.ay_.aJ_();
        var asyncOut = new AsyncVDOMBuilder(this.global, documentFragment, state);

        state.at_.emit('beginAsync', {
            out: asyncOut,
            parentOut: this
        });

        return asyncOut;
    },

    createOut: function (callback) {
        return new AsyncVDOMBuilder(this.global);
    },

    flush: function () {
        var events = this.r_.at_;

        if (events.listenerCount(EVENT_UPDATE)) {
            events.emit(EVENT_UPDATE, new RenderResult(this));
        }
    },

    ___: function () {
        return this.r_.au_;
    },

    aj_: function () {
        return this.aK_ || (this.aK_ = new RenderResult(this));
    },

    on: function (event, callback) {
        var state = this.r_;

        if (event === EVENT_FINISH && state.ax_ & FLAG_FINISHED) {
            callback(this.aj_());
        } else {
            state.at_.on(event, callback);
        }

        return this;
    },

    once: function (event, callback) {
        var state = this.r_;

        if (event === EVENT_FINISH && state.ax_ & FLAG_FINISHED) {
            callback(this.aj_());
            return this;
        }

        state.at_.once(event, callback);
        return this;
    },

    emit: function (type, arg) {
        var events = this.r_.at_;
        switch (arguments.length) {
            case 1:
                events.emit(type);
                break;
            case 2:
                events.emit(type, arg);
                break;
            default:
                events.emit.apply(events, arguments);
                break;
        }
        return this;
    },

    removeListener: function () {
        var events = this.r_.at_;
        events.removeListener.apply(events, arguments);
        return this;
    },

    sync: function () {
        this.aA_ = true;
    },

    isSync: function () {
        return this.aA_;
    },

    onLast: function (callback) {
        var state = this.r_;

        var lastArray = state.av_;

        if (!lastArray) {
            lastArray = state.av_ = [];
            var i = 0;
            var next = function () {
                if (i === lastArray.length) {
                    return;
                }
                var _next = lastArray[i++];
                _next(next);
            };

            this.once('last', function () {
                next();
            });
        }

        lastArray.push(callback);
        return this;
    },

    ag_: function (doc) {
        var node = this.aB_;
        if (!node) {
            var vdomTree = this.___();

            node = this.aB_ = vdomTree.actualize(doc || this.F_ || document);
        }
        return node;
    },

    toString: function () {
        var docFragment = this.ag_();
        var html = '';

        if (docFragment.hasChildNodes()) {
            var children = docFragment.childNodes;
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                // get outerHTML if exists, otherwise default to nodeValue
                html += child.outerHTML || child.nodeValue;
            }
        }

        return html;
    },

    then: function (fn, fnErr) {
        var out = this;
        var promise = new Promise(function (resolve, reject) {
            out.on('error', reject).on(EVENT_FINISH, function (result) {
                resolve(result);
            });
        });

        return Promise.resolve(promise).then(fn, fnErr);
    },

    catch: function (fnErr) {
        return this.then(undefined, fnErr);
    },

    isVDOM: true,

    c: function (componentArgs) {
        this._X_ = componentArgs;
    }
};

proto.e = proto.element;
proto.ed = proto.aE_;
proto.be = proto.beginElement;
proto.bed = proto.aI_;
proto.ee = proto.endElement;
proto.t = proto.text;
proto.h = proto.w = proto.write = proto.html;

module.exports = AsyncVDOMBuilder;