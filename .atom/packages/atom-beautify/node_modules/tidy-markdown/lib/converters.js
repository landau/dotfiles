// Generated by CoffeeScript 1.10.0
var CODE_HIGHLIGHT_REGEX, _, delimitCode, extractRows, fallback, formatHeaderSeparator, formatRow, getAttribute, getColumnWidths, indent, indentChildren, isBlock, languageCodeRewrite, ref, ref1, ref2, serialize, stringRepeat, treeAdapter, treeAdapters,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('lodash');

indent = require('indent');

ref = require('parse5'), serialize = ref.serialize, treeAdapters = ref.treeAdapters;

languageCodeRewrite = require('../lib/language-code-rewrites');

ref1 = require('./utils'), delimitCode = ref1.delimitCode, getAttribute = ref1.getAttribute, stringRepeat = ref1.stringRepeat, isBlock = ref1.isBlock;

ref2 = require('./tables'), extractRows = ref2.extractRows, formatHeaderSeparator = ref2.formatHeaderSeparator, formatRow = ref2.formatRow, getColumnWidths = ref2.getColumnWidths;

treeAdapter = treeAdapters["default"];

CODE_HIGHLIGHT_REGEX = /(?:highlight highlight|lang(?:uage)?)-(\S+)/;

indentChildren = function(node) {
  var allChildrenAreElements, child, children, j, k, l, len, len1, len2, ref3, ref4;
  allChildrenAreElements = true;
  ref3 = node.childNodes;
  for (j = 0, len = ref3.length; j < len; j++) {
    child = ref3[j];
    if (child.nodeName === '#text') {
      allChildrenAreElements = false;
    }
  }
  if (allChildrenAreElements) {
    children = [];
    ref4 = node.childNodes;
    for (k = 0, len1 = ref4.length; k < len1; k++) {
      child = ref4[k];
      children.push(child);
    }
    for (l = 0, len2 = children.length; l < len2; l++) {
      child = children[l];
      treeAdapter.insertTextBefore(node, '\n  ', child);
    }
    return treeAdapter.insertText(node, '\n');
  }
};

fallback = function() {
  return true;
};


/**
 * This array holds a set of "converters" that process DOM nodes and output
   Markdown. The `filter` property determines what nodes the converter is run
   on. The `replacement` function takes the content of the node and the node
   itself and returns a string of Markdown. The `surroundingBlankLines` option
   determines whether or not the block should have a blank line before and after
   it. Converters are matched to nodes starting from the top of the converters
   list and testing each one downwards.
 * @type {Array}
 */

module.exports = [
  {
    filter: function(node) {
      var ref3, ref4;
      return ((ref3 = node.parentNode) != null ? (ref4 = ref3._converter) != null ? ref4.filter : void 0 : void 0) === fallback;
    },
    surroundingBlankLines: false,
    replacement: function(content, node) {
      indentChildren(node);
      return '';
    }
  }, {
    filter: 'p',
    surroundingBlankLines: true,
    replacement: function(content) {
      return content;
    }
  }, {
    filter: ['td', 'th'],
    surroundingBlankLines: false,
    replacement: function(content) {
      return content;
    }
  }, {
    filter: ['tbody', 'thead', 'tr'],
    surroundingBlankLines: false,
    replacement: function() {
      return '';
    }
  }, {
    filter: ['del', 's', 'strike'],
    surroundingBlankLines: false,
    replacement: function(content) {
      return "~~" + content + "~~";
    }
  }, {
    filter: ['em', 'i'],
    surroundingBlankLines: false,
    replacement: function(content) {
      return "_" + content + "_";
    }
  }, {
    filter: ['strong', 'b'],
    surroundingBlankLines: false,
    replacement: function(content) {
      return "**" + content + "**";
    }
  }, {
    filter: 'br',
    surroundingBlankLines: false,
    trailingWhitespace: '\n',
    replacement: function() {
      return '<br>';
    }
  }, {
    filter: 'a',
    surroundingBlankLines: false,
    replacement: function(content, node, links) {
      var referenceLink, title, url;
      url = getAttribute(node, 'href') || '';
      title = getAttribute(node, 'title');
      referenceLink = _.find(links, {
        url: url,
        title: title
      });
      if (referenceLink) {
        if (content.toLowerCase() === referenceLink.name) {
          return "[" + content + "]";
        } else {
          return "[" + content + "][" + referenceLink.name + "]";
        }
      } else if (!title && url !== '' && content === url) {
        return "<" + url + ">";
      } else if (title) {
        return "[" + content + "](" + url + " \"" + title + "\")";
      } else {
        return "[" + content + "](" + url + ")";
      }
    }
  }, {
    filter: 'img',
    surroundingBlankLines: false,
    replacement: function(content, node, links) {
      var alt, referenceLink, title, url;
      alt = getAttribute(node, 'alt') || '';
      url = getAttribute(node, 'src') || '';
      title = getAttribute(node, 'title');
      referenceLink = _.find(links, {
        url: url,
        title: title
      });
      if (referenceLink) {
        if (alt.toLowerCase() === referenceLink.name) {
          return "![" + alt + "]";
        } else {
          return "![" + alt + "][" + referenceLink.name + "]";
        }
      } else if (title) {
        return "![" + alt + "](" + url + " \"" + title + "\")";
      } else {
        return "![" + alt + "](" + url + ")";
      }
    }
  }, {
    filter: function(node) {
      return node.type === 'checkbox' && node.parentNode.nodeName === 'li';
    },
    surroundingBlankLines: false,
    replacement: function(content, node) {
      return (node.checked ? '[x]' : '[ ]') + ' ';
    }
  }, {
    filter: 'table',
    surroundingBlankLines: true,
    replacement: function(content, node) {
      var alignments, columnWidths, i, j, out, ref3, ref4, rows, totalCols;
      ref3 = extractRows(node), alignments = ref3.alignments, rows = ref3.rows;
      columnWidths = getColumnWidths(rows);
      totalCols = rows[0].length;
      out = [formatRow(rows[0], alignments, columnWidths), formatHeaderSeparator(alignments, columnWidths)];
      for (i = j = 1, ref4 = rows.length; 1 <= ref4 ? j < ref4 : j > ref4; i = 1 <= ref4 ? ++j : --j) {
        out.push(formatRow(rows[i], alignments, columnWidths));
      }
      return out.join('\n');
    }
  }, {
    filter: 'pre',
    surroundingBlankLines: true,
    replacement: function(content, node) {
      var language, ref3, ref4, ref5, ref6, ref7;
      if (((ref3 = node.childNodes[0]) != null ? ref3.nodeName : void 0) === 'code') {
        language = (ref4 = getAttribute(node.childNodes[0], 'class')) != null ? (ref5 = ref4.match(CODE_HIGHLIGHT_REGEX)) != null ? ref5[1] : void 0 : void 0;
      }
      if ((language == null) && node.parentNode.nodeName === 'div') {
        language = (ref6 = getAttribute(node.parentNode, 'class')) != null ? (ref7 = ref6.match(CODE_HIGHLIGHT_REGEX)) != null ? ref7[1] : void 0 : void 0;
      }
      if (language != null) {
        language = language.toLowerCase();
        if (languageCodeRewrite[language] != null) {
          language = languageCodeRewrite[language];
        }
      }
      return delimitCode((language || '') + "\n" + content, '```');
    }
  }, {
    filter: 'code',
    surroundingBlankLines: false,
    replacement: function(content, node) {
      if (node.parentNode.nodeName !== 'pre') {
        return delimitCode(content, '`');
      } else {
        return content;
      }
    }
  }, {
    filter: function(node) {
      return node.nodeName === 'div' && CODE_HIGHLIGHT_REGEX.test(node.className);
    },
    surroundingBlankLines: true,
    replacement: function(content) {
      return content;
    }
  }, {
    filter: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
    surroundingBlankLines: true,
    replacement: function(content, node) {
      var hLevel;
      hLevel = node.nodeName[1];
      return (stringRepeat('#', hLevel)) + " " + content;
    }
  }, {
    filter: 'hr',
    surroundingBlankLines: true,
    replacement: function() {
      return stringRepeat('-', 80);
    }
  }, {
    filter: 'blockquote',
    surroundingBlankLines: true,
    replacement: function(content) {
      return indent(content, '> ');
    }
  }, {
    filter: 'li',
    surroundingBlankLines: false,
    trailingWhitespace: '\n',
    replacement: function(content, node) {
      var parent, prefix;
      if (indexOf.call(content, '\n') >= 0) {
        content = indent(content, '  ').trimLeft();
      }
      parent = node.parentNode;
      prefix = (parent.nodeName === 'ol' ? parent.childNodes.indexOf(node) + 1 + '. ' : '- ');
      return prefix + content;
    }
  }, {
    filter: ['ul', 'ol'],
    surroundingBlankLines: true,
    replacement: function(content) {
      return content;
    }
  }, {
    filter: fallback,
    surroundingBlankLines: true,
    replacement: function(content, node) {
      indentChildren(node);
      return serialize({
        nodeName: '#document-fragment',
        quirksMode: false,
        childNodes: [node]
      });
    }
  }
];
