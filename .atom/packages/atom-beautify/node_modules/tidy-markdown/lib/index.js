// Generated by CoffeeScript 1.10.0
var _, bfsOrder, canConvert, cleanText, converters, decodeHtmlEntities, findConverter, fixHeaders, flankingWhitespace, fm, getContent, getNextSibling, getNodeIndex, getPreviousSibling, isBlock, isFlankedByWhitespace, isVoid, marked, nodeType, parseFragment, process, ref, ref1, removeEmptyNodes, treeAdapter, treeAdapters, yaml,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('lodash');

fm = require('front-matter');

marked = require('marked');

yaml = require('js-yaml');

ref = require('parse5'), parseFragment = ref.parseFragment, treeAdapters = ref.treeAdapters;

converters = require('./converters');

ref1 = require('./utils'), cleanText = ref1.cleanText, decodeHtmlEntities = ref1.decodeHtmlEntities, nodeType = ref1.nodeType, isBlock = ref1.isBlock, isVoid = ref1.isVoid;

treeAdapter = treeAdapters["default"];


/**
 * Some people accidently skip levels in their headers (like jumping from h1 to
   h3), which screws up things like tables of contents. This function fixes
   that.
 * The algorithm assumes that relations between nearby headers are correct and
   will try to preserve them. For example, "h1, h3, h3" becomes "h1, h2, h2"
   rather than "h1, h2, h3".
 */

fixHeaders = function(dom, ensureFirstHeaderIsH1) {
  var child, childHeaderDepth, e, gap, headerDepth, i, j, k, lastHeaderDepth, len, ref2, ref3, ref4, rootDepth, topLevelHeaders;
  topLevelHeaders = [];
  ref2 = dom.childNodes;
  for (j = 0, len = ref2.length; j < len; j++) {
    child = ref2[j];
    if (/h[0-6]/.test(child.nodeName)) {
      topLevelHeaders.push(child);
    }
  }
  if (topLevelHeaders.length === 0) {
    return;
  }
  lastHeaderDepth = 0;
  if (!ensureFirstHeaderIsH1) {
    lastHeaderDepth = topLevelHeaders[0].nodeName[1] - 1;
  }
  rootDepth = lastHeaderDepth + 1;
  i = 0;
  while (i < topLevelHeaders.length) {
    headerDepth = parseInt(topLevelHeaders[i].nodeName[1]);
    if ((rootDepth <= headerDepth && headerDepth <= lastHeaderDepth + 1)) {
      lastHeaderDepth = headerDepth;
    } else {
      if (headerDepth <= rootDepth) {
        gap = headerDepth - rootDepth;
      } else {
        gap = headerDepth - (lastHeaderDepth + 1);
      }
      for (e = k = ref3 = i, ref4 = topLevelHeaders.length; ref3 <= ref4 ? k < ref4 : k > ref4; e = ref3 <= ref4 ? ++k : --k) {
        childHeaderDepth = parseInt(topLevelHeaders[e].nodeName[1]);
        if (childHeaderDepth >= headerDepth) {
          topLevelHeaders[e].nodeName = 'h' + (childHeaderDepth - gap);
        } else {
          break;
        }
      }
      continue;
    }
    i++;
  }
};


/**
 * Flattens DOM tree into single array
 */

bfsOrder = function(node) {
  var child, elem, inqueue, j, len, outqueue, ref2;
  inqueue = [node];
  outqueue = [];
  while (inqueue.length > 0) {
    elem = inqueue.shift();
    outqueue.push(elem);
    ref2 = elem.childNodes;
    for (j = 0, len = ref2.length; j < len; j++) {
      child = ref2[j];
      if (nodeType(child) === 1) {
        inqueue.push(child);
      }
    }
  }
  outqueue.shift();
  return outqueue;
};


/**
 * Contructs a Markdown string of replacement text for a given node
 */

getContent = function(node) {
  var child, childText, content, j, len, previousSibling, ref2, ref3, ref4, whitespaceSeparator;
  if (node.nodeName === '#text') {
    return node.value;
  }
  content = '';
  previousSibling = null;
  ref2 = node.childNodes;
  for (j = 0, len = ref2.length; j < len; j++) {
    child = ref2[j];
    childText = ((function() {
      switch (nodeType(child)) {
        case 1:
          return child._replacement;
        case 3:
          return cleanText(child);
      }
    })());
    if (child.nodeName === 'br') {
      content = content.trimRight();
    }
    if ((previousSibling != null ? previousSibling.nodeName : void 0) === 'br') {
      childText = childText.trimLeft();
    }
    if (previousSibling != null) {
      whitespaceSeparator = ((((ref3 = child._whitespace) != null ? ref3.leading : void 0) || '') + ((previousSibling != null ? (ref4 = previousSibling._whitespace) != null ? ref4.trailing : void 0 : void 0) || '')).replace(/\n{3,}/, '\n\n');
      content += whitespaceSeparator;
    }
    content += childText;
    previousSibling = child;
  }
  return content;
};

canConvert = function(node, filter) {
  var ref2;
  if (typeof filter === 'string') {
    return filter === node.nodeName;
  }
  if (Array.isArray(filter)) {
    return ref2 = node.nodeName.toLowerCase(), indexOf.call(filter, ref2) >= 0;
  } else if (typeof filter === 'function') {
    return filter(node);
  } else {
    throw new TypeError('`filter` needs to be a string, array, or function');
  }
};

findConverter = function(node) {
  var converter, j, len;
  for (j = 0, len = converters.length; j < len; j++) {
    converter = converters[j];
    if (canConvert(node, converter.filter)) {
      return converter;
    }
  }
};


/**
 * @return {Integer} The index of the given `node` relative to all the children
   of its parent
 */

getNodeIndex = function(node) {
  return node.parentNode.childNodes.indexOf(node);
};

getPreviousSibling = function(node) {
  return node.parentNode.childNodes[getNodeIndex(node) - 1];
};

getNextSibling = function(node) {
  return node.parentNode.childNodes[getNodeIndex(node) + 1];
};

isFlankedByWhitespace = function(side, node) {
  var regExp, sibling;
  if (side === 'left') {
    sibling = getPreviousSibling(node);
    regExp = /\s$/;
  } else {
    sibling = getNextSibling(node);
    regExp = /^\s/;
  }
  if (sibling && !isBlock(sibling)) {
    return regExp.test(getContent(sibling));
  } else {
    return false;
  }
};

flankingWhitespace = function(node) {
  var content, hasLeading, hasTrailing, leading, ref2, ref3, ref4, ref5, trailing;
  leading = '';
  trailing = '';
  if (!isBlock(node)) {
    content = getContent(node);
    hasLeading = /^\s/.test(content);
    hasTrailing = /\s$/.test(content);
    if (hasLeading && !isFlankedByWhitespace('left', node)) {
      leading = ' ';
    }
    if (hasTrailing && !isFlankedByWhitespace('right', node)) {
      trailing = ' ';
    }
  }
  if ((ref2 = node.childNodes[0]) != null ? (ref3 = ref2._whitespace) != null ? ref3.leading : void 0 : void 0) {
    leading += node.childNodes[0]._whitespace.leading;
  }
  if ((ref4 = node.childNodes.slice(-1)[0]) != null ? (ref5 = ref4._whitespace) != null ? ref5.trailing : void 0 : void 0) {
    trailing += node.childNodes.slice(-1)[0]._whitespace.trailing;
  }
  return {
    leading: leading,
    trailing: trailing
  };
};


/*
 * Finds a Markdown converter, gets the replacement, and sets it on
 * `_replacement`
 */

process = function(node, links) {
  var content, converter, whitespace;
  content = getContent(node);
  converter = node._converter;
  if (node.nodeName !== 'pre' && node.parentNode.nodeName !== 'pre') {
    content = content.trim();
  }
  if (converter.surroundingBlankLines) {
    whitespace = {
      leading: '\n\n',
      trailing: '\n\n'
    };
  } else {
    whitespace = flankingWhitespace(node);
    if (converter.trailingWhitespace != null) {
      whitespace.trailing += converter.trailingWhitespace;
    }
  }
  if (node.nodeName === 'li') {
    whitespace.leading = '';
  }
  node._replacement = converter.replacement(content, node, links);
  node._whitespace = whitespace;
};

removeEmptyNodes = function(nodes) {
  var child, emptyChildren, j, k, len, len1, nextSibling, node, previousSibling, ref2, results;
  results = [];
  for (j = 0, len = nodes.length; j < len; j++) {
    node = nodes[j];
    emptyChildren = [];
    ref2 = node.childNodes;
    for (k = 0, len1 = ref2.length; k < len1; k++) {
      child = ref2[k];
      if (child.nodeName === '#text' && child.value.trim() === '') {
        previousSibling = getPreviousSibling(child);
        nextSibling = getNextSibling(child);
        if (!previousSibling || !nextSibling || isBlock(previousSibling) || isBlock(nextSibling)) {
          emptyChildren.push(child);
        }
      }
    }
    results.push((function() {
      var l, len2, results1;
      results1 = [];
      for (l = 0, len2 = emptyChildren.length; l < len2; l++) {
        child = emptyChildren[l];
        results1.push(treeAdapter.detachNode(child));
      }
      return results1;
    })());
  }
  return results;
};

module.exports = function(dirtyMarkdown, options) {
  var ast, content, html, j, k, l, len, len1, link, links, name, node, nodes, optionalTitle, out, rawLinks, ref2, root, title, url, value;
  if (options == null) {
    options = {};
  }
  if (typeof dirtyMarkdown !== 'string') {
    throw new TypeError('Markdown input is not a string');
  }
  if (options.ensureFirstHeaderIsH1 == null) {
    options.ensureFirstHeaderIsH1 = true;
  }
  out = '';
  content = fm(dirtyMarkdown);
  if (Object.keys(content.attributes).length !== 0) {
    out += '---\n' + yaml.safeDump(content.attributes).trim() + '\n---\n\n';
  }
  ast = marked.lexer(content.body);
  rawLinks = ast.links;
  links = [];
  for (link in rawLinks) {
    value = rawLinks[link];
    links.push({
      name: link.toLowerCase(),
      url: value.href,
      title: value.title || null
    });
  }
  links = _.sortBy(links, ['name', 'url']);
  html = marked.parser(ast);
  html = html.replace(/(\d+)\. /g, '$1\\. ');
  root = parseFragment(html);
  removeEmptyNodes([root]);
  fixHeaders(root, options.ensureFirstHeaderIsH1);
  nodes = bfsOrder(root);
  removeEmptyNodes(nodes);
  for (j = 0, len = nodes.length; j < len; j++) {
    node = nodes[j];
    node._converter = findConverter(node);
  }
  for (k = nodes.length - 1; k >= 0; k += -1) {
    node = nodes[k];
    process(node, links);
  }
  out += getContent(root).trimRight() + '\n';
  if (links.length > 0) {
    out += '\n';
  }
  for (l = 0, len1 = links.length; l < len1; l++) {
    ref2 = links[l], name = ref2.name, url = ref2.url, title = ref2.title;
    optionalTitle = title ? " \"" + title + "\"" : '';
    out += "[" + name + "]: " + url + optionalTitle + "\n";
  }
  return out;
};
