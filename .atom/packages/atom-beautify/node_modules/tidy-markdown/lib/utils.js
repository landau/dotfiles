// Generated by CoffeeScript 1.10.0
var Entities, _, blocks, cleanText, decodeHtmlEntities, delimitCode, getAttribute, htmlEntities, isBlock, isVoid, nodeType, stringRepeat, voids,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Entities = require('html-entities').AllHtmlEntities;

_ = require('lodash');

blocks = require('./block-tags');

voids = require('./void-tags');


/**
 * @param {String} x The string to be repeated
 * @param {String} n Number of times to repeat the string
 * @return {String} The result of repeating the string
 */

stringRepeat = function(x, n) {
  var s;
  s = '';
  while (true) {
    if (n & 1) {
      s += x;
    }
    n >>= 1;
    if (n) {
      x += x;
    } else {
      break;
    }
  }
  return s;
};


/**
 * Wrap code with delimiters
 * @param {String} code
 * @param {String} delimiter The delimiter to start with, additional backticks
   will be added if needed; like if the code contains a sequence of backticks
   that would end the code block prematurely.
 */

delimitCode = function(code, delimiter) {
  while (RegExp("([^`]|^)" + delimiter + "([^`]|$)").test(code)) {
    delimiter += '`';
  }
  if (code[0] === '`') {
    code = ' ' + code;
  }
  if (code.slice(-1) === '`') {
    code += ' ';
  }
  return delimiter + code + delimiter;
};

nodeType = function(node) {
  if (node.nodeName === '#text') {
    return 3;
  } else if (node.tagName != null) {
    return 1;
  } else {
    throw new Error('cannot detect nodeType');
  }
};

getAttribute = function(node, attribute) {
  var ref;
  return ((ref = _.find(node.attrs, {
    name: attribute
  })) != null ? ref.value : void 0) || null;
};

cleanText = function(node) {
  var parent, ref, text;
  parent = node.parentNode;
  text = decodeHtmlEntities(node.value);
  if ('pre' !== parent.nodeName && 'pre' !== parent.parentNode.nodeName) {
    text = text.replace(/\s+/g, ' ');
  }
  if ((ref = parent.nodeName) === 'code' || ref === 'pre') {
    return text;
  } else {
    return text.replace(/\u2014/g, '--').replace(/\u2018|\u2019/g, '\'').replace(/\u201c|\u201d/g, '"').replace(/\u2026/g, '...');
  }
};

htmlEntities = new Entities();

decodeHtmlEntities = function(text) {
  return htmlEntities.decode(text);
};

isBlock = function(node) {
  var ref;
  if (node.nodeName === 'code' && node.parentNode.nodeName === 'pre') {
    return true;
  } else {
    return ref = node.nodeName, indexOf.call(blocks, ref) >= 0;
  }
};

isVoid = function(node) {
  var ref;
  return ref = node.nodeName, indexOf.call(voids, ref) >= 0;
};

module.exports = {
  cleanText: cleanText,
  decodeHtmlEntities: decodeHtmlEntities,
  delimitCode: delimitCode,
  getAttribute: getAttribute,
  isBlock: isBlock,
  isVoid: isVoid,
  nodeType: nodeType,
  stringRepeat: stringRepeat
};
