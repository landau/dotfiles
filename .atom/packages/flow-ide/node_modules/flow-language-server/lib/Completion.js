'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asyncToGenerator = require('async-to-generator');

var _asyncToGenerator2 = _interopRequireDefault(_asyncToGenerator);

var _FlowSingleProjectLanguageService = require('./pkg/nuclide-flow-rpc/lib/FlowSingleProjectLanguageService');

var _simpleTextBuffer = require('simple-text-buffer');

var _vscodeUri = require('vscode-uri');

var _vscodeUri2 = _interopRequireDefault(_vscodeUri);

var _vscodeLanguageserverTypes = require('vscode-languageserver-types');

var _range = require('nuclide-commons/range');

var _TextDocuments = require('./TextDocuments');

var _TextDocuments2 = _interopRequireDefault(_TextDocuments);

var _nuclideFlowCommon = require('./pkg/nuclide-flow-common');

var _util = require('./utils/util');

var _log4js = require('log4js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const logger = (0, _log4js.getLogger)('Completion'); /**
                                                      * Copyright (c) 2017-present, Facebook, Inc.
                                                      * All rights reserved.
                                                      *
                                                      * This source code is licensed under the BSD-style license found in the
                                                      * LICENSE file in the root directory of this source tree. An additional grant
                                                      * of patent rights can be found in the PATENTS file in the same directory.
                                                      *
                                                      * 
                                                      * @format
                                                      */

class Completion {

  constructor({ clientCapabilities, documents, flow }) {
    this.clientCapabilities = clientCapabilities;
    this.documents = documents;
    this.flow = flow;
  }

  provideCompletionItems({
    textDocument,
    position
  }) {
    var _this = this;

    return (0, _asyncToGenerator2.default)(function* () {
      const fileName = _vscodeUri2.default.parse(textDocument.uri).fsPath;
      const doc = _this.documents.get(textDocument.uri);
      const point = (0, _util.lspPositionToAtomPoint)(position);
      // $FlowFixMe: Add to defs
      const prevPoint = point.traverse([0, -1]);
      const match = (0, _range.wordAtPositionFromBuffer)(doc.buffer, prevPoint, _nuclideFlowCommon.JAVASCRIPT_WORD_REGEX);
      let prefix = match && match.wordMatch && match.wordMatch[0] || '';
      // Ensure that we also trigger on object properties (".").
      if (point.column !== 0 && doc.buffer.getTextInRange(new _simpleTextBuffer.Range(prevPoint, point)) === '.') {
        prefix = '.';
      }

      const autocompleteResult = yield _this.flow.getAutocompleteSuggestions(fileName, doc.buffer, point, false, // activatedManually
      prefix);

      if (autocompleteResult) {
        const isIncomplete = autocompleteResult.isIncomplete,
              items = autocompleteResult.items;


        return {
          isIncomplete,
          items: items.map(function (atomCompletion) {
            const completion = {
              label: atomCompletion.displayText,
              kind: _this.typeToKind(atomCompletion.type, atomCompletion.description)
            };

            if (atomCompletion.description) {
              completion.documentation = atomCompletion.description;
            }

            if (completion.kind === _vscodeLanguageserverTypes.CompletionItemKind.Function) {
              const returnDetail = atomCompletion.leftLabel,
                    parametersDetail = atomCompletion.rightLabel;


              completion._returnDetail = returnDetail;
              completion._parametersDetail = parametersDetail;

              if (returnDetail != null && parametersDetail != null) {
                completion.detail = `${parametersDetail} => ${returnDetail}`;
              }
            } else {
              completion.detail = atomCompletion.rightLabel;
            }

            if (_this.clientCapabilities && _this.clientCapabilities.textDocument && _this.clientCapabilities.textDocument.completion && _this.clientCapabilities.textDocument.completion.completionItem && _this.clientCapabilities.textDocument.completion.completionItem.snippetSupport && atomCompletion.snippet) {
              completion.insertText = atomCompletion.snippet;
              completion.insertTextFormat = _vscodeLanguageserverTypes.InsertTextFormat.Snippet;
            } else {
              logger.debug('Was going to return a snippet completion, but the client does not support them');
            }

            return completion;
          })
        };
      }

      logger.debug('found no autocomplete results');
      return {
        isIncomplete: true,
        items: []
      };
    })();
  }

  typeToKind(type, description) {
    if (type === 'function') {
      return _vscodeLanguageserverTypes.CompletionItemKind.Function;
    }

    if (description && description.indexOf('[class: ') >= 0) {
      return _vscodeLanguageserverTypes.CompletionItemKind.Class;
    }

    return _vscodeLanguageserverTypes.CompletionItemKind.Variable;
  }
}
exports.default = Completion;
//# sourceMappingURL=Completion.js.map