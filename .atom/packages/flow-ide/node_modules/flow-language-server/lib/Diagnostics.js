'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asyncToGenerator = require('async-to-generator');

var _asyncToGenerator2 = _interopRequireDefault(_asyncToGenerator);

var _vscodeUri = require('vscode-uri');

var _vscodeUri2 = _interopRequireDefault(_vscodeUri);

var _FlowSingleProjectLanguageService = require('./pkg/nuclide-flow-rpc/lib/FlowSingleProjectLanguageService');

var _util = require('./utils/util');

var _log4js = require('log4js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

const logger = (0, _log4js.getLogger)('Diagnostics');

class Diagnostics {

  constructor({ flow }) {
    this.flow = flow;
  }

  diagnoseOne(document) {
    var _this = this;

    return (0, _asyncToGenerator2.default)(function* () {
      const documentPath = _vscodeUri2.default.parse(document.uri).fsPath;
      if (!documentPath) {
        return [];
      }

      const diagnostics = yield _this.flow.getDiagnostics(documentPath, document.buffer);

      if (diagnostics == null || diagnostics.filePathToMessages == null) {
        return [];
      }

      /* prettier-ignore */
      return Array.from(diagnostics.filePathToMessages.entries()).map(function ([filePath, messages]) {
        return fileDiagnosticUpdateToLSPDiagnostic({ filePath, messages });
      });
    })();
  }

  observe() {
    logger.info('Beginning to observe diagnostics');

    return this.flow.observeDiagnostics().map(diagnostics => diagnostics.map(fileDiagnosticUpdateToLSPDiagnostic));
  }
}

exports.default = Diagnostics;
function fileDiagnosticUpdateToLSPDiagnostic(diagnostic) {
  return {
    uri: _vscodeUri2.default.file(diagnostic.filePath).toString(),
    diagnostics: diagnostic.messages.filter(
    // range and message text are required for LSP
    d => d.range != null && d.text != null).map(message => ({
      // $FlowFixMe Diagnostics without range filtered out above
      range: (0, _util.atomRangeToLSPRange)(message.range),
      severity: (0, _util.flowSeverityToLSPSeverity)(message.type),
      message: toMessage(message),
      source: message.providerName
    }))
  };
}

function toMessage(diagnostic) {
  let message = diagnostic.text || '';
  if (diagnostic.trace && diagnostic.trace.length) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = diagnostic.trace[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        const trace = _step.value;

        if (trace.text != null) {
          // put new 'sentences' on their own line
          // $FlowFixMe text presence is asserted above
          if (trace.text[0] && trace.text[0] === trace.text[0].toUpperCase()) {
            message += '\n';
          } else {
            message += ' ';
          }
          message += trace.text;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return message;
}
//# sourceMappingURL=Diagnostics.js.map