{"version":3,"sources":["../src/Diagnostics.js"],"names":["logger","Diagnostics","constructor","flow","diagnoseOne","document","documentPath","parse","uri","fsPath","diagnostics","getDiagnostics","buffer","filePathToMessages","Array","from","entries","map","filePath","messages","fileDiagnosticUpdateToLSPDiagnostic","observe","info","observeDiagnostics","diagnostic","file","toString","filter","d","range","text","message","severity","type","toMessage","source","providerName","trace","length","toUpperCase"],"mappings":";;;;;;;;;;AAiBA;;;;AAEA;;AACA;;AACA;;;;AArBA;;;;;;;;;;;;AAuBA,MAAMA,SAAS,uBAAU,aAAV,CAAf;;AAMe,MAAMC,WAAN,CAAkB;;AAG/BC,cAAY,EAACC,IAAD,EAAZ,EAAuC;AACrC,SAAKA,IAAL,GAAYA,IAAZ;AACD;;AAEKC,aAAN,CACEC,QADF,EAE4C;AAAA;;AAAA;AAC1C,YAAMC,eAAe,oBAAIC,KAAJ,CAAUF,SAASG,GAAnB,EAAwBC,MAA7C;AACA,UAAI,CAACH,YAAL,EAAmB;AACjB,eAAO,EAAP;AACD;;AAED,YAAMI,cAAc,MAAM,MAAKP,IAAL,CAAUQ,cAAV,CACxBL,YADwB,EAExBD,SAASO,MAFe,CAA1B;;AAKA,UAAIF,eAAe,IAAf,IAAuBA,YAAYG,kBAAZ,IAAkC,IAA7D,EAAmE;AACjE,eAAO,EAAP;AACD;;AAED;AACA,aAAOC,MAAMC,IAAN,CAAWL,YAAYG,kBAAZ,CAA+BG,OAA/B,EAAX,EACJC,GADI,CACA,UAAC,CAACC,QAAD,EAAWC,QAAX,CAAD,EAA0B;AAC7B,eAAOC,oCAAoC,EAACF,QAAD,EAAWC,QAAX,EAApC,CAAP;AACD,OAHI,CAAP;AAhB0C;AAoB3C;;AAEDE,YAAuD;AACrDrB,WAAOsB,IAAP,CAAY,kCAAZ;;AAEA,WAAO,KAAKnB,IAAL,CACJoB,kBADI,GAEJN,GAFI,CAEAP,eAAeA,YAAYO,GAAZ,CAAgBG,mCAAhB,CAFf,CAAP;AAGD;AArC8B;;kBAAZnB,W;AAwCrB,SAASmB,mCAAT,CACEI,UADF,EAE4B;AAC1B,SAAO;AACLhB,SAAK,oBAAIiB,IAAJ,CAASD,WAAWN,QAApB,EAA8BQ,QAA9B,EADA;AAELhB,iBAAac,WAAWL,QAAX,CACVQ,MADU;AAET;AACAC,SAAKA,EAAEC,KAAF,IAAW,IAAX,IAAmBD,EAAEE,IAAF,IAAU,IAHzB,EAKVb,GALU,CAKNc,YAAY;AACf;AACAF,aAAO,+BAAoBE,QAAQF,KAA5B,CAFQ;AAGfG,gBAAU,qCAA0BD,QAAQE,IAAlC,CAHK;AAIfF,eAASG,UAAUH,OAAV,CAJM;AAKfI,cAAQJ,QAAQK;AALD,KAAZ,CALM;AAFR,GAAP;AAeD;;AAED,SAASF,SAAT,CAAmBV,UAAnB,EAA8D;AAC5D,MAAIO,UAAUP,WAAWM,IAAX,IAAmB,EAAjC;AACA,MAAIN,WAAWa,KAAX,IAAoBb,WAAWa,KAAX,CAAiBC,MAAzC,EAAiD;AAAA;AAAA;AAAA;;AAAA;AAC/C,2BAAoBd,WAAWa,KAA/B,8HAAsC;AAAA,cAA3BA,KAA2B;;AACpC,YAAIA,MAAMP,IAAN,IAAc,IAAlB,EAAwB;AACtB;AACA;AACA,cAAIO,MAAMP,IAAN,CAAW,CAAX,KAAiBO,MAAMP,IAAN,CAAW,CAAX,MAAkBO,MAAMP,IAAN,CAAW,CAAX,EAAcS,WAAd,EAAvC,EAAoE;AAClER,uBAAW,IAAX;AACD,WAFD,MAEO;AACLA,uBAAW,GAAX;AACD;AACDA,qBAAWM,MAAMP,IAAjB;AACD;AACF;AAZ8C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAahD;;AAED,SAAOC,OAAP;AACD","file":"Diagnostics.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport type {PublishDiagnosticsParams} from 'vscode-languageserver';\nimport type {FileDiagnosticMessage, FileDiagnosticMessages} from 'atom-ide-ui';\nimport type TextDocument from './TextDocument';\nimport type {Observable} from 'rxjs';\n\nimport URI from 'vscode-uri';\n\nimport {FlowSingleProjectLanguageService} from './pkg/nuclide-flow-rpc/lib/FlowSingleProjectLanguageService';\nimport {atomRangeToLSPRange, flowSeverityToLSPSeverity} from './utils/util';\nimport {getLogger} from 'log4js';\n\nconst logger = getLogger('Diagnostics');\n\ntype DiagnosticsParams = {\n  flow: FlowSingleProjectLanguageService,\n};\n\nexport default class Diagnostics {\n  flow: FlowSingleProjectLanguageService;\n\n  constructor({flow}: DiagnosticsParams) {\n    this.flow = flow;\n  }\n\n  async diagnoseOne(\n    document: TextDocument,\n  ): Promise<Array<PublishDiagnosticsParams>> {\n    const documentPath = URI.parse(document.uri).fsPath;\n    if (!documentPath) {\n      return [];\n    }\n\n    const diagnostics = await this.flow.getDiagnostics(\n      documentPath,\n      document.buffer,\n    );\n\n    if (diagnostics == null || diagnostics.filePathToMessages == null) {\n      return [];\n    }\n\n    /* prettier-ignore */\n    return Array.from(diagnostics.filePathToMessages.entries())\n      .map(([filePath, messages]) => {\n        return fileDiagnosticUpdateToLSPDiagnostic({filePath, messages});\n      });\n  }\n\n  observe(): Observable<Array<PublishDiagnosticsParams>> {\n    logger.info('Beginning to observe diagnostics');\n\n    return this.flow\n      .observeDiagnostics()\n      .map(diagnostics => diagnostics.map(fileDiagnosticUpdateToLSPDiagnostic));\n  }\n}\n\nfunction fileDiagnosticUpdateToLSPDiagnostic(\n  diagnostic: FileDiagnosticMessages,\n): PublishDiagnosticsParams {\n  return {\n    uri: URI.file(diagnostic.filePath).toString(),\n    diagnostics: diagnostic.messages\n      .filter(\n        // range and message text are required for LSP\n        d => d.range != null && d.text != null,\n      )\n      .map(message => ({\n        // $FlowFixMe Diagnostics without range filtered out above\n        range: atomRangeToLSPRange(message.range),\n        severity: flowSeverityToLSPSeverity(message.type),\n        message: toMessage(message),\n        source: message.providerName,\n      })),\n  };\n}\n\nfunction toMessage(diagnostic: FileDiagnosticMessage): string {\n  let message = diagnostic.text || '';\n  if (diagnostic.trace && diagnostic.trace.length) {\n    for (const trace of diagnostic.trace) {\n      if (trace.text != null) {\n        // put new 'sentences' on their own line\n        // $FlowFixMe text presence is asserted above\n        if (trace.text[0] && trace.text[0] === trace.text[0].toUpperCase()) {\n          message += '\\n';\n        } else {\n          message += ' ';\n        }\n        message += trace.text;\n      }\n    }\n  }\n\n  return message;\n}\n"]}