'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asyncToGenerator = require('async-to-generator');

var _asyncToGenerator2 = _interopRequireDefault(_asyncToGenerator);

var _nullthrows = require('nullthrows');

var _nullthrows2 = _interopRequireDefault(_nullthrows);

var _vscodeUri = require('vscode-uri');

var _vscodeUri2 = _interopRequireDefault(_vscodeUri);

var _vscodeLanguageserverTypes = require('vscode-languageserver-types');

var _FlowSingleProjectLanguageService = require('./pkg/nuclide-flow-rpc/lib/FlowSingleProjectLanguageService');

var _TextDocuments = require('./TextDocuments');

var _TextDocuments2 = _interopRequireDefault(_TextDocuments);

var _util = require('./utils/util');

var _log4js = require('log4js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const logger = (0, _log4js.getLogger)('Symbol'); /**
                                                  * Copyright (c) 2017-present, Facebook, Inc.
                                                  * All rights reserved.
                                                  *
                                                  * This source code is licensed under the BSD-style license found in the
                                                  * LICENSE file in the root directory of this source tree. An additional grant
                                                  * of patent rights can be found in the PATENTS file in the same directory.
                                                  *
                                                  * 
                                                  * @format
                                                  */

class SymbolSupport {

  constructor({ documents, flow }) {
    this.documents = documents;
    this.flow = flow;
  }

  provideDocumentSymbol(params) {
    var _this = this;

    return (0, _asyncToGenerator2.default)(function* () {
      logger.debug('document symbols requested');
      const textDocument = params.textDocument;


      const fileName = _vscodeUri2.default.parse(textDocument.uri).fsPath;
      const doc = _this.documents.get(textDocument.uri);

      const outline = yield _this.flow.getOutline(fileName, doc.buffer);

      if (!outline) {
        logger.debug('returning empty list of symbols');
        return [];
      }

      return treesToItems(outline.outlineTrees, null, doc.uri);
    })();
  }
}

exports.default = SymbolSupport;
function treesToItems(trees, containerName, uri) {
  const items = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = trees[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      const tree = _step.value;

      if (!tree.representativeName && !tree.children.length) {
        continue;
      }

      const name = tree.representativeName;
      const kind = tree.kind;
      if (name == null || kind == null) {
        continue;
      }

      const item = {
        name,
        kind: OUTLINE_KIND_TO_LSP_KIND[kind],
        location: {
          uri,
          range: {
            start: (0, _util.atomPointToLSPPosition)(tree.startPosition),
            end: (0, _util.atomPointToLSPPosition)((0, _nullthrows2.default)(tree.endPosition))
          }
        }
      };

      if (containerName != null) {
        item.containerName = containerName;
      }

      items.push(item, ...treesToItems(tree.children, name, uri));
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return items;
}

const OUTLINE_KIND_TO_LSP_KIND = {
  array: _vscodeLanguageserverTypes.SymbolKind.Array,
  boolean: _vscodeLanguageserverTypes.SymbolKind.Boolean,
  class: _vscodeLanguageserverTypes.SymbolKind.Class,
  constant: _vscodeLanguageserverTypes.SymbolKind.Constant,
  constructor: _vscodeLanguageserverTypes.SymbolKind.Constructor,
  enum: _vscodeLanguageserverTypes.SymbolKind.Enum,
  field: _vscodeLanguageserverTypes.SymbolKind.Field,
  file: _vscodeLanguageserverTypes.SymbolKind.File,
  function: _vscodeLanguageserverTypes.SymbolKind.Function,
  interface: _vscodeLanguageserverTypes.SymbolKind.Interface,
  method: _vscodeLanguageserverTypes.SymbolKind.Method,
  module: _vscodeLanguageserverTypes.SymbolKind.Module,
  namespace: _vscodeLanguageserverTypes.SymbolKind.Namespace,
  number: _vscodeLanguageserverTypes.SymbolKind.Number,
  package: _vscodeLanguageserverTypes.SymbolKind.Package,
  property: _vscodeLanguageserverTypes.SymbolKind.Property,
  string: _vscodeLanguageserverTypes.SymbolKind.String,
  variable: _vscodeLanguageserverTypes.SymbolKind.Variable
};
//# sourceMappingURL=Symbol.js.map