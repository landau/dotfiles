'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _simpleTextBuffer = require('simple-text-buffer');

var _simpleTextBuffer2 = _interopRequireDefault(_simpleTextBuffer);

var _UniversalDisposable = require('nuclide-commons/UniversalDisposable');

var _UniversalDisposable2 = _interopRequireDefault(_UniversalDisposable);

var _eventKit = require('event-kit');

var _util = require('./utils/util');

var _log4js = require('log4js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

const logger = (0, _log4js.getLogger)('TextDocument');

class TextDocument {

  constructor(uri, languageId, version, text) {
    this.isDirty = false;
    this._disposables = new _UniversalDisposable2.default();
    this._emitter = new _eventKit.Emitter();

    this._handleDidStopChanging = () => {
      this.assertNotDisposed();
      this._emitter.emit('didStopChanging', this);
    };

    this.uri = uri;
    this.languageId = languageId;
    this.version = version;
    this.buffer = new _simpleTextBuffer2.default(text);

    this._disposables.add(this._emitter);
    this._disposables.add(this.buffer.onDidStopChanging(this._handleDidStopChanging));
  }

  assertNotDisposed() {
    (0, _assert2.default)(!this.disposed, `TextDocument with uri ${this.uri} was already disposed`);
  }

  dispose() {
    this.assertNotDisposed();
    this._disposables.dispose();
  }

  get disposed() {
    return this._disposables.disposed;
  }

  get lineCount() {
    this.assertNotDisposed();
    return this.buffer.getLineCount();
  }

  getText() {
    this.assertNotDisposed();
    return this.buffer.getText();
  }

  offsetAt(position) {
    this.assertNotDisposed();
    return this.buffer.characterIndexForPosition((0, _util.lspPositionToAtomPoint)(position));
  }

  onDidStopChanging(handler) {
    this.assertNotDisposed();
    return this._emitter.on('didStopChanging', handler);
  }

  onDidSave(handler) {
    this.assertNotDisposed();
    return this._emitter.on('didSave', handler);
  }

  positionAt(offset) {
    this.assertNotDisposed();
    return (0, _util.atomPointToLSPPosition)(this.buffer.positionForCharacterIndex(offset));
  }

  save(version, text) {
    this.assertNotDisposed();
    if (text != null) {
      this.buffer.setText(text);
    }

    this.version = version;
    this.isDirty = false;
    this._emitter.emit('didSave', this);
    logger.debug(`TextDocument: saved ${this.uri} and marked not dirty`);
  }

  updateMany(changes, version) {
    this.assertNotDisposed();

    this.isDirty = true;
    this.version = version;

    // Ensure that ranged changes are sorted in reverse order.
    // Otherwise, the changes can't be applied cleanly.
    changes.sort((a, b) => {
      (0, _assert2.default)(a.range != null && b.range != null, 'There should only be one full-text update.');
      return (0, _util.compareLspRange)(b.range, a.range);
    });

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = changes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        const change = _step.value;

        if (change.range != null) {
          // Incremental update
          this.buffer.setTextInRange((0, _util.lspRangeToAtomRange)(change.range), change.text);
        } else {
          // Full text update
          this.buffer.setText(change.text);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    logger.debug(`TextDocument: ${this.uri} updated and marked dirty`);
  }

}
exports.default = TextDocument;
//# sourceMappingURL=TextDocument.js.map