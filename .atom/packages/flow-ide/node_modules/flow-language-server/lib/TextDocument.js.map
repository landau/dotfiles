{"version":3,"sources":["../src/TextDocument.js"],"names":["logger","TextDocument","constructor","uri","languageId","version","text","isDirty","_disposables","_emitter","_handleDidStopChanging","assertNotDisposed","emit","buffer","add","onDidStopChanging","disposed","dispose","lineCount","getLineCount","getText","offsetAt","position","characterIndexForPosition","handler","on","onDidSave","positionAt","offset","positionForCharacterIndex","save","setText","debug","updateMany","changes","sort","a","b","range","change","setTextInRange"],"mappings":"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","file":"TextDocument.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport invariant from 'assert';\nimport SimpleTextBuffer from 'simple-text-buffer';\nimport UniversalDisposable from 'nuclide-commons/UniversalDisposable';\nimport {Emitter} from 'event-kit';\nimport {\n  atomPointToLSPPosition,\n  compareLspRange,\n  lspPositionToAtomPoint,\n  lspRangeToAtomRange,\n} from './utils/util';\nimport {getLogger} from 'log4js';\n\nconst logger = getLogger('TextDocument');\n\nexport default class TextDocument {\n  buffer: SimpleTextBuffer;\n  isDirty: boolean = false;\n  languageId: string;\n  uri: string;\n  version: number;\n\n  _disposables: UniversalDisposable = new UniversalDisposable();\n  _emitter: Emitter = new Emitter();\n\n  constructor(uri: string, languageId: string, version: number, text: string) {\n    this.uri = uri;\n    this.languageId = languageId;\n    this.version = version;\n    this.buffer = new SimpleTextBuffer(text);\n\n    this._disposables.add(this._emitter);\n    this._disposables.add(\n      this.buffer.onDidStopChanging(this._handleDidStopChanging),\n    );\n  }\n\n  assertNotDisposed() {\n    invariant(\n      !this.disposed,\n      `TextDocument with uri ${this.uri} was already disposed`,\n    );\n  }\n\n  dispose() {\n    this.assertNotDisposed();\n    this._disposables.dispose();\n  }\n\n  get disposed(): boolean {\n    return this._disposables.disposed;\n  }\n\n  get lineCount(): number {\n    this.assertNotDisposed();\n    return this.buffer.getLineCount();\n  }\n\n  getText(): string {\n    this.assertNotDisposed();\n    return this.buffer.getText();\n  }\n\n  offsetAt(position: Position): number {\n    this.assertNotDisposed();\n    return this.buffer.characterIndexForPosition(\n      lspPositionToAtomPoint(position),\n    );\n  }\n\n  onDidStopChanging(handler: (document: TextDocument) => mixed): IDisposable {\n    this.assertNotDisposed();\n    return this._emitter.on('didStopChanging', handler);\n  }\n\n  onDidSave(handler: (document: TextDocument) => mixed): IDisposable {\n    this.assertNotDisposed();\n    return this._emitter.on('didSave', handler);\n  }\n\n  positionAt(offset: number): Position {\n    this.assertNotDisposed();\n    return atomPointToLSPPosition(\n      this.buffer.positionForCharacterIndex(offset),\n    );\n  }\n\n  save(version: number, text: ?string) {\n    this.assertNotDisposed();\n    if (text != null) {\n      this.buffer.setText(text);\n    }\n\n    this.version = version;\n    this.isDirty = false;\n    this._emitter.emit('didSave', this);\n    logger.debug(`TextDocument: saved ${this.uri} and marked not dirty`);\n  }\n\n  updateMany(changes: Array<TextDocumentContentChangeEvent>, version: number) {\n    this.assertNotDisposed();\n\n    this.isDirty = true;\n    this.version = version;\n\n    // Ensure that ranged changes are sorted in reverse order.\n    // Otherwise, the changes can't be applied cleanly.\n    changes.sort((a, b) => {\n      invariant(\n        a.range != null && b.range != null,\n        'There should only be one full-text update.',\n      );\n      return compareLspRange(b.range, a.range);\n    });\n\n    for (const change of changes) {\n      if (change.range != null) {\n        // Incremental update\n        this.buffer.setTextInRange(\n          lspRangeToAtomRange(change.range),\n          change.text,\n        );\n      } else {\n        // Full text update\n        this.buffer.setText(change.text);\n      }\n    }\n\n    logger.debug(`TextDocument: ${this.uri} updated and marked dirty`);\n  }\n\n  _handleDidStopChanging = () => {\n    this.assertNotDisposed();\n    this._emitter.emit('didStopChanging', this);\n  };\n}\n"]}