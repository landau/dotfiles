'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asyncToGenerator = require('async-to-generator');

var _asyncToGenerator2 = _interopRequireDefault(_asyncToGenerator);

let getFlowVersionInfo = (() => {
  var _ref3 = (0, _asyncToGenerator2.default)(function* (rootPath, connection, flowOptions) {
    const versionLogger = (0, _log4js.getLogger)('flow-versions');

    if (flowOptions.flowPath != null) {
      connection.window.showInformationMessage('path to flow ' + flowOptions.flowPath);
      if (!_nuclideUri2.default.isAbsolute(flowOptions.flowPath)) {
        connection.window.showErrorMessage('Supplied path to flow was not absolute. Specify a complete path to ' + 'the flow binary or leave the option empty for Flow to be managed ' + 'for you.');
        return null;
      }

      const flowVersionInfo = yield (0, _utils.versionInfoForPath)(rootPath, flowOptions.flowPath);
      if (!flowVersionInfo) {
        connection.window.showErrorMessage('Invalid path to flow binary.');
      }
      versionLogger.info(`Using the provided path to flow binary at ${flowOptions.flowPath}`);

      return flowVersionInfo;
    }

    const downloadManagerLogger = {
      error: connection.window.showErrorMessage.bind(connection.window),
      info: versionLogger.info.bind(versionLogger),
      warn: versionLogger.warn.bind(versionLogger)
    };

    const versionInfo = yield (0, _flowBinForRoot.flowBinForPath)(rootPath, {
      autoDownloadFlow: flowOptions.autoDownloadFlow,
      reporter: downloadManagerLogger,
      semverDownloader: _githubSemverDownloader.downloadSemverFromGitHub,
      tryFlowBin: flowOptions.tryFlowBin
    });

    if (!versionInfo) {
      versionLogger.error('There was a problem obtaining the appropriate version of flow for ' + 'your project. Please check the extension logs.');
    }

    return versionInfo;
  });

  return function getFlowVersionInfo(_x3, _x4, _x5) {
    return _ref3.apply(this, arguments);
  };
})();

exports.createServer = createServer;

var _nuclideUri = require('nuclide-commons/nuclideUri');

var _nuclideUri2 = _interopRequireDefault(_nuclideUri);

var _UniversalDisposable = require('nuclide-commons/UniversalDisposable');

var _UniversalDisposable2 = _interopRequireDefault(_UniversalDisposable);

var _vscodeLanguageserver = require('vscode-languageserver');

var _Completion = require('./Completion');

var _Completion2 = _interopRequireDefault(_Completion);

var _Definition = require('./Definition');

var _Definition2 = _interopRequireDefault(_Definition);

var _Diagnostics = require('./Diagnostics');

var _Diagnostics2 = _interopRequireDefault(_Diagnostics);

var _Hover = require('./Hover');

var _Hover2 = _interopRequireDefault(_Hover);

var _Symbol = require('./Symbol');

var _Symbol2 = _interopRequireDefault(_Symbol);

var _TextDocuments = require('./TextDocuments');

var _TextDocuments2 = _interopRequireDefault(_TextDocuments);

var _FlowExecInfoContainer = require('./pkg/nuclide-flow-rpc/lib/FlowExecInfoContainer');

var _FlowSingleProjectLanguageService = require('./pkg/nuclide-flow-rpc/lib/FlowSingleProjectLanguageService');

var _log4js = require('log4js');

var _flowBinForRoot = require('./flow-versions/flowBinForRoot');

var _githubSemverDownloader = require('./flow-versions/githubSemverDownloader');

var _utils = require('./flow-versions/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

const SUPPORTS_PERSISTENT_CONNECTION = process.platform !== 'win32';

function createServer(connection, initialFlowOptions) {
  const logger = (0, _log4js.getLogger)('index');
  const disposable = new _UniversalDisposable2.default();
  const documents = new _TextDocuments2.default();

  disposable.add(documents);

  connection.onShutdown(() => {
    logger.debug('LSP server connection shutting down');
    disposable.dispose();
  });

  connection.onInitialize((() => {
    var _ref = (0, _asyncToGenerator2.default)(function* ({ capabilities, rootPath }) {
      const root = rootPath || process.cwd();

      logger.debug('LSP connection initialized. Connecting to flow...');

      const flowVersionInfo = yield getFlowVersionInfo(root, connection, initialFlowOptions);
      if (!flowVersionInfo) {
        return { capabilities: {} };
      }
      const flowContainer = new _FlowExecInfoContainer.FlowExecInfoContainer(flowVersionInfo);
      const flow = new _FlowSingleProjectLanguageService.FlowSingleProjectLanguageService(root, flowContainer);

      disposable.add(flow, flow.getServerStatusUpdates().distinctUntilChanged().subscribe(function (statusType) {
        connection.console.info(`Flow status: ${statusType}`);
      }));

      const diagnostics = new _Diagnostics2.default({ flow });

      if (SUPPORTS_PERSISTENT_CONNECTION) {
        disposable.add(diagnostics.observe().subscribe(function (diagnosticItems) {
          return diagnosticItems.forEach(connection.sendDiagnostics);
        }));
      } else {
        // Flow doesn't support its persistent connection well on Windows,
        // so fall back to monitoring open and save events to offer diagnostics
        const diagnoseAndSend = (() => {
          var _ref2 = (0, _asyncToGenerator2.default)(function* ({ document }) {
            const diagnosticItems = yield diagnostics.diagnoseOne(document);
            diagnosticItems.forEach(connection.sendDiagnostics);
          });

          return function diagnoseAndSend(_x2) {
            return _ref2.apply(this, arguments);
          };
        })();

        documents.onDidSave(diagnoseAndSend);
        documents.onDidOpen(diagnoseAndSend);
      }

      const completion = new _Completion2.default({
        clientCapabilities: capabilities,
        documents,
        flow
      });
      connection.onCompletion(function (docParams) {
        logger.debug(`completion requested for document ${docParams.textDocument.uri}`);
        return completion.provideCompletionItems(docParams);
      });

      connection.onCompletionResolve(function () {
        // for now, noop as we can't/don't need to provide any additional
        // information on resolve, but need to respond to implement completion
      });

      const definition = new _Definition2.default({ documents, flow });
      connection.onDefinition(function (docParams) {
        logger.debug(`definition requested for document ${docParams.textDocument.uri}`);
        return definition.provideDefinition(docParams);
      });

      const hover = new _Hover2.default({ documents, flow });
      connection.onHover(function (docParams) {
        return hover.provideHover(docParams);
      });

      const symbols = new _Symbol2.default({ documents, flow });
      connection.onDocumentSymbol(function (symbolParams) {
        logger.debug(`symbols requested for document ${symbolParams.textDocument.uri}`);
        return symbols.provideDocumentSymbol(symbolParams);
      });

      logger.info('Flow language server started');

      return {
        capabilities: {
          textDocumentSync: documents.syncKind,
          definitionProvider: true,
          documentSymbolProvider: true,
          completionProvider: {
            resolveProvider: true,
            triggerCharacters: ['.']
          },
          hoverProvider: true
        }
      };
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  })());

  return {
    listen() {
      documents.listen(connection);
      connection.listen();
    }
  };
}
//# sourceMappingURL=index.js.map