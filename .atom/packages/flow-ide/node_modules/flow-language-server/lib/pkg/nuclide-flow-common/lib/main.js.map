{"version":3,"sources":["../../../../src/pkg/nuclide-flow-common/lib/main.js"],"names":["getReplacementPrefix","shouldFilter","filterResultsByPrefix","flowCoordsToAtomCoords","JAVASCRIPT_IDENTIFIER_REGEX","JAVASCRIPT_WHOLE_STRING_IDENTIFIER_REGEX","identifierOrNumber","makeStrRegex","delimiter","d","strRegexes","map","regexStrings","concat","s","JAVASCRIPT_WORD_REGEX","RegExp","join","originalPrefix","test","lastRequest","currentRequest","charsSinceLastRequest","prefixIsIdentifier","prefix","previousPrefixIsDot","prefixLengthDifference","length","startsWithPrevious","startsWith","results","replacementPrefix","resultsWithCurrentPrefix","items","result","filter","key","flowCoords","start","line","column","end"],"mappings":";;;;;;;kQAAA;;;;;;;;;;;;QA2CgBA,oB,GAAAA,oB;QAQAC,Y,GAAAA,Y;QAuBAC,qB,GAAAA,qB;QAuBAC,sB,GAAAA,sB;;AArFhB;;AAEA;;;;;;AAOA;AACO,MAAMC,oEAA8B,oBAApC;;AAEA,MAAMC,8FAA2C,qBAAjD;;AAEP,MAAMC,qBAAqB,gBAA3B;;AAEA,SAASC,YAAT,CAAsBC,SAAtB,EAAiD;AAC/C,QAAMC,IAAID,SAAV;AACA;AACA;AACA,SAAQ,GAAEC,CAAE,YAAWA,CAAE,UAASA,CAAE,EAApC;AACD;;AAED,MAAMC,aAAa,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgBC,GAAhB,CAAoBJ,YAApB,CAAnB;;AAEA,MAAMK,eAAe,GAClBC,MADkB,CACXH,UADW,EACC,CAACJ,kBAAD,CADD,EAElBK,GAFkB,CAEdG,KAAM,IAAGA,CAAE,GAFG,CAArB;;AAIO,MAAMC,wDAAwB,IAAIC,MAAJ,CAAWJ,aAAaK,IAAb,CAAkB,GAAlB,CAAX,EAAmC,GAAnC,CAA9B;;AAEA,SAASjB,oBAAT,CAA8BkB,cAA9B,EAA8D;AACnE;AACA;AACA,SAAOb,yCAAyCc,IAAzC,CAA8CD,cAA9C,IACHA,cADG,GAEH,EAFJ;AAGD;;AAEM,SAASjB,YAAT,CACLmB,WADK,EAELC,cAFK,EAGLC,qBAHK,EAII;AACT,QAAMC,qBAAqBlB,yCAAyCc,IAAzC,CACzBE,eAAeG,MADU,CAA3B;AAGA,QAAMC,sBAAsB,aAAaN,IAAb,CAAkBC,YAAYI,MAA9B,CAA5B;AACA,QAAME,yBACJL,eAAeG,MAAf,CAAsBG,MAAtB,GAA+BP,YAAYI,MAAZ,CAAmBG,MADpD;AAEA,QAAMC,qBAAqBP,eAAeG,MAAf,CAAsBK,UAAtB,CACzBT,YAAYI,MADa,CAA3B;;AAIA,SACED,uBACEE,uBACAJ,eAAeG,MAAf,CAAsBG,MAAtB,KAAiCL,qBADlC,IAEEM,sBAAsBF,2BAA2BJ,qBAHpD,CADF;AAMD;;AAEM,SAASpB,qBAAT,CACLsB,MADK,EAELM,OAFK,EAGe;AACpB,QAAMC,oBAAoB/B,qBAAqBwB,MAArB,CAA1B;AACA,QAAMQ,2BAA2BF,QAAQG,KAAR,CAActB,GAAd,CAAkBuB,UAAU;AAC3D,wBACKA,MADL;AAEEH;AAFF;AAID,GALgC,CAAjC;AAMA,MAAIE,KAAJ;AACA;AACA,MAAIF,sBAAsB,EAA1B,EAA8B;AAC5BE,YAAQD,wBAAR;AACD,GAFD,MAEO;AACLC,YAAQ,yBAAeE,MAAf,CAAsBH,wBAAtB,EAAgDD,iBAAhD,EAAmE;AACzEK,WAAK;AADoE,KAAnE,CAAR;AAGD;AACD,sBAAWN,OAAX,IAAoBG,KAApB;AACD;;AAEM,SAAS9B,sBAAT,CACLkC,UADK,EAEO;AACZ,SAAO,4BACL,CAACA,WAAWC,KAAX,CAAiBC,IAAjB,GAAwB,CAAzB,EAA4BF,WAAWC,KAAX,CAAiBE,MAAjB,GAA0B,CAAtD,CADK,EAEL,CACEH,WAAWI,GAAX,CAAeF,IAAf,GAAsB,CADxB;AAEE;AACAF,aAAWI,GAAX,CAAeD,MAHjB,CAFK,CAAP;AAQD","file":"main.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport {Range} from 'simple-text-buffer';\n\nimport fuzzaldrinPlus from 'fuzzaldrin-plus';\n\nimport type {\n  AutocompleteResult,\n} from '../../nuclide-language-service/lib/LanguageService';\nimport type {FlowLocNoSource} from '../../nuclide-flow-rpc';\n\n// A simple heuristic for identifier names in JavaScript.\nexport const JAVASCRIPT_IDENTIFIER_REGEX = /[$_a-zA-Z][$_\\w]*/g;\n\nexport const JAVASCRIPT_WHOLE_STRING_IDENTIFIER_REGEX = /^[$_a-zA-Z][$_\\w]*$/;\n\nconst identifierOrNumber = '[a-zA-Z0-9_$]+';\n\nfunction makeStrRegex(delimiter: string): string {\n  const d = delimiter;\n  // Each run of four backslashes ends up as just one backslash. We need to escape once for the\n  // string literal here, and once for the RegExp compilation.\n  return `${d}(\\\\\\\\.|[^${d}\\\\\\\\])*${d}`;\n}\n\nconst strRegexes = ['`', \"'\", '\"'].map(makeStrRegex);\n\nconst regexStrings = []\n  .concat(strRegexes, [identifierOrNumber])\n  .map(s => `(${s})`);\n\nexport const JAVASCRIPT_WORD_REGEX = new RegExp(regexStrings.join('|'), 'g');\n\nexport function getReplacementPrefix(originalPrefix: string): string {\n  // Ignore prefix unless it's an identifier (this keeps us from eating leading\n  // dots, colons, etc).\n  return JAVASCRIPT_WHOLE_STRING_IDENTIFIER_REGEX.test(originalPrefix)\n    ? originalPrefix\n    : '';\n}\n\nexport function shouldFilter(\n  lastRequest: atom$AutocompleteRequest,\n  currentRequest: atom$AutocompleteRequest,\n  charsSinceLastRequest: number,\n): boolean {\n  const prefixIsIdentifier = JAVASCRIPT_WHOLE_STRING_IDENTIFIER_REGEX.test(\n    currentRequest.prefix,\n  );\n  const previousPrefixIsDot = /^\\s*\\.\\s*$/.test(lastRequest.prefix);\n  const prefixLengthDifference =\n    currentRequest.prefix.length - lastRequest.prefix.length;\n  const startsWithPrevious = currentRequest.prefix.startsWith(\n    lastRequest.prefix,\n  );\n\n  return (\n    prefixIsIdentifier &&\n    ((previousPrefixIsDot &&\n      currentRequest.prefix.length === charsSinceLastRequest) ||\n      (startsWithPrevious && prefixLengthDifference === charsSinceLastRequest))\n  );\n}\n\nexport function filterResultsByPrefix(\n  prefix: string,\n  results: AutocompleteResult,\n): AutocompleteResult {\n  const replacementPrefix = getReplacementPrefix(prefix);\n  const resultsWithCurrentPrefix = results.items.map(result => {\n    return {\n      ...result,\n      replacementPrefix,\n    };\n  });\n  let items;\n  // fuzzaldrin-plus filters everything when the query is empty.\n  if (replacementPrefix === '') {\n    items = resultsWithCurrentPrefix;\n  } else {\n    items = fuzzaldrinPlus.filter(resultsWithCurrentPrefix, replacementPrefix, {\n      key: 'displayText',\n    });\n  }\n  return {...results, items};\n}\n\nexport function flowCoordsToAtomCoords(\n  flowCoords: FlowLocNoSource,\n): atom$Range {\n  return new Range(\n    [flowCoords.start.line - 1, flowCoords.start.column - 1],\n    [\n      flowCoords.end.line - 1,\n      // Yes, this is inconsistent. Yes, it works as expected in practice.\n      flowCoords.end.column,\n    ],\n  );\n}\n"]}