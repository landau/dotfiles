'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FlowIDEConnection = undefined;

var _eventKit = require('event-kit');

var _rxjs = require('rxjs');

var _vscodeJsonrpc = require('vscode-jsonrpc');

var rpc = _interopRequireWildcard(_vscodeJsonrpc);

var _through = require('through');

var _through2 = _interopRequireDefault(_through);

var _UniversalDisposable = require('nuclide-commons/UniversalDisposable');

var _UniversalDisposable2 = _interopRequireDefault(_UniversalDisposable);

var _nuclideAnalytics = require('../../nuclide-analytics');

var _log4js = require('log4js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// TODO put these in flow-typed when they are fleshed out better

const SUBSCRIBE_METHOD_NAME = 'subscribeToDiagnostics'; /**
                                                         * Copyright (c) 2017-present, Facebook, Inc.
                                                         * All rights reserved.
                                                         *
                                                         * This source code is licensed under the BSD-style license found in the
                                                         * LICENSE file in the root directory of this source tree. An additional grant
                                                         * of patent rights can be found in the PATENTS file in the same directory.
                                                         *
                                                         * 
                                                         * @format
                                                         */

const NOTIFICATION_METHOD_NAME = 'diagnosticsNotification';

const SUBSCRIBE_RETRY_INTERVAL = 5000;
const SUBSCRIBE_RETRIES = 10;

// Manages the connection to a single `flow ide` process. The lifecycle of an instance of this class
// is tied to the lifecycle of a the `flow ide` process.
class FlowIDEConnection {

  // Because vscode-jsonrpc offers no mechanism to unsubscribe from notifications, we have to make
  // sure that we put a bound on the number of times we add subscriptions, otherwise we could have a
  // memory leak. The most sensible bound is to just allow a single subscription per message type.
  // Therefore, we must have singleton observables rather than returning new instances from method
  // calls.
  constructor(process) {
    this._disposables = new _UniversalDisposable2.default();
    this._ideProcess = process;
    this._ideProcess.stderr.pipe((0, _through2.default)(msg => {
      (0, _log4js.getLogger)('nuclide-flow-rpc').info('Flow IDE process stderr: ', msg.toString());
    }));
    this._connection = rpc.createMessageConnection(new rpc.StreamMessageReader(this._ideProcess.stdout), new rpc.StreamMessageWriter(this._ideProcess.stdin));
    this._connection.listen();

    this._ideProcess.on('exit', () => this.dispose());
    this._ideProcess.on('close', () => this.dispose());

    this._diagnostics = _rxjs.Observable.fromEventPattern(handler => {
      this._connection.onNotification(NOTIFICATION_METHOD_NAME, errors => {
        handler(errors);
      });
    },
    // no-op: vscode-jsonrpc offers no way to unsubscribe
    () => {}).publishReplay(1);
    this._disposables.add(this._diagnostics.connect());

    this._recheckBookends = _rxjs.Observable.fromEventPattern(handler => {
      this._connection.onNotification('startRecheck', () => {
        handler({ kind: 'start-recheck' });
      });
      this._connection.onNotification('endRecheck', () => {
        handler({ kind: 'end-recheck' });
      });
    },
    // no-op
    () => {}).publish();
    this._disposables.add(this._recheckBookends.connect());

    this._disposables.add(() => {
      this._ideProcess.stdin.end();
      this._ideProcess.kill();

      this._connection.dispose();
    });
  }

  dispose() {
    this._disposables.dispose();
  }

  onWillDispose(callback) {
    this._disposables.add(callback);
    return new _eventKit.Disposable(() => {
      this._disposables.remove(callback);
    });
  }

  observeDiagnostics() {
    const subscribe = () => {
      this._connection.sendNotification(SUBSCRIBE_METHOD_NAME);
    };

    const retrySubscription = _rxjs.Observable.interval(SUBSCRIBE_RETRY_INTERVAL).take(SUBSCRIBE_RETRIES).takeUntil(this._diagnostics).subscribe(() => {
      (0, _log4js.getLogger)('nuclide-flow-rpc').error('Did not receive diagnostics after subscribe request -- retrying...');
      (0, _nuclideAnalytics.track)('nuclide-flow.missing-push-diagnostics');
      subscribe();
    });

    subscribe();
    return _rxjs.Observable.using(() => retrySubscription, () => {
      return _rxjs.Observable.merge(this._diagnostics.map(errors => ({ kind: 'errors', errors })), this._recheckBookends);
    });
  }

  // Flow will not send these messages unless we have subscribed to diagnostics. So, this observable
  // will never emit any items unless observeDiagnostics() is called.
  observeRecheckBookends() {
    return this._recheckBookends;
  }

  getAutocompleteSuggestions(filePath, line, column, contents) {
    return this._connection.sendRequest('autocomplete', filePath, line, column, contents);
  }
}
exports.FlowIDEConnection = FlowIDEConnection;
//# sourceMappingURL=FlowIDEConnection.js.map