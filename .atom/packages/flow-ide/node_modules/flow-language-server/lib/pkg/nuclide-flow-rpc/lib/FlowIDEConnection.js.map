{"version":3,"sources":["../../../../src/pkg/nuclide-flow-rpc/lib/FlowIDEConnection.js"],"names":["rpc","SUBSCRIBE_METHOD_NAME","NOTIFICATION_METHOD_NAME","SUBSCRIBE_RETRY_INTERVAL","SUBSCRIBE_RETRIES","FlowIDEConnection","constructor","process","_disposables","_ideProcess","stderr","pipe","msg","info","toString","_connection","createMessageConnection","StreamMessageReader","stdout","StreamMessageWriter","stdin","listen","on","dispose","_diagnostics","fromEventPattern","handler","onNotification","errors","publishReplay","add","connect","_recheckBookends","kind","publish","end","kill","onWillDispose","callback","remove","observeDiagnostics","subscribe","sendNotification","retrySubscription","interval","take","takeUntil","error","using","merge","map","observeRecheckBookends","getAutocompleteSuggestions","filePath","line","column","contents","sendRequest"],"mappings":"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","file":"FlowIDEConnection.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport type {NuclideUri} from 'nuclide-commons/nuclideUri';\n\nimport type {FlowStatusOutput, FlowAutocompleteOutput} from './flowOutputTypes';\n\nimport {Disposable} from 'event-kit';\nimport {Observable} from 'rxjs';\nimport * as rpc from 'vscode-jsonrpc';\nimport through from 'through';\n\nimport UniversalDisposable from 'nuclide-commons/UniversalDisposable';\nimport {track} from '../../nuclide-analytics';\nimport {getLogger} from 'log4js';\n\n// TODO put these in flow-typed when they are fleshed out better\n\ntype MessageHandler = (...args: any) => mixed;\n\ntype RpcConnection = {\n  onNotification(methodName: string, handler: MessageHandler): void,\n  sendNotification(methodName: string, ...args: any): void,\n  sendRequest(methodName: string, ...args: any): Promise<any>,\n  // TODO requests\n  listen(): void,\n  dispose(): void,\n};\n\nexport type PushDiagnosticsMessage =\n  | RecheckBookend\n  | {\n      kind: 'errors',\n      errors: FlowStatusOutput,\n    };\n\nexport type RecheckBookend =\n  | {\n      kind: 'start-recheck',\n    }\n  | {\n      kind: 'end-recheck',\n    };\n\nconst SUBSCRIBE_METHOD_NAME = 'subscribeToDiagnostics';\n\nconst NOTIFICATION_METHOD_NAME = 'diagnosticsNotification';\n\nconst SUBSCRIBE_RETRY_INTERVAL = 5000;\nconst SUBSCRIBE_RETRIES = 10;\n\n// Manages the connection to a single `flow ide` process. The lifecycle of an instance of this class\n// is tied to the lifecycle of a the `flow ide` process.\nexport class FlowIDEConnection {\n  _connection: RpcConnection;\n  _ideProcess: child_process$ChildProcess;\n  _disposables: UniversalDisposable;\n\n  // Because vscode-jsonrpc offers no mechanism to unsubscribe from notifications, we have to make\n  // sure that we put a bound on the number of times we add subscriptions, otherwise we could have a\n  // memory leak. The most sensible bound is to just allow a single subscription per message type.\n  // Therefore, we must have singleton observables rather than returning new instances from method\n  // calls.\n  _diagnostics: Observable<FlowStatusOutput>;\n  _recheckBookends: Observable<RecheckBookend>;\n\n  constructor(process: child_process$ChildProcess) {\n    this._disposables = new UniversalDisposable();\n    this._ideProcess = process;\n    this._ideProcess.stderr.pipe(\n      through(msg => {\n        getLogger('nuclide-flow-rpc').info(\n          'Flow IDE process stderr: ',\n          msg.toString(),\n        );\n      }),\n    );\n    this._connection = rpc.createMessageConnection(\n      new rpc.StreamMessageReader(this._ideProcess.stdout),\n      new rpc.StreamMessageWriter(this._ideProcess.stdin),\n    );\n    this._connection.listen();\n\n    this._ideProcess.on('exit', () => this.dispose());\n    this._ideProcess.on('close', () => this.dispose());\n\n    this._diagnostics = Observable.fromEventPattern(\n      handler => {\n        this._connection.onNotification(\n          NOTIFICATION_METHOD_NAME,\n          (errors: FlowStatusOutput) => {\n            handler(errors);\n          },\n        );\n      },\n      // no-op: vscode-jsonrpc offers no way to unsubscribe\n      () => {},\n    ).publishReplay(1);\n    this._disposables.add(this._diagnostics.connect());\n\n    this._recheckBookends = Observable.fromEventPattern(\n      handler => {\n        this._connection.onNotification('startRecheck', () => {\n          handler({kind: 'start-recheck'});\n        });\n        this._connection.onNotification('endRecheck', () => {\n          handler({kind: 'end-recheck'});\n        });\n      },\n      // no-op\n      () => {},\n    ).publish();\n    this._disposables.add(this._recheckBookends.connect());\n\n    this._disposables.add(() => {\n      this._ideProcess.stdin.end();\n      this._ideProcess.kill();\n\n      this._connection.dispose();\n    });\n  }\n\n  dispose(): void {\n    this._disposables.dispose();\n  }\n\n  onWillDispose(callback: () => mixed): IDisposable {\n    this._disposables.add(callback);\n    return new Disposable(() => {\n      this._disposables.remove(callback);\n    });\n  }\n\n  observeDiagnostics(): Observable<PushDiagnosticsMessage> {\n    const subscribe = () => {\n      this._connection.sendNotification(SUBSCRIBE_METHOD_NAME);\n    };\n\n    const retrySubscription = Observable.interval(SUBSCRIBE_RETRY_INTERVAL)\n      .take(SUBSCRIBE_RETRIES)\n      .takeUntil(this._diagnostics)\n      .subscribe(() => {\n        getLogger('nuclide-flow-rpc').error(\n          'Did not receive diagnostics after subscribe request -- retrying...',\n        );\n        track('nuclide-flow.missing-push-diagnostics');\n        subscribe();\n      });\n\n    subscribe();\n    return Observable.using(\n      () => retrySubscription,\n      () => {\n        return Observable.merge(\n          this._diagnostics.map(errors => ({kind: 'errors', errors})),\n          this._recheckBookends,\n        );\n      },\n    );\n  }\n\n  // Flow will not send these messages unless we have subscribed to diagnostics. So, this observable\n  // will never emit any items unless observeDiagnostics() is called.\n  observeRecheckBookends(): Observable<RecheckBookend> {\n    return this._recheckBookends;\n  }\n\n  getAutocompleteSuggestions(\n    filePath: NuclideUri,\n    line: number,\n    column: number,\n    contents: string,\n  ): Promise<FlowAutocompleteOutput> {\n    return this._connection.sendRequest(\n      'autocomplete',\n      filePath,\n      line,\n      column,\n      contents,\n    );\n  }\n}\n"]}