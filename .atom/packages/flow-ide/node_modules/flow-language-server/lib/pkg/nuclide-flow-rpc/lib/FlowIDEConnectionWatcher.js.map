{"version":3,"sources":["../../../../src/pkg/nuclide-flow-rpc/lib/FlowIDEConnectionWatcher.js"],"names":["defaultIDEConnectionFactory","proc","IDE_CONNECTION_MAX_WAIT_MS","IDE_CONNECTION_MIN_INTERVAL_MS","IDE_CONNECTION_HEALTHY_THRESHOLD_MS","MAX_UNHEALTHY_CONNECTIONS","FlowIDEConnectionWatcher","constructor","processFactory","ideConnectionCallback","ideConnectionFactory","_processFactory","_ideConnectionFactory","_ideConnectionCallback","_currentIDEConnection","_currentIDEConnectionSubscription","_consecutiveUnhealthyConnections","_isDisposed","_isStarted","start","_makeIDEConnection","Promise","resolve","info","endTimeMS","_getTimeMS","attemptStartTime","processStream","publish","processPromise","take","toPromise","connect","kill","attemptEndTime","attemptWallTime","additionalWaitTime","_sleep","error","connectionStartTime","ideConnection","onWillDispose","connectionAliveTime","Date","now","ms","dispose"],"mappings":"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","file":"FlowIDEConnectionWatcher.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport {FlowIDEConnection} from './FlowIDEConnection';\n\nimport {sleep} from 'nuclide-commons/promise';\nimport {getLogger} from 'log4js';\nimport {Observable} from 'rxjs';\n\nconst defaultIDEConnectionFactory = proc => new FlowIDEConnection(proc);\n\n// ESLint thinks the comment at the end is whitespace and warns. Worse, the autofix removes the\n// entire comment as well as the whitespace.\n// eslint-disable-next-line semi-spacing\nconst IDE_CONNECTION_MAX_WAIT_MS =\n  20 /* min */ * 60 /* s/min */ * 1000;\n\nconst IDE_CONNECTION_MIN_INTERVAL_MS = 1000;\n\n// If a connection lives shorter than this, it is considered unhealthy (it probably crashed\n// immediately for whatever reason)\nconst IDE_CONNECTION_HEALTHY_THRESHOLD_MS = 10 * 1000;\n\n// If we get this many unhealthy connections in a row, give up.\nconst MAX_UNHEALTHY_CONNECTIONS = 20;\n\ntype IdeConnectionFactory = child_process$ChildProcess => FlowIDEConnection;\n\n// For the lifetime of this class instance, keep a FlowIDEConnection alive, assuming we do not have\n// too many failures in a row.\nexport class FlowIDEConnectionWatcher {\n  _processFactory: Observable<?child_process$ChildProcess>;\n  _ideConnectionCallback: (?FlowIDEConnection) => mixed;\n  _ideConnectionFactory: child_process$ChildProcess => FlowIDEConnection;\n\n  _currentIDEConnection: ?FlowIDEConnection;\n  _currentIDEConnectionSubscription: ?IDisposable;\n  _consecutiveUnhealthyConnections: number;\n\n  _isStarted: boolean;\n  _isDisposed: boolean;\n\n  constructor(\n    processFactory: Observable<?child_process$ChildProcess>,\n    ideConnectionCallback: (?FlowIDEConnection) => mixed,\n    // Can be injected for testing purposes\n    ideConnectionFactory: IdeConnectionFactory = defaultIDEConnectionFactory,\n  ) {\n    this._processFactory = processFactory;\n    this._ideConnectionFactory = ideConnectionFactory;\n    this._ideConnectionCallback = ideConnectionCallback;\n\n    this._currentIDEConnection = null;\n    this._currentIDEConnectionSubscription = null;\n    this._consecutiveUnhealthyConnections = 0;\n\n    this._isDisposed = false;\n    this._isStarted = false;\n  }\n\n  // Returns a promise which resolves when the first connection has been established, or we give up.\n  start(): Promise<void> {\n    if (!this._isStarted) {\n      this._isStarted = true;\n      return this._makeIDEConnection();\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  async _makeIDEConnection(): Promise<void> {\n    getLogger('nuclide-flow-rpc').info('Attempting to start IDE connection...');\n    let proc = null;\n    const endTimeMS = this._getTimeMS() + IDE_CONNECTION_MAX_WAIT_MS;\n    while (true) {\n      const attemptStartTime = this._getTimeMS();\n\n      // Start the process. Eventually we should cancel by unsubscribing, but for now we'll just\n      // convert to an uncancelable promise. We need to use `connect()` because otherwise, `take(1)`\n      // would complete the stream and kill the process as soon as we got it.\n      const processStream = this._processFactory.publish();\n      const processPromise = processStream.take(1).toPromise();\n      processStream.connect();\n\n      // eslint-disable-next-line no-await-in-loop\n      proc = await processPromise;\n      // dispose() could have been called while we were waiting for the above promise to resolve.\n      if (this._isDisposed) {\n        if (proc != null) {\n          proc.kill();\n        }\n        return;\n      }\n      const attemptEndTime = this._getTimeMS();\n      if (proc != null || attemptEndTime > endTimeMS) {\n        break;\n      } else {\n        getLogger('nuclide-flow-rpc').info(\n          'Failed to start Flow IDE connection... retrying',\n        );\n        const attemptWallTime = attemptEndTime - attemptStartTime;\n        const additionalWaitTime =\n          IDE_CONNECTION_MIN_INTERVAL_MS - attemptWallTime;\n        if (additionalWaitTime > 0) {\n          getLogger('nuclide-flow-rpc').info(\n            `Waiting an additional ${additionalWaitTime} ms before retrying`,\n          );\n          // eslint-disable-next-line no-await-in-loop\n          await this._sleep(additionalWaitTime);\n        }\n      }\n    }\n    if (proc == null) {\n      getLogger('nuclide-flow-rpc').error(\n        'Failed to start Flow IDE connection too many times... giving up',\n      );\n      return;\n    }\n    const connectionStartTime = this._getTimeMS();\n    const ideConnection = this._ideConnectionFactory(proc);\n    this._ideConnectionCallback(ideConnection);\n    this._currentIDEConnectionSubscription = ideConnection.onWillDispose(() => {\n      this._ideConnectionCallback(null);\n      const connectionAliveTime = this._getTimeMS() - connectionStartTime;\n      if (connectionAliveTime < IDE_CONNECTION_HEALTHY_THRESHOLD_MS) {\n        this._consecutiveUnhealthyConnections++;\n        if (\n          this._consecutiveUnhealthyConnections >= MAX_UNHEALTHY_CONNECTIONS\n        ) {\n          getLogger('nuclide-flow-rpc').error(\n            'Too many consecutive unhealthy Flow IDE connections... giving up',\n          );\n          return;\n        }\n      } else {\n        this._consecutiveUnhealthyConnections = 0;\n      }\n      this._makeIDEConnection();\n    });\n\n    this._currentIDEConnection = ideConnection;\n  }\n\n  // Split this out just so it's easy to mock\n  _getTimeMS(): number {\n    return Date.now();\n  }\n\n  // Split this out just so it's easy to mock\n  _sleep(ms: number): Promise<void> {\n    return sleep(ms);\n  }\n\n  dispose(): void {\n    if (!this._isDisposed) {\n      this._isDisposed = true;\n      if (this._currentIDEConnectionSubscription != null) {\n        this._currentIDEConnectionSubscription.dispose();\n      }\n      if (this._currentIDEConnection != null) {\n        this._currentIDEConnection.dispose();\n      }\n    }\n  }\n}\n"]}