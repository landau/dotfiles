{"version":3,"sources":["../../../../src/pkg/nuclide-flow-rpc/lib/FlowProcess.js"],"names":["args","root","execInfoContainer","options","execInfo","getFlowExecInfo","execOptions","pathToFlow","getAllExecInfo","logger","FLOW_RETURN_CODES","ok","serverInitializing","typeError","noServerRunning","outOfRetries","buildIdMismatch","unexpectedArgument","SERVER_READY_TIMEOUT_MS","EXEC_FLOW_RETRIES","NO_RETRY_ARGS","TEMP_SERVER_STATES","NOT_RUNNING","BUSY","INIT","FlowProcess","constructor","_subscriptions","_execInfoContainer","_serverStatus","UNKNOWN","_root","_isDisposed","_optionalIDEConnections","_ideConnections","_createIDEConnectionStream","subscribe","status","info","filter","x","_startFlowServer","scan","previousState","nextState","shouldStartPinging","includes","_pingServer","FAILED","dispose","complete","next","_startedServer","kill","allowServerRestart","getValue","getServerStatusUpdates","asObservable","getIDEConnections","getCurrentIDEConnection","add","conn","switchMap","observeRecheckBookends","bookend","kind","_setServerStatus","READY","isFailed","map","distinctUntilChanged","shouldStart","failed","mapTo","undefined","_createSingleIDEConnectionStream","takeUntil","concat","of","do","publishReplay","refCount","connectionWatcher","fromEventPattern","handler","_tryCreateIDEProcess","start","defer","_serverIsReady","serverIsReady","allExecInfo","proc","once","code","signal","_updateServerStatus","execFlow","waitForServer","suppressErrors","maxRetries","i","result","_rawExecFlow","e","couldRetry","indexOf","error","join","JSON","stringify","flowExecInfo","reallyGetFlowExecInfo","NOT_INSTALLED","lazy","push","serverProcess","_getMaxWorkers","toString","logIt","pid","debug","data","stdout","on","stderr","args_","execFlowClient","exitCode","String","currentStatus","hasReachedSteadyState","state","take","_pingServerOnce","catch","then","race","delay","first","toPromise","Math","max","cpus","length"],"mappings":"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","file":"FlowProcess.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport type {ServerStatusType} from '..';\n\nimport type {FlowExecInfoContainer} from './FlowExecInfoContainer';\n\nimport os from 'os';\nimport invariant from 'assert';\nimport {BehaviorSubject, Observable} from 'rxjs';\n\nimport {getLogger} from 'log4js';\nconst logger = getLogger('nuclide-flow-rpc');\n\nimport {track} from '../../nuclide-analytics';\n\nimport {runCommandDetailed, spawn} from 'nuclide-commons/process';\nimport {sleep} from 'nuclide-commons/promise';\nimport {niceSafeSpawn} from 'nuclide-commons/nice';\nimport UniversalDisposable from 'nuclide-commons/UniversalDisposable';\n\nimport {getStopFlowOnExit} from './FlowHelpers';\nimport {getConfig} from './config';\nimport {ServerStatus} from './FlowConstants';\nimport {FlowIDEConnection} from './FlowIDEConnection';\nimport {FlowIDEConnectionWatcher} from './FlowIDEConnectionWatcher';\n\ntype FlowExecResult = {\n  stdout: string,\n  stderr: string,\n  exitCode: ?number,\n};\n\n// Names modeled after https://github.com/facebook/flow/blob/master/src/common/flowExitStatus.ml\nexport const FLOW_RETURN_CODES = {\n  ok: 0,\n  serverInitializing: 1,\n  typeError: 2,\n  noServerRunning: 6,\n  // This means that the server exists, but it is not responding, typically because it is busy doing\n  // other work.\n  outOfRetries: 7,\n  buildIdMismatch: 9,\n  unexpectedArgument: 64,\n};\n\nconst SERVER_READY_TIMEOUT_MS = 60 * 1000;\n\nconst EXEC_FLOW_RETRIES = 5;\n\nconst NO_RETRY_ARGS = [\n  '--retry-if-init',\n  'false',\n  '--retries',\n  '0',\n  '--no-auto-start',\n];\n\nconst TEMP_SERVER_STATES: Array<ServerStatusType> = [\n  ServerStatus.NOT_RUNNING,\n  ServerStatus.BUSY,\n  ServerStatus.INIT,\n];\n\nexport class FlowProcess {\n  // If we had to start a Flow server, store the process here so we can kill it when we shut down.\n  _startedServer: ?child_process$ChildProcess;\n  // The current state of the Flow server in this directory\n  _serverStatus: BehaviorSubject<ServerStatusType>;\n  // The path to the directory where the .flowconfig is -- i.e. the root of the Flow project.\n  _root: string;\n  _execInfoContainer: FlowExecInfoContainer;\n\n  _ideConnections: Observable<?FlowIDEConnection>;\n\n  // If someone subscribes to _ideConnections, we will also publish them here. But subscribing to\n  // this does not actually cause a connection to be created or maintained.\n  _optionalIDEConnections: BehaviorSubject<?FlowIDEConnection>;\n\n  _isDisposed: BehaviorSubject<boolean>;\n  _subscriptions: UniversalDisposable;\n\n  constructor(root: string, execInfoContainer: FlowExecInfoContainer) {\n    this._subscriptions = new UniversalDisposable();\n    this._execInfoContainer = execInfoContainer;\n    this._serverStatus = new BehaviorSubject(ServerStatus.UNKNOWN);\n    this._root = root;\n    this._isDisposed = new BehaviorSubject(false);\n\n    this._optionalIDEConnections = new BehaviorSubject(null);\n    this._ideConnections = this._createIDEConnectionStream();\n\n    this._serverStatus.subscribe(status => {\n      logger.info(`[${status}]: Flow server in ${this._root}`);\n    });\n\n    this._serverStatus\n      .filter(x => x === ServerStatus.NOT_RUNNING)\n      .subscribe(() => {\n        this._startFlowServer();\n      });\n\n    this._serverStatus\n      .scan(\n        ({previousState}, nextState) => {\n          // We should start pinging if we move into a temp state\n          const shouldStartPinging =\n            !TEMP_SERVER_STATES.includes(previousState) &&\n            TEMP_SERVER_STATES.includes(nextState);\n          return {\n            shouldStartPinging,\n            previousState: nextState,\n          };\n        },\n        {shouldStartPinging: false, previousState: ServerStatus.UNKNOWN},\n      )\n      .filter(({shouldStartPinging}) => shouldStartPinging)\n      .subscribe(() => {\n        this._pingServer();\n      });\n\n    this._serverStatus\n      .filter(status => status === ServerStatus.FAILED)\n      .subscribe(() => {\n        track('flow-server-failed');\n      });\n  }\n\n  dispose(): void {\n    this._serverStatus.complete();\n    this._isDisposed.next(true);\n    if (this._startedServer && getStopFlowOnExit()) {\n      // The default, SIGTERM, does not reliably kill the flow servers.\n      this._startedServer.kill('SIGKILL');\n    }\n    this._subscriptions.dispose();\n  }\n\n  /**\n   * If the Flow server fails we will not try to restart it again automatically. Calling this\n   * method lets us exit that state and retry.\n   */\n  allowServerRestart(): void {\n    if (this._serverStatus.getValue() === ServerStatus.FAILED) {\n      // We intentionally do not use _setServerStatus because leaving the FAILED state is a\n      // special-case that _setServerStatus does not allow.\n      this._serverStatus.next(ServerStatus.UNKNOWN);\n    }\n  }\n\n  getServerStatusUpdates(): Observable<ServerStatusType> {\n    return this._serverStatus.asObservable();\n  }\n\n  // It is possible for an IDE connection to die. If there are subscribers to this Observable, it\n  // will be automatically restarted and the new one will be sent.\n  //\n  // If the connection dies, `null` will be sent while the next one is being established.\n  getIDEConnections(): Observable<?FlowIDEConnection> {\n    return this._ideConnections;\n  }\n\n  // This will not cause an IDE connection to be established or maintained, and the return value is\n  // not safe to store. If there happens to be an IDE connection it will be returned.\n  getCurrentIDEConnection(): ?FlowIDEConnection {\n    return this._optionalIDEConnections.getValue();\n  }\n\n  _createIDEConnectionStream(): Observable<?FlowIDEConnection> {\n    this._subscriptions.add(\n      this._optionalIDEConnections\n        .filter(conn => conn != null)\n        .switchMap(conn => {\n          invariant(conn != null);\n          return conn.observeRecheckBookends();\n        })\n        .subscribe(bookend => {\n          if (bookend.kind === 'start-recheck') {\n            this._setServerStatus(ServerStatus.BUSY);\n          } else {\n            this._setServerStatus(ServerStatus.READY);\n          }\n        }),\n    );\n\n    const isFailed: Observable<boolean> = this._serverStatus\n      .map(x => x === ServerStatus.FAILED)\n      .distinctUntilChanged();\n    // When we move from failed to non-failed that means we have been explicitly asked to retry\n    // after a Flow server crash. Odds are good that the IDE connection has timed out or is\n    // otherwise unhealthy. So, when we transition from failed to non-failed we should also start\n    // all IDE connection logic anew.\n    const shouldStart: Observable<void> = isFailed\n      .filter(failed => !failed)\n      .mapTo(undefined);\n    return (\n      shouldStart\n        .switchMap(() => this._createSingleIDEConnectionStream())\n        .takeUntil(this._isDisposed.filter(x => x))\n        .concat(Observable.of(null))\n        // This is so we can passively observe IDE connections if somebody happens to be using one. We\n        // want to use it to more quickly update the Flow server status, but it's not crucial to\n        // correctness so we only want to do this if somebody is using the IDE connections anyway.\n        // Don't pass the Subject as an Observer since then it will complete if a client unsubscribes.\n        .do(\n          conn => this._optionalIDEConnections.next(conn),\n          () => {\n            // If we get an error, set the current ide connection to null\n            this._optionalIDEConnections.next(null);\n          },\n          () => {\n            // If we get a completion (happens when the downstream client unsubscribes), set the current ide connection to null.\n            this._optionalIDEConnections.next(null);\n          },\n        )\n        // multicast and store the current connection and immediately deliver it to new subscribers\n        .publishReplay(1)\n        .refCount()\n    );\n  }\n\n  _createSingleIDEConnectionStream(): Observable<?FlowIDEConnection> {\n    logger.info('Creating Flow IDE connection stream');\n    let connectionWatcher: ?FlowIDEConnectionWatcher = null;\n    return Observable.fromEventPattern(\n      // Called when the observable is subscribed to\n      handler => {\n        logger.info('Got a subscriber for the Flow IDE connection stream');\n        invariant(connectionWatcher == null);\n        connectionWatcher = new FlowIDEConnectionWatcher(\n          this._tryCreateIDEProcess(),\n          handler,\n        );\n        connectionWatcher.start();\n      },\n      // Called when the observable is unsubscribed from\n      () => {\n        logger.info(\n          'No more IDE connection stream subscribers -- shutting down connection watcher',\n        );\n        invariant(connectionWatcher != null);\n        connectionWatcher.dispose();\n        connectionWatcher = null;\n      },\n    );\n  }\n\n  _tryCreateIDEProcess(): Observable<?child_process$ChildProcess> {\n    return Observable.defer(() => this._serverIsReady())\n      .switchMap(serverIsReady => {\n        if (!serverIsReady) {\n          return Observable.of(null);\n        }\n        return getAllExecInfo(\n          ['ide', '--protocol', 'very-unstable', ...NO_RETRY_ARGS],\n          this._root,\n          this._execInfoContainer,\n        );\n      })\n      .switchMap(allExecInfo => {\n        if (allExecInfo == null) {\n          return Observable.of(null);\n        }\n\n        return spawn(\n          allExecInfo.pathToFlow,\n          allExecInfo.args,\n          allExecInfo.options,\n        ).do(proc => {\n          proc.once('exit', (code: ?number, signal: ?string) => {\n            // If it crashes we will get `null` or `undefined`, but that doesn't actually mean\n            // that Flow is not installed.\n            if (code != null) {\n              this._updateServerStatus(code);\n            }\n          });\n        });\n      });\n  }\n\n  /**\n   * Returns null if Flow cannot be found.\n   */\n  async execFlow(\n    args: Array<any>,\n    options: Object,\n    waitForServer?: boolean = false,\n    suppressErrors?: boolean = false,\n  ): Promise<?FlowExecResult> {\n    const maxRetries = waitForServer ? EXEC_FLOW_RETRIES : 0;\n    if (this._serverStatus.getValue() === ServerStatus.FAILED) {\n      return null;\n    }\n    for (let i = 0; ; i++) {\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        const result = await this._rawExecFlow(args, options);\n        return result;\n      } catch (e) {\n        const couldRetry =\n          [\n            ServerStatus.NOT_RUNNING,\n            ServerStatus.INIT,\n            ServerStatus.BUSY,\n          ].indexOf(this._serverStatus.getValue()) !== -1;\n        if (i < maxRetries && couldRetry) {\n          // eslint-disable-next-line no-await-in-loop\n          await this._serverIsReady();\n          // Then try again.\n        } else {\n          // If it couldn't retry, it means there was a legitimate error. If it could retry, we\n          // don't want to log because it just means the server is busy and we don't want to wait.\n          if (!couldRetry && !suppressErrors) {\n            // not sure what happened, but we'll let the caller deal with it\n            logger.error(\n              `Flow failed: flow ${args.join(' ')}. Error: ${JSON.stringify(\n                e,\n              )}`,\n            );\n          }\n          throw e;\n        }\n        // try again\n      }\n    }\n  }\n\n  /** Starts a Flow server in the current root */\n  async _startFlowServer(): Promise<void> {\n    // If the server is restarting because of a change in the version specified in the .flowconfig,\n    // then it's important not to use a stale path to start it, since we could have cached the path\n    // to a different version. In that case, starting the server will fail.\n    const flowExecInfo = await this._execInfoContainer.reallyGetFlowExecInfo(\n      this._root,\n    );\n    if (flowExecInfo == null) {\n      // This should not happen in normal use. If Flow is not installed we should have caught it by\n      // now.\n      logger.error(`Could not find Flow to start server in ${this._root}`);\n      this._setServerStatus(ServerStatus.NOT_INSTALLED);\n      return;\n    }\n    const lazy = [];\n    if (getConfig('lazyServer')) {\n      lazy.push('--lazy');\n    }\n    // `flow server` will start a server in the foreground. runCommand/runCommandDetailed\n    // will not resolve the promise until the process exits, which in this\n    // case is never. We need to use spawn directly to get access to the\n    // ChildProcess object.\n    // eslint-disable-next-line no-await-in-loop\n    const serverProcess = await niceSafeSpawn(\n      flowExecInfo.pathToFlow,\n      [\n        'server',\n        ...lazy,\n        '--from',\n        'nuclide',\n        '--max-workers',\n        this._getMaxWorkers().toString(),\n        this._root,\n      ],\n      flowExecInfo.execOptions,\n    );\n    const logIt = data => {\n      const pid = serverProcess.pid;\n      logger.debug(`flow server (${pid}): ${data}`);\n    };\n    serverProcess.stdout.on('data', logIt);\n    serverProcess.stderr.on('data', logIt);\n    serverProcess.on('exit', (code, signal) => {\n      // We only want to blacklist this root if the Flow processes\n      // actually failed, rather than being killed manually. It seems that\n      // if they are killed, the code is null and the signal is 'SIGTERM'.\n      // In the Flow crashes I have observed, the code is 2 and the signal\n      // is null. So, let's blacklist conservatively for now and we can\n      // add cases later if we observe Flow crashes that do not fit this\n      // pattern.\n      if (code === 2 && signal === null) {\n        logger.error('Flow server unexpectedly exited', this._root);\n        this._setServerStatus(ServerStatus.FAILED);\n      }\n    });\n    this._startedServer = serverProcess;\n  }\n\n  /** Execute Flow with the given arguments */\n  async _rawExecFlow(\n    args_: Array<any>,\n    options?: Object = {},\n  ): Promise<?FlowExecResult> {\n    let args = args_;\n    args = [...args, ...NO_RETRY_ARGS];\n    try {\n      const result = await FlowProcess.execFlowClient(\n        args,\n        this._root,\n        this._execInfoContainer,\n        options,\n      );\n      this._updateServerStatus(result != null ? result.exitCode : null);\n      return result;\n    } catch (e) {\n      this._updateServerStatus(e != null ? e.exitCode : null);\n      if (e.exitCode === FLOW_RETURN_CODES.typeError) {\n        return e;\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  _updateServerStatus(exitCode: ?number): void {\n    let status;\n    if (exitCode == null) {\n      status = ServerStatus.NOT_INSTALLED;\n    } else {\n      switch (exitCode) {\n        case FLOW_RETURN_CODES.ok:\n        // falls through\n        case FLOW_RETURN_CODES.typeError:\n          status = ServerStatus.READY;\n          break;\n        case FLOW_RETURN_CODES.serverInitializing:\n          status = ServerStatus.INIT;\n          break;\n        case FLOW_RETURN_CODES.noServerRunning:\n          status = ServerStatus.NOT_RUNNING;\n          break;\n        case FLOW_RETURN_CODES.outOfRetries:\n          status = ServerStatus.BUSY;\n          break;\n        case FLOW_RETURN_CODES.buildIdMismatch:\n          // If the version doesn't match, the server is automatically killed and the client\n          // returns 9.\n          logger.info(\n            'Killed flow server with incorrect version in',\n            this._root,\n          );\n          status = ServerStatus.NOT_RUNNING;\n          break;\n        case FLOW_RETURN_CODES.unexpectedArgument:\n          // If we issued an unexpected argument we have learned nothing about the state of the Flow\n          // server. So, don't update.\n          return;\n        default:\n          logger.error(`Unknown return code from Flow: ${String(exitCode)}`);\n          status = ServerStatus.UNKNOWN;\n      }\n    }\n    this._setServerStatus(status);\n  }\n\n  _setServerStatus(status: ServerStatusType): void {\n    const currentStatus = this._serverStatus.getValue();\n    if (\n      // Avoid duplicate updates\n      status !== currentStatus &&\n      // Avoid moving the status away from FAILED, to let any existing  work die out when the\n      // server fails.\n      currentStatus !== ServerStatus.FAILED\n    ) {\n      this._serverStatus.next(status);\n    }\n    if (this._isDisposed.getValue()) {\n      logger.error('Attempted to update server status after disposal');\n    }\n  }\n\n  /** Ping the server until it reaches a steady state */\n  async _pingServer(): Promise<void> {\n    let hasReachedSteadyState = false;\n    this._serverStatus\n      .filter(state => !TEMP_SERVER_STATES.includes(state))\n      .take(1)\n      .subscribe(() => {\n        hasReachedSteadyState = true;\n      });\n    while (!hasReachedSteadyState && !this._isDisposed.getValue()) {\n      // eslint-disable-next-line no-await-in-loop\n      await this._pingServerOnce();\n      // Wait 1 second\n      // eslint-disable-next-line no-await-in-loop\n      await sleep(1000);\n    }\n  }\n\n  _pingServerOnce(): Promise<void> {\n    return this._rawExecFlow(['status']).catch(() => {}).then(() => {});\n  }\n\n  /**\n   * Resolves when the server is ready or the request times out, as indicated by the result of the\n   * returned Promise.\n   */\n  _serverIsReady(): Promise<boolean> {\n    // If the server state is unknown, nobody has tried to do anything flow-related yet. However,\n    // the call to _serverIsReady() implies that somebody wants to. So, kick off a Flow server ping\n    // which will learn the state of the Flow server and start it up if needed.\n    if (this._serverStatus.getValue() === ServerStatus.UNKNOWN) {\n      this._pingServerOnce();\n    }\n    return (\n      this._serverStatus\n        .filter(x => x === ServerStatus.READY)\n        .map(() => true)\n        .race(Observable.of(false).delay(SERVER_READY_TIMEOUT_MS))\n        // If the stream is completed timeout will not return its default value and we will see an\n        // EmptyError. So, provide a defaultValue here so the promise resolves.\n        .first(null, null, false)\n        .toPromise()\n    );\n  }\n\n  _getMaxWorkers(): number {\n    return Math.max(os.cpus().length - 2, 1);\n  }\n\n  /**\n   * This should be used to execute Flow commands that do not rely on a Flow server. So, they do not\n   * need to be associated with a FlowProcess instance and they may be executed from any working\n   * directory.\n   *\n   * Note that using this method means that you get no guarantee that the Flow version specified in\n   * any given .flowconfig is the one that will be executed here, because it has no association with\n   * any given root. If you need this property, create an instance with the appropriate root and use\n   * execFlow.\n   */\n  static async execFlowClient(\n    args: Array<any>,\n    root: string | null,\n    execInfoContainer: FlowExecInfoContainer,\n    options: Object = {},\n  ): Promise<?FlowExecResult> {\n    const allExecInfo = await getAllExecInfo(\n      args,\n      root,\n      execInfoContainer,\n      options,\n    );\n    if (allExecInfo == null) {\n      return null;\n    }\n\n    // TODO: bubble up the exit code via return value instead of the error\n    return runCommandDetailed(\n      allExecInfo.pathToFlow,\n      allExecInfo.args,\n      allExecInfo.options,\n    ).toPromise();\n  }\n}\n\ntype AllExecInfo = {\n  args: Array<any>,\n  options: Object,\n  pathToFlow: string,\n};\n\nasync function getAllExecInfo(\n  args: Array<any>,\n  root: string | null,\n  execInfoContainer: FlowExecInfoContainer,\n  options: Object = {},\n): Promise<?AllExecInfo> {\n  const execInfo = await execInfoContainer.getFlowExecInfo(root);\n  if (execInfo == null) {\n    return null;\n  }\n  return {\n    args: [...args, '--from', 'nuclide'],\n    options: {\n      ...execInfo.execOptions,\n      ...options,\n    },\n    pathToFlow: execInfo.pathToFlow,\n  };\n}\n"]}