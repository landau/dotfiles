{"version":3,"sources":["../../../../src/pkg/nuclide-flow-rpc/lib/FlowService.js"],"names":["fileNotifier","host","config","fileCache","FlowLanguageService","initialize","dispose","flowGetAst","state","getState","constructor","logger","projectDir","execInfoContainer","getExecInfoContainer","singleProjectLS","languageService","Promise","resolve","Object","keys","key","getOutline","fileVersion","ls","getLanguageServiceForFile","filePath","buffer","getServerStatusUpdates","observeLanguageServices","mergeMap","getSingleFileLanguageService","pathToRoot","getPathToRoot","map","status","publish","allowServerRestart","languageServices","getAllLanguageServices","flowLanguageServices","forEach","file","currentContents"],"mappings":";;;;;;;;;;;;6CA+FO,WACLA,YADK,EAELC,IAFK,EAGLC,MAHK,EAI6B;AAClC,0BAAUF,sDAAV;AACA,UAAMG,YAAuBH,YAA7B;AACA,WAAO,IAAII,mBAAJ,CAAwBD,SAAxB,EAAmCF,IAAnC,EAAyCC,MAAzC,CAAP;AACD,G;;kBARqBG,U;;;;;QAPNC,O,GAAAA,O;QAkKAC,U,GAAAA,U;;AAtNhB;;;;AAEA;;AACA;;AAIA;;AAEA;;AA+BA;;AACA;;;;AAzBA;AACA;AA0BA,IAAIC,QAA2B,IAA/B,C,CA/EA;;;;;;;;;;;;AAiFA,SAASC,QAAT,GAAsC;AACpC,MAAID,SAAS,IAAb,EAAmB;AACjBA,YAAQ,wCAAR;AACD;AACD,SAAOA,KAAP;AACD;;AAEM,SAASF,OAAT,GAAyB;AAC9B,MAAIE,SAAS,IAAb,EAAmB;AACjBA,UAAMF,OAAN;AACAE,YAAQ,IAAR;AACD;AACF;;AAYD,MAAMJ,mBAAN,gEAEE;AACAM,cAAYP,SAAZ,EAAkCF,IAAlC,EAAsDC,MAAtD,EAA4E;AAC1E,UAAMS,SAAS,uBAAU,MAAV,CAAf;AACA;AACA,SAAKN,UAAL,CACEM,MADF,EAEER,SAFF,EAGEF,IAHF,EAIE,aAJF,EAKE,CAAC,KAAD,EAAQ,MAAR,CALF,EAMEW,cAAc;AACZ,YAAMC,oBAAoBJ,WAAWK,oBAAX,EAA1B;AACA,YAAMC,kBAAkB,uEACtBH,UADsB,EAEtBC,iBAFsB,CAAxB;AAIA,YAAMG,kBAAkB,qDACtBb,SADsB,EAEtBY,eAFsB,CAAxB;AAIA,aAAOE,QAAQC,OAAR,CAAgBF,eAAhB,CAAP;AACD,KAjBH;AAH0E;AAAA;AAAA;;AAAA;AAsB1E,2BAAkBG,OAAOC,IAAP,CAAYlB,MAAZ,CAAlB,8HAAuC;AAAA,cAA5BmB,GAA4B;;AACrC,+BAAUA,GAAV,EAAenB,OAAOmB,GAAP,CAAf;AACD;AAxByE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyB3E;;AAEKC,YAAN,CAAiBC,WAAjB,EAA8D;AAAA;;AAAA;AAC5D,YAAMC,KAAK,MAAM,MAAKC,yBAAL,CAA+BF,YAAYG,QAA3C,CAAjB;AACA,UAAIF,MAAM,IAAV,EAAgB;AACd,eAAOA,GAAGF,UAAH,CAAcC,WAAd,CAAP;AACD,OAFD,MAEO;AACL,cAAMI,SAAS,MAAM,6CAAmBJ,WAAnB,CAArB;AACA,YAAII,UAAU,IAAd,EAAoB;AAClB,iBAAO,IAAP;AACD;AACD,eAAO,mEAAiCL,UAAjC,CACLC,YAAYG,QADP,EAELC,MAFK,EAGL,IAHK,EAILlB,WAAWK,oBAAX,EAJK,CAAP;AAMD;AAf2D;AAgB7D;;AAEDc,2BAAoE;AAClE,WAAO,KAAKC,uBAAL,GACJC,QADI,CACKd,mBAAmB;AAC3B,YAAMD,kBAAoDC,gBAAgBe,4BAAhB,EAA1D;AACA,YAAMC,aAAajB,gBAAgBkB,aAAhB,EAAnB;AACA,aAAOlB,gBACJa,sBADI,GAEJM,GAFI,CAEAC,WAAW,EAACH,UAAD,EAAaG,MAAb,EAAX,CAFA,CAAP;AAGD,KAPI,EAQJC,OARI,EAAP;AASD;;AAEKC,oBAAN,GAA0C;AAAA;;AAAA;AACxC,YAAMC,mBAAmB,MAAM,OAAKC,sBAAL,EAA/B;AACA,YAAMC,uBAAuBF,iBAAiBJ,GAAjB,CAAqB;AAAA,eAChDV,GAAGO,4BAAH,EADgD;AAAA,OAArB,CAA7B;AAGAS,2BAAqBC,OAArB,CAA6B;AAAA,eAAMjB,GAAGa,kBAAH,EAAN;AAAA,OAA7B;AALwC;AAMzC;AAhED;;AAmEF;AA4EO,SAAS9B,UAAT,CACLmC,IADK,EAELC,eAFK,EAGU;AACf,SAAO,mEAAiCpC,UAAjC,CACL,IADK,EAELoC,eAFK,EAGLlC,WAAWK,oBAAX,EAHK,CAAP;AAKD","file":"FlowService.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport type {ConnectableObservable} from 'rxjs';\n\nimport type {NuclideUri} from 'nuclide-commons/nuclideUri';\nimport type {\n  AutocompleteResult,\n  SymbolResult,\n} from '../../nuclide-language-service/lib/LanguageService';\nimport type {HostServices} from '../../nuclide-language-service-rpc/lib/rpc-types';\nimport type {\n  FileVersion,\n  FileNotifier,\n} from '../../nuclide-open-files-rpc/lib/rpc-types';\nimport type {TextEdit} from 'nuclide-commons-atom/text-edit';\nimport type {TypeHint} from '../../nuclide-type-hint/lib/rpc-types';\nimport type {CoverageResult} from '../../nuclide-type-coverage/lib/rpc-types';\nimport type {\n  DefinitionQueryResult,\n  DiagnosticProviderUpdate,\n  FileDiagnosticMessages,\n  FindReferencesReturn,\n  Outline,\n} from 'atom-ide-ui';\nimport type {NuclideEvaluationExpression} from '../../nuclide-debugger-interfaces/rpc-types';\n\nimport invariant from 'assert';\n\nimport {setConfig} from './config';\nimport {\n  ServerLanguageService,\n  MultiProjectLanguageService,\n} from '../../nuclide-language-service-rpc';\nimport {FileCache, getBufferAtVersion} from '../../nuclide-open-files-rpc';\n\nimport {getLogger} from 'log4js';\n\nexport type Loc = {\n  file: NuclideUri,\n  point: atom$Point,\n};\n\n// If types are added here, make sure to also add them to FlowConstants.js. This needs to be the\n// canonical type definition so that we can use these in the service framework.\nexport type ServerStatusType =\n  | 'failed'\n  | 'unknown'\n  | 'not running'\n  | 'not installed'\n  | 'busy'\n  | 'init'\n  | 'ready';\n\nexport type ServerStatusUpdate = {\n  pathToRoot: NuclideUri,\n  status: ServerStatusType,\n};\n\nexport type FlowSettings = {\n  functionSnippetShouldIncludeArguments: boolean,\n  stopFlowOnExit: boolean,\n  lazyServer: boolean,\n};\n\nexport type {FlowLocNoSource} from './flowOutputTypes';\n\nimport {FlowSingleProjectLanguageService} from './FlowSingleProjectLanguageService';\nimport {FlowServiceState} from './FlowServiceState';\n\nlet state: ?FlowServiceState = null;\n\nfunction getState(): FlowServiceState {\n  if (state == null) {\n    state = new FlowServiceState();\n  }\n  return state;\n}\n\nexport function dispose(): void {\n  if (state != null) {\n    state.dispose();\n    state = null;\n  }\n}\n\nexport async function initialize(\n  fileNotifier: FileNotifier,\n  host: HostServices,\n  config: FlowSettings,\n): Promise<FlowLanguageServiceType> {\n  invariant(fileNotifier instanceof FileCache);\n  const fileCache: FileCache = fileNotifier;\n  return new FlowLanguageService(fileCache, host, config);\n}\n\nclass FlowLanguageService extends MultiProjectLanguageService<\n  ServerLanguageService<FlowSingleProjectLanguageService>,\n> {\n  constructor(fileCache: FileCache, host: HostServices, config: FlowSettings) {\n    const logger = getLogger('Flow');\n    super();\n    this.initialize(\n      logger,\n      fileCache,\n      host,\n      '.flowconfig',\n      ['.js', '.jsx'],\n      projectDir => {\n        const execInfoContainer = getState().getExecInfoContainer();\n        const singleProjectLS = new FlowSingleProjectLanguageService(\n          projectDir,\n          execInfoContainer,\n        );\n        const languageService = new ServerLanguageService(\n          fileCache,\n          singleProjectLS,\n        );\n        return Promise.resolve(languageService);\n      },\n    );\n    for (const key of Object.keys(config)) {\n      setConfig(key, config[key]);\n    }\n  }\n\n  async getOutline(fileVersion: FileVersion): Promise<?Outline> {\n    const ls = await this.getLanguageServiceForFile(fileVersion.filePath);\n    if (ls != null) {\n      return ls.getOutline(fileVersion);\n    } else {\n      const buffer = await getBufferAtVersion(fileVersion);\n      if (buffer == null) {\n        return null;\n      }\n      return FlowSingleProjectLanguageService.getOutline(\n        fileVersion.filePath,\n        buffer,\n        null,\n        getState().getExecInfoContainer(),\n      );\n    }\n  }\n\n  getServerStatusUpdates(): ConnectableObservable<ServerStatusUpdate> {\n    return this.observeLanguageServices()\n      .mergeMap(languageService => {\n        const singleProjectLS: FlowSingleProjectLanguageService = languageService.getSingleFileLanguageService();\n        const pathToRoot = singleProjectLS.getPathToRoot();\n        return singleProjectLS\n          .getServerStatusUpdates()\n          .map(status => ({pathToRoot, status}));\n      })\n      .publish();\n  }\n\n  async allowServerRestart(): Promise<void> {\n    const languageServices = await this.getAllLanguageServices();\n    const flowLanguageServices = languageServices.map(ls =>\n      ls.getSingleFileLanguageService(),\n    );\n    flowLanguageServices.forEach(ls => ls.allowServerRestart());\n  }\n}\n\n// Unfortunately we have to duplicate a lot of things here to make FlowLanguageService remotable.\nexport interface FlowLanguageServiceType {\n  getDiagnostics(fileVersion: FileVersion): Promise<?DiagnosticProviderUpdate>,\n\n  observeDiagnostics(): ConnectableObservable<Array<FileDiagnosticMessages>>,\n\n  getAutocompleteSuggestions(\n    fileVersion: FileVersion,\n    position: atom$Point,\n    activatedManually: boolean,\n    prefix: string,\n  ): Promise<?AutocompleteResult>,\n\n  getDefinition(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?DefinitionQueryResult>,\n\n  findReferences(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?FindReferencesReturn>,\n\n  getCoverage(filePath: NuclideUri): Promise<?CoverageResult>,\n\n  getOutline(fileVersion: FileVersion): Promise<?Outline>,\n\n  typeHint(fileVersion: FileVersion, position: atom$Point): Promise<?TypeHint>,\n\n  highlight(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?Array<atom$Range>>,\n\n  formatSource(\n    fileVersion: FileVersion,\n    range: atom$Range,\n  ): Promise<?Array<TextEdit>>,\n\n  formatEntireFile(\n    fileVersion: FileVersion,\n    range: atom$Range,\n  ): Promise<?{\n    newCursor?: number,\n    formatted: string,\n  }>,\n\n  formatAtPosition(\n    fileVersion: FileVersion,\n    position: atom$Point,\n    triggerCharacter: string,\n  ): Promise<?Array<TextEdit>>,\n\n  getEvaluationExpression(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?NuclideEvaluationExpression>,\n\n  supportsSymbolSearch(directories: Array<NuclideUri>): Promise<boolean>,\n\n  symbolSearch(\n    query: string,\n    directories: Array<NuclideUri>,\n  ): Promise<?Array<SymbolResult>>,\n\n  getProjectRoot(fileUri: NuclideUri): Promise<?NuclideUri>,\n\n  isFileInProject(fileUri: NuclideUri): Promise<boolean>,\n\n  getServerStatusUpdates(): ConnectableObservable<ServerStatusUpdate>,\n\n  allowServerRestart(): Promise<void>,\n\n  dispose(): void,\n}\n\nexport function flowGetAst(\n  file: ?NuclideUri,\n  currentContents: string,\n): Promise<?any> {\n  return FlowSingleProjectLanguageService.flowGetAst(\n    null,\n    currentContents,\n    getState().getExecInfoContainer(),\n  );\n}\n"]}