{"version":3,"sources":["../../../../src/pkg/nuclide-flow-rpc/lib/FlowSingleProjectLanguageService.js"],"names":["processAutocompleteItem","groupParamNames","emptyDiagnosticsState","updateDiagnostics","getDiagnosticUpdates","logger","FlowSingleProjectLanguageService","constructor","root","execInfoContainer","_root","_execInfoContainer","_process","_version","execInfo","getFlowExecInfo","flowVersion","getServerStatusUpdates","filter","state","subscribe","invalidateVersion","dispose","allowServerRestart","getPathToRoot","getProjectRoot","fileUri","Promise","resolve","getDefinition","filePath","buffer","position","match","line","row","column","options","input","getText","args","result","execFlow","json","parseJSON","stdout","path","loc","file","point","start","queryRange","range","definitions","language","e","highlight","isSupported","satisfies","Array","isArray","map","end","error","String","getDiagnostics","_forceRecheck","exitCode","undefined","diagnostics","filePathToMessages","Map","diagnostic","diagnosticArray","get","set","push","observeDiagnostics","ideConnections","getIDEConnections","switchMap","ideConnection","of","scan","concatMap","catch","err","getAutocompleteSuggestions","activatedManually","prefix","replacementPrefix","minimumPrefixLength","prefixHasDot","lineForRow","charAt","indexOf","length","contents","getCurrentIDEConnection","isIncomplete","items","resultsArray","completions","item","typeHint","character","getTextInRange","output","type","typeString","message","hint","getCoverage","expressions","uncoveredCount","uncovered_count","coveredCount","covered_count","totalCount","uncoveredRegions","uncovered_locs","percentage","getOutline","flowGetAst","currentContents","flowRootPath","execFlowClient","warn","formatSource","Error","formatEntireFile","formatAtPosition","triggerCharacter","findReferences","getEvaluationExpression","isFileInProject","value","JSON","parse","join","flowItem","description","substring","displayText","name","funcDetails","func_details","rightParamStrings","params","param","snippetArgs","getSnippetString","leftLabel","return_type","rightLabel","snippet","text","paramNames","groupedParams","snippetParamStrings","i","reduceRight","ordinary","optional","isOptional","unshift","ordinaryParams","trailingOptional","lastParam","lastChar","isInRecheck","staleMessages","currentMessages","filesToUpdate","Set","msg","keys","kind","newErrors","collateDiagnostics","errors","newMessages","messages","entries","oldMessages","stale","updates"],"mappings":";;;;;;;;;;;;;kQAAA;;;;;;;;;;;;QAwmBgBA,uB,GAAAA,uB;QA+DAC,e,GAAAA,e;QAwDAC,qB,GAAAA,qB;QAUAC,iB,GAAAA,iB;QAgFAC,oB,GAAAA,oB;;AA5yBhB;;AA8BA;;;;AACA;;AACA;;AACA;;AAEA;;AACA;;AAKA;;AAKA;;AACA;;AACA;;;;AACA;;AACA;;;;AARA,MAAMC,SAAS,uBAAU,kBAAV,CAAf;;AAUA;AACO,MAAMC,gCAAN,CAAuC;AAC5C;AAMAC,cAAYC,IAAZ,EAA0BC,iBAA1B,EAAoE;AAClE,SAAKC,KAAL,GAAaF,IAAb;AACA,SAAKG,kBAAL,GAA0BF,iBAA1B;AACA,SAAKG,QAAL,GAAgB,6BAAgBJ,IAAhB,EAAsBC,iBAAtB,CAAhB;AACA,SAAKI,QAAL,GAAgB,6DAAgB,aAAY;AAC1C,YAAMC,WAAW,MAAML,kBAAkBM,eAAlB,CAAkCP,IAAlC,CAAvB;AACA,UAAI,CAACM,QAAL,EAAe;AACb,eAAO,IAAP;AACD;AACD,aAAOA,SAASE,WAAhB;AACD,KANe,EAAhB;AAOA,SAAKJ,QAAL,CACGK,sBADH,GAEGC,MAFH,CAEUC,SAASA,UAAU,aAF7B,EAGGC,SAHH,CAGa,MAAM,KAAKP,QAAL,CAAcQ,iBAAd,EAHnB;AAID;;AAEDC,YAAgB;AACd,SAAKV,QAAL,CAAcU,OAAd;AACD;;AAEDC,uBAA2B;AACzB,SAAKX,QAAL,CAAcW,kBAAd;AACD;;AAEDC,kBAAwB;AACtB,WAAO,KAAKd,KAAZ;AACD;;AAEDe,iBAAeC,OAAf,EAA0D;AACxD;AACA;AACA;AACA,WAAOC,QAAQC,OAAR,CAAgB,KAAKlB,KAArB,CAAP;AACD;;AAEDO,2BAAuD;AACrD,WAAO,KAAKL,QAAL,CAAcK,sBAAd,EAAP;AACD;;AAEKY,eAAN,CACEC,QADF,EAEEC,MAFF,EAGEC,QAHF,EAImC;AAAA;;AAAA;AACjC,YAAMC,QAAQ,qCACZF,MADY,EAEZC,QAFY,2CAAd;AAKA,UAAIC,SAAS,IAAb,EAAmB;AACjB,eAAO,IAAP;AACD;AACD,YAAMC,OAAOF,SAASG,GAAT,GAAe,CAA5B;AACA,YAAMC,SAASJ,SAASI,MAAT,GAAkB,CAAjC;AACA,YAAMC,UAAU,EAAhB;AACA;AACA;AACA;AACA;AACA;AACAA,cAAQC,KAAR,GAAgBP,OAAOQ,OAAP,EAAhB;;AAEA,YAAMC,OAAO,CAAC,SAAD,EAAY,QAAZ,EAAsB,QAAtB,EAAgCV,QAAhC,EAA0CI,IAA1C,EAAgDE,MAAhD,CAAb;AACA,UAAI;AACF,cAAMK,SAAS,MAAM,MAAK7B,QAAL,CAAc8B,QAAd,CAAuBF,IAAvB,EAA6BH,OAA7B,CAArB;AACA,YAAI,CAACI,MAAL,EAAa;AACX,iBAAO,IAAP;AACD;AACD,cAAME,OAAOC,UAAUJ,IAAV,EAAgBC,OAAOI,MAAvB,CAAb;AACA,YAAIF,KAAKG,IAAT,EAAe;AACb,gBAAMC,MAAM;AACVC,kBAAML,KAAKG,IADD;AAEVG,mBAAO,4BAAUN,KAAKT,IAAL,GAAY,CAAtB,EAAyBS,KAAKO,KAAL,GAAa,CAAtC;AAFG,WAAZ;AAIA,iBAAO;AACLC,wBAAY,CAAClB,MAAMmB,KAAP,CADP;AAELC,yBAAa,CACX;AACEP,oBAAMC,IAAIC,IADZ;AAEEhB,wBAAUe,IAAIE,KAFhB;AAGEK,wBAAU;AAHZ,aADW;AAFR,WAAP;AAUD,SAfD,MAeO;AACL,iBAAO,IAAP;AACD;AACF,OAxBD,CAwBE,OAAOC,CAAP,EAAU;AACV,eAAO,IAAP;AACD;AA9CgC;AA+ClC;;AAEKC,WAAN,CACE1B,QADF,EAEEC,MAFF,EAGEC,QAHF,EAI+B;AAAA;;AAAA;AAC7B;AACA;AACA,YAAMyB,cAAc,MAAM,OAAK5C,QAAL,CAAc6C,SAAd,CAAwB,UAAxB,CAA1B;AACA,UAAI,CAACD,WAAL,EAAkB;AAChB,eAAO,IAAP;AACD;;AAED,YAAMpB,UAAU,EAACC,OAAOP,OAAOQ,OAAP,EAAR,EAAhB;AACA,YAAMC,OAAO,CACX,WADW,EAEX,QAFW,EAGX,QAHW,EAIXV,QAJW,EAKXE,SAASG,GAAT,GAAe,CALJ,EAMXH,SAASI,MAAT,GAAkB,CANP,CAAb;AAQA,UAAI;AACF,cAAMK,SAAS,MAAM,OAAK7B,QAAL,CAAc8B,QAAd,CAAuBF,IAAvB,EAA6BH,OAA7B,CAArB;AACA,YAAII,UAAU,IAAd,EAAoB;AAClB,iBAAO,IAAP;AACD;AACD,cAAME,OAAOC,UAAUJ,IAAV,EAAgBC,OAAOI,MAAvB,CAAb;AACA,YAAI,CAACc,MAAMC,OAAN,CAAcjB,IAAd,CAAL,EAA0B;AACxB,iBAAO,IAAP;AACD;AACD,eAAOA,KAAKkB,GAAL,CAAS,eAAO;AACrB,iBAAO,4BACL,4BAAUd,IAAIG,KAAJ,CAAUhB,IAAV,GAAiB,CAA3B,EAA8Ba,IAAIG,KAAJ,CAAUd,MAAV,GAAmB,CAAjD,CADK,EAEL,4BAAUW,IAAIe,GAAJ,CAAQ5B,IAAR,GAAe,CAAzB,EAA4Ba,IAAIe,GAAJ,CAAQ1B,MAApC,CAFK,CAAP;AAID,SALM,CAAP;AAMD,OAfD,CAeE,OAAOmB,CAAP,EAAU;AACVlD,eAAO0D,KAAP,CAAc,uBAAsBC,OAAOT,CAAP,CAAU,EAA9C;AACA,eAAO,IAAP;AACD;AAnC4B;AAoC9B;;AAED;;;;;AAKMU,gBAAN,CACEnC,QADF,EAEEC,MAFF,EAGsC;AAAA;;AAAA;AACpC,YAAM,OAAKmC,aAAL,CAAmBpC,QAAnB,CAAN;;AAEA,YAAMO,UAAU,EAAhB;;AAEA,YAAMG,OAAO,CAAC,QAAD,EAAW,QAAX,EAAqBV,QAArB,CAAb;;AAEA,UAAIW,MAAJ;;AAEA,UAAI;AACF;AACA;AACAA,iBAAS,MAAM,OAAK7B,QAAL,CAAc8B,QAAd,CACbF,IADa,EAEbH,OAFa;AAGb,2BAAoB,IAHP,CAAf;AAKA,YAAI,CAACI,MAAL,EAAa;AACX,iBAAO,IAAP;AACD;AACF,OAXD,CAWE,OAAOc,CAAP,EAAU;AACV;AACA;AACA;AACA,YAAIA,EAAEY,QAAF,KAAeC,SAAnB,EAA8B;AAC5B3B,mBAASc,CAAT;AACD,SAFD,MAEO;AACLlD,iBAAO0D,KAAP,CAAaR,CAAb;AACA,iBAAO,IAAP;AACD;AACF;;AAED,UAAIZ,IAAJ;AACA,UAAI;AACFA,eAAOC,UAAUJ,IAAV,EAAgBC,OAAOI,MAAvB,CAAP;AACD,OAFD,CAEE,OAAOU,CAAP,EAAU;AACV,eAAO,IAAP;AACD;;AAED,YAAMc,cAAc,sDAA8B1B,IAA9B,CAApB;;AAEA,YAAM2B,qBAAqB,IAAIC,GAAJ,EAA3B;;AAzCoC;AAAA;AAAA;;AAAA;AA2CpC,6BAAyBF,WAAzB,8HAAsC;AAAA,gBAA3BG,UAA2B;;AACpC,gBAAM1B,OAAO0B,WAAW1C,QAAxB;AACA,cAAI2C,kBAAkBH,mBAAmBI,GAAnB,CAAuB5B,IAAvB,CAAtB;AACA,cAAI,CAAC2B,eAAL,EAAsB;AACpBA,8BAAkB,EAAlB;AACAH,+BAAmBK,GAAnB,CAAuB7B,IAAvB,EAA6B2B,eAA7B;AACD;AACDA,0BAAgBG,IAAhB,CAAqBJ,UAArB;AACD;AAnDmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAqDpC,aAAO;AACLF;AADK,OAAP;AArDoC;AAwDrC;;AAEDO,uBAAgE;AAC9D,UAAMC,iBAAiB,KAAKlE,QAAL,CAAcmE,iBAAd,EAAvB;AACA,WAAOD,eACJE,SADI,CACMC,iBAAiB;AAC1B,UAAIA,iBAAiB,IAArB,EAA2B;AACzB,eAAOA,cAAcJ,kBAAd,EAAP;AACD,OAFD,MAEO;AACL;AACA;AACA,eAAO,iBAAWK,EAAX,CAAc,IAAd,CAAP;AACD;AACF,KATI,EAUJC,IAVI,CAUChF,iBAVD,EAUoBD,uBAVpB,EAWJkF,SAXI,CAWMhF,oBAXN,EAYJiF,KAZI,CAYEC,OAAO;AACZjF,aAAO0D,KAAP,CAAauB,GAAb;AACA,YAAMA,GAAN;AACD,KAfI,CAAP;AAgBD;;AAEKC,4BAAN,CACEzD,QADF,EAEEC,MAFF,EAGEC,QAHF,EAIEwD,iBAJF,EAKEC,MALF,EAMgC;AAAA;;AAAA;AAC9B,YAAMC,oBAAoB,6CAAqBD,MAArB,CAA1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAME,sBAAsB,CAA5B;;AAEA;AACA;AACA;AACA,YAAMC;AACJ;AACA7D,aAAO8D,UAAP,CAAkB7D,SAASG,GAA3B,EAAgC2D,MAAhC,CAAuC9D,SAASI,MAAT,GAAkB,CAAzD,MAAgE,GAAhE,IACAqD,OAAOM,OAAP,CAAe,GAAf,MAAwB,CAAC,CAH3B;;AAKA,UACE,CAACP,iBAAD,IACA,CAACI,YADD,IAEAF,kBAAkBM,MAAlB,GAA2BL,mBAH7B,EAIE;AACA,eAAO,IAAP;AACD;;AAED;AACA,YAAMzD,OAAOF,SAASG,GAAT,GAAe,CAA5B;AACA,YAAMC,SAASJ,SAASI,MAAT,GAAkB,CAAjC;AACA,YAAM6D,WAAWlE,OAAOQ,OAAP,EAAjB;AACA,UAAI;AACF,YAAII,IAAJ;AACA,cAAMsC,gBAAgB,OAAKrE,QAAL,CAAcsF,uBAAd,EAAtB;AACA,YACEjB,iBAAiB,IAAjB,KACC,MAAM,OAAKpE,QAAL,CAAc6C,SAAd,CAAwB,UAAxB,CADP,CADF,EAGE;AACAf,iBAAO,MAAMsC,cAAcM,0BAAd,CACXzD,QADW,EAEXI,IAFW,EAGXE,MAHW,EAIX6D,QAJW,CAAb;AAMD,SAVD,MAUO;AACL,gBAAMzD,OAAO,CAAC,cAAD,EAAiB,QAAjB,EAA2BV,QAA3B,EAAqCI,IAArC,EAA2CE,MAA3C,CAAb;AACA,gBAAMC,UAAU,EAACC,OAAO2D,QAAR,EAAhB;;AAEA,gBAAMxD,SAAS,MAAM,OAAK7B,QAAL,CAAc8B,QAAd,CAAuBF,IAAvB,EAA6BH,OAA7B,CAArB;AACA,cAAI,CAACI,MAAL,EAAa;AACX,mBAAO,EAAC0D,cAAc,KAAf,EAAsBC,OAAO,EAA7B,EAAP;AACD;AACDzD,iBAAQC,UAAUJ,IAAV,EAAgBC,OAAOI,MAAvB,CAAR;AACD;AACD,cAAMwD,eAA4C1D,KAAKF,MAAvD;AACA,cAAM6D,cAAcD,aAAaxC,GAAb,CAAiB;AAAA,iBACnC7D,wBAAwB0F,iBAAxB,EAA2Ca,IAA3C,CADmC;AAAA,SAAjB,CAApB;AAGA,eAAO,8CAAsBd,MAAtB,EAA8B;AACnCU,wBAAc,KADqB;AAEnCC,iBAAOE;AAF4B,SAA9B,CAAP;AAID,OA/BD,CA+BE,OAAO/C,CAAP,EAAU;AACV,eAAO,EAAC4C,cAAc,KAAf,EAAsBC,OAAO,EAA7B,EAAP;AACD;AA/D6B;AAgE/B;;AAEKI,UAAN,CACE1E,QADF,EAEEC,MAFF,EAGEC,QAHF,EAIsB;AAAA;;AAAA;AACpB;AACA,YAAMyE,YAAY1E,OAAO2E,cAAP,CAAsB,CACtC1E,QADsC,EAEtC;AACEG,aAAKH,SAASG,GADhB;AAEEC,gBAAQJ,SAASI,MAAT,GAAkB;AAF5B,OAFsC,CAAtB,CAAlB;AAOA,UAAIqE,UAAUxE,KAAV,CAAgB,IAAhB,CAAJ,EAA2B;AACzB,eAAO,IAAP;AACD;;AAED,YAAMI,UAAU,EAAhB;;AAEAA,cAAQC,KAAR,GAAgBP,OAAOQ,OAAP,EAAhB;;AAEA,YAAML,OAAOF,SAASG,GAAT,GAAe,CAA5B;AACA,YAAMC,SAASJ,SAASI,MAAT,GAAkB,CAAjC;AACA,YAAMI,OAAO,CAAC,aAAD,EAAgB,QAAhB,EAA0B,QAA1B,EAAoCV,QAApC,EAA8CI,IAA9C,EAAoDE,MAApD,CAAb;;AAEA,UAAIK,MAAJ;AACA,UAAI;AACFA,iBAAS,MAAM,OAAK7B,QAAL,CAAc8B,QAAd,CAAuBF,IAAvB,EAA6BH,OAA7B,CAAf;AACD,OAFD,CAEE,OAAOkB,CAAP,EAAU;AACVd,iBAAS,IAAT;AACD;AACD,UAAI,CAACA,MAAL,EAAa;AACX,eAAO,IAAP;AACD;AACD,YAAMkE,SAASlE,OAAOI,MAAtB;;AAEA,UAAIF,IAAJ;AACA,UAAI;AACFA,eAAQC,UAAUJ,IAAV,EAAgBmE,MAAhB,CAAR;AACD,OAFD,CAEE,OAAOpD,CAAP,EAAU;AACV,eAAO,IAAP;AACD;AACD,YAAMqD,OAAOjE,KAAKiE,IAAlB;AACA,YAAMxD,QAAQ,+CAAuBT,KAAKI,GAA5B,CAAd;AACA,UAAI,CAAC6D,IAAD,IAASA,SAAS,WAAtB,EAAmC;AACjC,eAAO,IAAP;AACD;AACD,UAAIC,UAAJ;AACA,UAAI;AACFA,qBAAa,gCAAiBD,IAAjB,CAAb;AACD,OAFD,CAEE,OAAOrD,CAAP,EAAU;AACVlD,eAAO0D,KAAP,CAAc,sCAAqCR,EAAEuD,OAAQ,EAA7D;AACAD,qBAAaD,IAAb;AACD;AACD,aAAO;AACLG,cAAMF,UADD;AAELzD;AAFK,OAAP;AAlDoB;AAsDrB;;AAEK4D,aAAN,CAAkBlF,QAAlB,EAAkE;AAAA;;AAAA;AAChE,YAAMU,OAAO,CAAC,UAAD,EAAa,QAAb,EAAuBV,QAAvB,CAAb;AACA,UAAIW,MAAJ;AACA,UAAI;AACFA,iBAAS,MAAM,OAAK7B,QAAL,CAAc8B,QAAd,CAAuBF,IAAvB,EAA6B,EAA7B,CAAf;AACD,OAFD,CAEE,OAAOe,CAAP,EAAU;AACV,eAAO,IAAP;AACD;AACD,UAAId,UAAU,IAAd,EAAoB;AAClB,eAAO,IAAP;AACD;AACD,UAAIE,IAAJ;AACA,UAAI;AACFA,eAAOC,UAAUJ,IAAV,EAAgBC,OAAOI,MAAvB,CAAP;AACD,OAFD,CAEE,OAAOU,CAAP,EAAU;AACV;AACA,eAAO,IAAP;AACD;;AAED,YAAM0D,cAActE,KAAKsE,WAAzB;;AAEA,YAAMC,iBAAiBD,YAAYE,eAAnC;AACA,YAAMC,eAAeH,YAAYI,aAAjC;AACA,YAAMC,aAAaJ,iBAAiBE,YAApC;;AAEA,YAAMG,mBAAmBN,YAAYO,cAAZ,CACtB3D,GADsB,4CAEtBA,GAFsB,CAElB;AAAA,eAAU,EAACT,KAAD,EAAV;AAAA,OAFkB,CAAzB;;AAIA,aAAO;AACLqE,oBAAYH,eAAe,CAAf,GAAmB,GAAnB,GAAyBF,eAAeE,UAAf,GAA4B,GAD5D;AAELC;AAFK,OAAP;AA7BgE;AAiCjE;;AAEKrD,eAAN,CAAoBlB,IAApB,EAAoD;AAAA;;AAAA;AAClD,UAAI;AACF,cAAM,OAAKpC,QAAL,CAAc8B,QAAd,CACJ,CAAC,eAAD,EAAkBM,IAAlB,CADI;AAEJ,qBAAc,EAFV;AAGJ;AACA,4BAAqB,KAJjB;AAKJ,4BAAqB,IALjB,CAAN;AAOA,eAAO,IAAP;AACD,OATD,CASE,OAAOO,CAAP,EAAU;AACV;AACA;AACA,eAAO,KAAP;AACD;AAdiD;AAenD;;AAEDmE,aACE5F,QADF,EAEEC,MAFF,EAGqB;AACnB,WAAOzB,iCAAiCoH,UAAjC,CACL5F,QADK,EAELC,MAFK,EAGL,IAHK,EAIL,KAAKpB,kBAJA,CAAP;AAMD;;AAED;AACA;AACA;AACA;AACA,SAAa+G,UAAb,CACE5F,QADF,EAEEC,MAFF,EAGEvB,IAHF,EAIEC,iBAJF,EAKqB;AAAA;AACnB,YAAMkC,OAAO,MAAMrC,iCAAiCqH,UAAjC,CACjBnH,IADiB,EAEjBuB,OAAOQ,OAAP,EAFiB,EAGjB9B,iBAHiB,CAAnB;;AAMA,UAAI;AACF,eAAOkC,OAAO,gCAAaA,IAAb,CAAP,GAA4B,IAAnC;AACD,OAFD,CAEE,OAAOY,CAAP,EAAU;AACV;AACA;AACAlD,eAAO0D,KAAP,CAAaR,CAAb;AACA,eAAO,IAAP;AACD;AAdkB;AAepB;;AAED,SAAaoE,UAAb,CACEnH,IADF,EAEEoH,eAFF,EAGEnH,iBAHF,EAIgB;AAAA;AACd,YAAM4B,UAAU;AACdC,eAAOsF;AADO,OAAhB;;AAIA,YAAMC,eAAerH,QAAQ,IAAR,GAAe,IAAf,GAAsBA,KAAKgB,aAAL,EAA3C;;AAEA,YAAMgB,OAAO,CAAC,KAAD,CAAb;;AAEA,UAAIG,IAAJ;AACA,UAAI;AACF,cAAMF,SAAS,MAAM,yBAAYqF,cAAZ,CACnBtF,IADmB,EAEnBqF,YAFmB,EAGnBpH,iBAHmB,EAInB4B,OAJmB,CAArB;AAMA,YAAII,UAAU,IAAd,EAAoB;AAClB,iBAAO,IAAP;AACD;AACDE,eAAOC,UAAUJ,IAAV,EAAgBC,OAAOI,MAAvB,CAAP;AACD,OAXD,CAWE,OAAOU,CAAP,EAAU;AACVlD,eAAO0H,IAAP,CAAYxE,CAAZ;AACA,eAAO,IAAP;AACD;AACD,aAAOZ,IAAP;AAzBc;AA0Bf;;AAEDqF,eACElG,QADF,EAEEC,MAFF,EAGEqB,KAHF,EAI6B;AAC3B,UAAM,IAAI6E,KAAJ,CAAU,qBAAV,CAAN;AACD;;AAEDC,mBACEpG,QADF,EAEEC,MAFF,EAGEqB,KAHF,EAOG;AACD,UAAM,IAAI6E,KAAJ,CAAU,iBAAV,CAAN;AACD;;AAEDE,mBACErG,QADF,EAEEC,MAFF,EAGEC,QAHF,EAIEoG,gBAJF,EAK6B;AAC3B,UAAM,IAAIH,KAAJ,CAAU,qBAAV,CAAN;AACD;;AAEDI,iBACEvG,QADF,EAEEC,MAFF,EAGEC,QAHF,EAIkC;AAChC,UAAM,IAAIiG,KAAJ,CAAU,qBAAV,CAAN;AACD;;AAEDK,0BACExG,QADF,EAEEC,MAFF,EAGEC,QAHF,EAIyC;AACvC,UAAM,IAAIiG,KAAJ,CAAU,iBAAV,CAAN;AACD;;AAEDM,kBAAgB7G,OAAhB,EAAuD;AACrD,UAAM,IAAIuG,KAAJ,CAAU,qBAAV,CAAN;AACD;AAhhB2C;;QAAjC3H,gC,GAAAA,gC,EAmhBb;;AACG,IAAH;;AAEA,SAASsC,SAAT,CAAmBJ,IAAnB,EAAqCgG,KAArC,EAAyD;AACvD,MAAI;AACF,WAAOC,KAAKC,KAAL,CAAWF,KAAX,CAAP;AACD,GAFD,CAEE,OAAOjF,CAAP,EAAU;AACVlD,WAAO0H,IAAP,CACG,iCAAgCvF,KAAKmG,IAAL,CAAU,GAAV,CAAe,aAAYH,KAAM,IADpE;AAGA,UAAMjF,CAAN;AACD;AACF;;AAED;;;;;AAKO,SAASvD,uBAAT,CACL0F,iBADK,EAELkD,QAFK,EAGO;AACZ;AACA,QAAMC,cACJD,SAAShC,IAAT,CAAcZ,MAAd,GAAuB,EAAvB,GACI4C,SAAShC,IADb,GAEIgC,SAAShC,IAAT,CAAckC,SAAd,CAAwB,CAAxB,EAA2B,EAA3B,IAAiC,MAHvC;AAIA,MAAIrG,SAAS;AACXoG,eADW;AAEXE,iBAAaH,SAASI,IAFX;AAGXtD;AAHW,GAAb;AAKA,QAAMuD,cAAcL,SAASM,YAA7B;AACA,MAAID,WAAJ,EAAiB;AACf;AACA,UAAME,oBAAoBF,YAAYG,MAAZ,CAAmBvF,GAAnB,CACxBwF,SAAU,GAAEA,MAAML,IAAK,KAAIK,MAAMzC,IAAK,EADd,CAA1B;AAGA,QAAI0C,cAAe,IAAGC,iBACpBN,YAAYG,MAAZ,CAAmBvF,GAAnB,CAAuBwF,SAASA,MAAML,IAAtC,CADoB,CAEpB,GAFF;AAGA,QAAIQ,YAAYP,YAAYQ,WAA5B;AACA,QAAIC,aAAc,IAAGP,kBAAkBR,IAAlB,CAAuB,IAAvB,CAA6B,GAAlD;AACA,QAAI,CAAC,uBAAU,uCAAV,CAAL,EAAyD;AACvDW,oBAAc,EAAd;AACAE,kBAAYpF,SAAZ;AACAsF,oBAAe,OAAMT,YAAYQ,WAAY,EAA7C;AACD;AACDhH,0BACKA,MADL;AAEE+G,eAFF;AAGEE,gBAHF;AAIEC,eAAU,GAAEf,SAASI,IAAK,GAAEM,WAAY,EAJ1C;AAKE1C,YAAM;AALR;AAOD,GAtBD,MAsBO;AACLnE,0BACKA,MADL;AAEEiH,kBAAYd,SAAShC,IAFvB;AAGEgD,YAAMhB,SAASI;AAHjB;AAKD;AACD,SAAOvG,MAAP;AACD;;AAED,SAAS8G,gBAAT,CAA0BM,UAA1B,EAA6D;AAC3D,QAAMC,gBAAgB7J,gBAAgB4J,UAAhB,CAAtB;AACA;AACA,QAAME,sBAAsBD,cACzBjG,GADyB,CACrBuF,UAAUA,OAAOT,IAAP,CAAY,IAAZ,CADW,EAEzB9E,GAFyB,CAErB,CAACwF,KAAD,EAAQW,CAAR,KAAe,MAAKA,IAAI,CAAE,IAAGX,KAAM,GAFd,CAA5B;AAGA,SAAOU,oBAAoBpB,IAApB,CAAyB,IAAzB,CAAP;AACD;;AAED;;;;;;AAMA;AACO,SAAS1I,eAAT,CACL4J,UADK,EAEiB;AACtB;AACA;AAFsB,8BAIqBA,WAAWI,WAAX,CACzC,CAAC,CAACC,QAAD,EAAWC,QAAX,CAAD,EAAuBd,KAAvB,KAAiC;AAC/B;AACA;AACA,QAAIe,WAAWf,KAAX,KAAqBa,SAASlE,MAAT,KAAoB,CAA7C,EAAgD;AAC9CmE,eAASE,OAAT,CAAiBhB,KAAjB;AACD,KAFD,MAEO;AACLa,eAASG,OAAT,CAAiBhB,KAAjB;AACD;AACD,WAAO,CAACa,QAAD,EAAWC,QAAX,CAAP;AACD,GAVwC,EAWzC,CAAC,EAAD,EAAK,EAAL,CAXyC,CAJrB;AAAA;;AAAA,QAIfG,cAJe;AAAA,QAICC,gBAJD;;;AAkBtB,QAAMT,gBAAgBQ,eAAezG,GAAf,CAAmBwF,SAAS,CAACA,KAAD,CAA5B,CAAtB;AACA,QAAMmB,YAAYV,cAAcA,cAAc9D,MAAd,GAAuB,CAArC,CAAlB;AACA,MAAIwE,aAAa,IAAjB,EAAuB;AACrBA,cAAU5F,IAAV,CAAe,GAAG2F,gBAAlB;AACD,GAFD,MAEO,IAAIA,iBAAiBvE,MAAjB,GAA0B,CAA9B,EAAiC;AACtC8D,kBAAclF,IAAd,CAAmB2F,gBAAnB;AACD;;AAED,SAAOT,aAAP;AACD;;AAED,SAASM,UAAT,CAAoBf,KAApB,EAA4C;AAC1C,wBAAUA,MAAMrD,MAAN,GAAe,CAAzB;AACA,QAAMyE,WAAWpB,MAAMA,MAAMrD,MAAN,GAAe,CAArB,CAAjB;AACA,SAAOyE,aAAa,GAApB;AACD;;AAED;AACA;AACA;;;AAgBA;AACO,SAASvK,qBAAT,GAAmD;AACxD,SAAO;AACLwK,iBAAa,KADR;AAELC,mBAAe,IAAIpG,GAAJ,EAFV;AAGLqG,qBAAiB,IAAIrG,GAAJ,EAHZ;AAILsG,mBAAe,IAAIC,GAAJ;AAJV,GAAP;AAMD;;AAED;AACO,SAAS3K,iBAAT,CACLgB,KADK;AAEL;AACA4J,GAHK,EAIa;AAClB,MAAIA,OAAO,IAAX,EAAiB;AACf,WAAO;AACLL,mBAAa,KADR;AAELC,qBAAe,IAAIpG,GAAJ,EAFV;AAGLqG,uBAAiB,IAAIrG,GAAJ,EAHZ;AAILsG,qBAAe,0BACb,IAAIC,GAAJ,CAAQ3J,MAAMwJ,aAAN,CAAoBK,IAApB,EAAR,CADa,EAEb,IAAIF,GAAJ,CAAQ3J,MAAMyJ,eAAN,CAAsBI,IAAtB,EAAR,CAFa;AAJV,KAAP;AASD;AACD,UAAQD,IAAIE,IAAZ;AACE,SAAK,QAAL;AACE,YAAMC,YAAYC,mBAAmBJ,IAAIK,MAAvB,CAAlB;AACA,UAAIjK,MAAMuJ,WAAV,EAAuB;AACrB;AADqB,cAEdE,eAFc,GAEKzJ,KAFL,CAEdyJ,eAFc;AAAA;AAAA;AAAA;;AAAA;AAGrB,gCAAkCM,SAAlC,mIAA6C;AAAA;;AAAA;;AAAA,kBAAjClI,IAAiC;AAAA,kBAA3BqI,WAA2B;;AAC3C,gBAAIC,WAAWV,gBAAgBlG,GAAhB,CAAoB1B,IAApB,CAAf;AACA,gBAAIsI,YAAY,IAAhB,EAAsB;AACpBA,yBAAW,EAAX;AACAV,8BAAgBjG,GAAhB,CAAoB3B,IAApB,EAA0BsI,QAA1B;AACD;AACDA,qBAAS1G,IAAT,CAAc,GAAGyG,WAAjB;AACD;AAVoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAWrB,eAAO;AACLX,uBAAavJ,MAAMuJ,WADd;AAELC,yBAAexJ,MAAMwJ,aAFhB;AAGLC,yBAHK;AAILC,yBAAe,IAAIC,GAAJ,CAAQI,UAAUF,IAAV,EAAR;AAJV,SAAP;AAMD,OAjBD,MAiBO;AACL;AACA;AACA,cAAMH,gBAAgB,0BACpB,IAAIC,GAAJ,CAAQI,UAAUF,IAAV,EAAR,CADoB,EAEpB,IAAIF,GAAJ,CAAQ3J,MAAMyJ,eAAN,CAAsBI,IAAtB,EAAR,CAFoB,CAAtB;AAIA,eAAO;AACLN,uBAAavJ,MAAMuJ,WADd;AAELC,yBAAexJ,MAAMwJ,aAFhB;AAGLC,2BAAiBM,SAHZ;AAILL;AAJK,SAAP;AAMD;AACH,SAAK,eAAL;AACE,YAAMF,gBAAgB,IAAIpG,GAAJ,EAAtB;AADF;AAAA;AAAA;;AAAA;AAEE,8BAAkCpD,MAAMyJ,eAAN,CAAsBW,OAAtB,EAAlC,mIAAmE;AAAA;;AAAA;;AAAA,gBAAvDvI,IAAuD;AAAA,gBAAjDwI,WAAiD;;AACjE,gBAAMF,WAAWE,YAAY3H,GAAZ,CAAgBiD,wBAC5BA,OAD4B;AAE/B2E,mBAAO;AAFwB,YAAhB,CAAjB;AAIAd,wBAAchG,GAAd,CAAkB3B,IAAlB,EAAwBsI,QAAxB;AACD;AARH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASE,aAAO;AACLZ,qBAAa,IADR;AAELC,qBAFK;AAGLC,yBAAiB,IAAIrG,GAAJ,EAHZ;AAILsG,uBAAe,IAAIC,GAAJ,CAAQ3J,MAAMyJ,eAAN,CAAsBI,IAAtB,EAAR;AAJV,OAAP;AAMF,SAAK,aAAL;AACE,aAAO;AACLN,qBAAa,KADR;AAELC,uBAAe,IAAIpG,GAAJ,EAFV;AAGLqG,yBAAiBzJ,MAAMyJ,eAHlB;AAILC,uBAAe,IAAIC,GAAJ,CAAQ3J,MAAMwJ,aAAN,CAAoBK,IAApB,EAAR;AAJV,OAAP;AAMF;AACE;AACCD,UAAIE,IAAL;AACA,YAAM,IAAIhD,KAAJ,CAAW,wBAAuB8C,IAAIE,IAAK,EAA3C,CAAN;AA3DJ;AA6DD;;AAED;AACO,SAAS7K,oBAAT,CACLe,KADK,EAEsC;AAC3C,QAAMuK,UAAU,EAAhB;AAD2C;AAAA;AAAA;;AAAA;AAE3C,0BAAmBvK,MAAM0J,aAAzB,mIAAwC;AAAA,YAA7B7H,IAA6B;;AACtC,YAAMsI,WAAW,CACf,GAAG,mCAAkBnK,MAAMwJ,aAAxB,EAAuC3H,IAAvC,EAA6C,EAA7C,CADY,EAEf,GAAG,mCAAkB7B,MAAMyJ,eAAxB,EAAyC5H,IAAzC,EAA+C,EAA/C,CAFY,CAAjB;AAIA0I,cAAQ9G,IAAR,CAAa,EAAC9C,UAAUkB,IAAX,EAAiBsI,QAAjB,EAAb;AACD;AAR0C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAS3C,SAAO,iBAAWpG,EAAX,CAAcwG,OAAd,CAAP;AACD;;AAED,SAASP,kBAAT,CACExE,MADF,EAEiD;AAC/C,QAAMtC,cAAc,sDAA8BsC,MAA9B,CAApB;AACA,QAAMrC,qBAAqB,IAAIC,GAAJ,EAA3B;;AAF+C;AAAA;AAAA;;AAAA;AAI/C,0BAAyBF,WAAzB,mIAAsC;AAAA,YAA3BG,UAA2B;;AACpC,YAAM1B,OAAO0B,WAAW1C,QAAxB;AACA,UAAI2C,kBAAkBH,mBAAmBI,GAAnB,CAAuB5B,IAAvB,CAAtB;AACA,UAAI,CAAC2B,eAAL,EAAsB;AACpBA,0BAAkB,EAAlB;AACAH,2BAAmBK,GAAnB,CAAuB7B,IAAvB,EAA6B2B,eAA7B;AACD;AACDA,sBAAgBG,IAAhB,CAAqBJ,UAArB;AACD;AAZ8C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAa/C,SAAOF,kBAAP;AACD","file":"FlowSingleProjectLanguageService.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport type {NuclideUri} from 'nuclide-commons/nuclideUri';\nimport {wordAtPositionFromBuffer} from 'nuclide-commons/range';\nimport type {CoverageResult} from '../../nuclide-type-coverage/lib/rpc-types';\nimport type {\n  AutocompleteResult,\n  Completion,\n} from '../../nuclide-language-service/lib/LanguageService';\nimport type {\n  DefinitionQueryResult,\n  DiagnosticProviderUpdate,\n  FileDiagnosticMessages,\n  FileDiagnosticMessage,\n  FindReferencesReturn,\n  Outline,\n} from 'atom-ide-ui';\nimport type {SingleFileLanguageService} from '../../nuclide-language-service-rpc';\nimport type {NuclideEvaluationExpression} from '../../nuclide-debugger-interfaces/rpc-types';\nimport type {TextEdit} from 'nuclide-commons-atom/text-edit';\nimport type {TypeHint} from '../../nuclide-type-hint/lib/rpc-types';\n\nimport type {PushDiagnosticsMessage} from './FlowIDEConnection';\n\nimport type {ServerStatusType} from '..';\nimport type {FlowExecInfoContainer} from './FlowExecInfoContainer';\nimport type {\n  FlowAutocompleteOutput,\n  FlowAutocompleteItem,\n  TypeAtPosOutput,\n  FlowStatusOutput,\n} from './flowOutputTypes';\n\nimport invariant from 'assert';\nimport {Range, Point} from 'simple-text-buffer';\nimport {getConfig} from './config';\nimport {Observable} from 'rxjs';\n\nimport {setUnion, mapGetWithDefault} from 'nuclide-commons/collection';\nimport {\n  filterResultsByPrefix,\n  getReplacementPrefix,\n  JAVASCRIPT_WORD_REGEX,\n} from '../../nuclide-flow-common';\nimport {getLogger} from 'log4js';\nconst logger = getLogger('nuclide-flow-rpc');\n\nimport {flowCoordsToAtomCoords} from '../../nuclide-flow-common';\n\nimport {FlowProcess} from './FlowProcess';\nimport {FlowVersion} from './FlowVersion';\nimport prettyPrintTypes from './prettyPrintTypes';\nimport {astToOutline} from './astToOutline';\nimport {flowStatusOutputToDiagnostics} from './diagnosticsParser';\n\n/** Encapsulates all of the state information we need about a specific Flow root */\nexport class FlowSingleProjectLanguageService {\n  // The path to the directory where the .flowconfig is -- i.e. the root of the Flow project.\n  _root: string;\n  _process: FlowProcess;\n  _version: FlowVersion;\n  _execInfoContainer: FlowExecInfoContainer;\n\n  constructor(root: string, execInfoContainer: FlowExecInfoContainer) {\n    this._root = root;\n    this._execInfoContainer = execInfoContainer;\n    this._process = new FlowProcess(root, execInfoContainer);\n    this._version = new FlowVersion(async () => {\n      const execInfo = await execInfoContainer.getFlowExecInfo(root);\n      if (!execInfo) {\n        return null;\n      }\n      return execInfo.flowVersion;\n    });\n    this._process\n      .getServerStatusUpdates()\n      .filter(state => state === 'not running')\n      .subscribe(() => this._version.invalidateVersion());\n  }\n\n  dispose(): void {\n    this._process.dispose();\n  }\n\n  allowServerRestart(): void {\n    this._process.allowServerRestart();\n  }\n\n  getPathToRoot(): string {\n    return this._root;\n  }\n\n  getProjectRoot(fileUri: NuclideUri): Promise<?NuclideUri> {\n    // TODO Consider an invariant to assert that fileUri is inside this root. However, that should\n    // never happen since this will be enclosed by MultiProjectLanguageService which will dispatch\n    // to the correct instance of this class.\n    return Promise.resolve(this._root);\n  }\n\n  getServerStatusUpdates(): Observable<ServerStatusType> {\n    return this._process.getServerStatusUpdates();\n  }\n\n  async getDefinition(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n  ): Promise<?DefinitionQueryResult> {\n    const match = wordAtPositionFromBuffer(\n      buffer,\n      position,\n      JAVASCRIPT_WORD_REGEX,\n    );\n    if (match == null) {\n      return null;\n    }\n    const line = position.row + 1;\n    const column = position.column + 1;\n    const options = {};\n    // We pass the current contents of the buffer to Flow via stdin.\n    // This makes it possible for get-def to operate on the unsaved content in\n    // the user's editor rather than what is saved on disk. It would be annoying\n    // if the user had to save before using the jump-to-definition feature to\n    // ensure he or she got accurate results.\n    options.input = buffer.getText();\n\n    const args = ['get-def', '--json', '--path', filePath, line, column];\n    try {\n      const result = await this._process.execFlow(args, options);\n      if (!result) {\n        return null;\n      }\n      const json = parseJSON(args, result.stdout);\n      if (json.path) {\n        const loc = {\n          file: json.path,\n          point: new Point(json.line - 1, json.start - 1),\n        };\n        return {\n          queryRange: [match.range],\n          definitions: [\n            {\n              path: loc.file,\n              position: loc.point,\n              language: 'Flow',\n            },\n          ],\n        };\n      } else {\n        return null;\n      }\n    } catch (e) {\n      return null;\n    }\n  }\n\n  async highlight(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n  ): Promise<?Array<atom$Range>> {\n    // `flow find-refs` came out in v0.38.0\n    // https://github.com/facebook/flow/releases/tag/v0.38.0\n    const isSupported = await this._version.satisfies('>=0.38.0');\n    if (!isSupported) {\n      return null;\n    }\n\n    const options = {input: buffer.getText()};\n    const args = [\n      'find-refs',\n      '--json',\n      '--path',\n      filePath,\n      position.row + 1,\n      position.column + 1,\n    ];\n    try {\n      const result = await this._process.execFlow(args, options);\n      if (result == null) {\n        return null;\n      }\n      const json = parseJSON(args, result.stdout);\n      if (!Array.isArray(json)) {\n        return null;\n      }\n      return json.map(loc => {\n        return new Range(\n          new Point(loc.start.line - 1, loc.start.column - 1),\n          new Point(loc.end.line - 1, loc.end.column),\n        );\n      });\n    } catch (e) {\n      logger.error(`flowFindRefs error: ${String(e)}`);\n      return null;\n    }\n  }\n\n  /**\n   * If currentContents is null, it means that the file has not changed since\n   * it has been saved, so we can avoid piping the whole contents to the Flow\n   * process.\n   */\n  async getDiagnostics(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n  ): Promise<?DiagnosticProviderUpdate> {\n    await this._forceRecheck(filePath);\n\n    const options = {};\n\n    const args = ['status', '--json', filePath];\n\n    let result;\n\n    try {\n      // Don't log errors if the command returns a nonzero exit code, because status returns nonzero\n      // if it is reporting any issues, even when it succeeds.\n      result = await this._process.execFlow(\n        args,\n        options,\n        /* waitForServer */ true,\n      );\n      if (!result) {\n        return null;\n      }\n    } catch (e) {\n      // This codepath will be exercised when Flow finds type errors as the\n      // exit code will be non-zero. Note this codepath could also be exercised\n      // due to a logical error in Nuclide, so we try to differentiate.\n      if (e.exitCode !== undefined) {\n        result = e;\n      } else {\n        logger.error(e);\n        return null;\n      }\n    }\n\n    let json;\n    try {\n      json = parseJSON(args, result.stdout);\n    } catch (e) {\n      return null;\n    }\n\n    const diagnostics = flowStatusOutputToDiagnostics(json);\n\n    const filePathToMessages = new Map();\n\n    for (const diagnostic of diagnostics) {\n      const path = diagnostic.filePath;\n      let diagnosticArray = filePathToMessages.get(path);\n      if (!diagnosticArray) {\n        diagnosticArray = [];\n        filePathToMessages.set(path, diagnosticArray);\n      }\n      diagnosticArray.push(diagnostic);\n    }\n\n    return {\n      filePathToMessages,\n    };\n  }\n\n  observeDiagnostics(): Observable<Array<FileDiagnosticMessages>> {\n    const ideConnections = this._process.getIDEConnections();\n    return ideConnections\n      .switchMap(ideConnection => {\n        if (ideConnection != null) {\n          return ideConnection.observeDiagnostics();\n        } else {\n          // if ideConnection is null, it means there is currently no connection. So, invalidate the\n          // current diagnostics so we don't display stale data.\n          return Observable.of(null);\n        }\n      })\n      .scan(updateDiagnostics, emptyDiagnosticsState())\n      .concatMap(getDiagnosticUpdates)\n      .catch(err => {\n        logger.error(err);\n        throw err;\n      });\n  }\n\n  async getAutocompleteSuggestions(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n    activatedManually: boolean,\n    prefix: string,\n  ): Promise<?AutocompleteResult> {\n    const replacementPrefix = getReplacementPrefix(prefix);\n    // We may want to make this configurable, but if it is ever higher than one we need to make sure\n    // it works properly when the user manually activates it (e.g. with ctrl+space). See\n    // https://github.com/atom/autocomplete-plus/issues/597\n    //\n    // If this is made configurable, consider using autocomplete-plus' minimumWordLength setting, as\n    // per https://github.com/atom/autocomplete-plus/issues/594\n    const minimumPrefixLength = 1;\n\n    // Allows completions to immediately appear when we are completing off of object properties.\n    // This also needs to be changed if minimumPrefixLength goes above 1, since after you type a\n    // single alphanumeric character, autocomplete-plus no longer includes the dot in the prefix.\n    const prefixHasDot =\n      // charAt(index) returns an empty string if the index is out of bounds\n      buffer.lineForRow(position.row).charAt(position.column - 1) === '.' ||\n      prefix.indexOf('.') !== -1;\n\n    if (\n      !activatedManually &&\n      !prefixHasDot &&\n      replacementPrefix.length < minimumPrefixLength\n    ) {\n      return null;\n    }\n\n    // Note that Atom coordinates are 0-indexed whereas Flow's are 1-indexed, so we must add 1.\n    const line = position.row + 1;\n    const column = position.column + 1;\n    const contents = buffer.getText();\n    try {\n      let json: FlowAutocompleteOutput;\n      const ideConnection = this._process.getCurrentIDEConnection();\n      if (\n        ideConnection != null &&\n        (await this._version.satisfies('>=0.48.0'))\n      ) {\n        json = await ideConnection.getAutocompleteSuggestions(\n          filePath,\n          line,\n          column,\n          contents,\n        );\n      } else {\n        const args = ['autocomplete', '--json', filePath, line, column];\n        const options = {input: contents};\n\n        const result = await this._process.execFlow(args, options);\n        if (!result) {\n          return {isIncomplete: false, items: []};\n        }\n        json = (parseJSON(args, result.stdout): FlowAutocompleteOutput);\n      }\n      const resultsArray: Array<FlowAutocompleteItem> = json.result;\n      const completions = resultsArray.map(item =>\n        processAutocompleteItem(replacementPrefix, item),\n      );\n      return filterResultsByPrefix(prefix, {\n        isIncomplete: false,\n        items: completions,\n      });\n    } catch (e) {\n      return {isIncomplete: false, items: []};\n    }\n  }\n\n  async typeHint(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n  ): Promise<?TypeHint> {\n    // Do not show typehints for whitespace.\n    const character = buffer.getTextInRange([\n      position,\n      {\n        row: position.row,\n        column: position.column + 1,\n      },\n    ]);\n    if (character.match(/\\s/)) {\n      return null;\n    }\n\n    const options = {};\n\n    options.input = buffer.getText();\n\n    const line = position.row + 1;\n    const column = position.column + 1;\n    const args = ['type-at-pos', '--json', '--path', filePath, line, column];\n\n    let result;\n    try {\n      result = await this._process.execFlow(args, options);\n    } catch (e) {\n      result = null;\n    }\n    if (!result) {\n      return null;\n    }\n    const output = result.stdout;\n\n    let json;\n    try {\n      json = (parseJSON(args, output): TypeAtPosOutput);\n    } catch (e) {\n      return null;\n    }\n    const type = json.type;\n    const range = flowCoordsToAtomCoords(json.loc);\n    if (!type || type === '(unknown)') {\n      return null;\n    }\n    let typeString;\n    try {\n      typeString = prettyPrintTypes(type);\n    } catch (e) {\n      logger.error(`Problem pretty printing type hint: ${e.message}`);\n      typeString = type;\n    }\n    return {\n      hint: typeString,\n      range,\n    };\n  }\n\n  async getCoverage(filePath: NuclideUri): Promise<?CoverageResult> {\n    const args = ['coverage', '--json', filePath];\n    let result;\n    try {\n      result = await this._process.execFlow(args, {});\n    } catch (e) {\n      return null;\n    }\n    if (result == null) {\n      return null;\n    }\n    let json;\n    try {\n      json = parseJSON(args, result.stdout);\n    } catch (e) {\n      // The error is already logged in parseJSON\n      return null;\n    }\n\n    const expressions = json.expressions;\n\n    const uncoveredCount = expressions.uncovered_count;\n    const coveredCount = expressions.covered_count;\n    const totalCount = uncoveredCount + coveredCount;\n\n    const uncoveredRegions = expressions.uncovered_locs\n      .map(flowCoordsToAtomCoords)\n      .map(range => ({range}));\n\n    return {\n      percentage: totalCount === 0 ? 100 : coveredCount / totalCount * 100,\n      uncoveredRegions,\n    };\n  }\n\n  async _forceRecheck(file: string): Promise<boolean> {\n    try {\n      await this._process.execFlow(\n        ['force-recheck', file],\n        /* options */ {},\n        // Make an attempt to force a recheck, but if the server is busy don't insist.\n        /* waitsForServer */ false,\n        /* suppressErrors */ true,\n      );\n      return true;\n    } catch (e) {\n      // This command was introduced in Flow v0.23, so silently swallow errors to avoid logspam on\n      // earlier versions, until we want to break support for earlier version.\n      return false;\n    }\n  }\n\n  getOutline(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n  ): Promise<?Outline> {\n    return FlowSingleProjectLanguageService.getOutline(\n      filePath,\n      buffer,\n      this,\n      this._execInfoContainer,\n    );\n  }\n\n  // This static function takes an optional FlowRoot instance so that *if* it is part of a Flow\n  // root, it can use the appropriate flow-bin installation (which may be the only Flow\n  // installation) but if it lives outside of a Flow root, outlining still works using the system\n  // Flow.\n  static async getOutline(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    root: ?FlowSingleProjectLanguageService,\n    execInfoContainer: FlowExecInfoContainer,\n  ): Promise<?Outline> {\n    const json = await FlowSingleProjectLanguageService.flowGetAst(\n      root,\n      buffer.getText(),\n      execInfoContainer,\n    );\n\n    try {\n      return json ? astToOutline(json) : null;\n    } catch (e) {\n      // Traversing the AST is an error-prone process and it's hard to be sure we've handled all the\n      // cases. Fail gracefully if it does not work.\n      logger.error(e);\n      return null;\n    }\n  }\n\n  static async flowGetAst(\n    root: ?FlowSingleProjectLanguageService,\n    currentContents: string,\n    execInfoContainer: FlowExecInfoContainer,\n  ): Promise<any> {\n    const options = {\n      input: currentContents,\n    };\n\n    const flowRootPath = root == null ? null : root.getPathToRoot();\n\n    const args = ['ast'];\n\n    let json;\n    try {\n      const result = await FlowProcess.execFlowClient(\n        args,\n        flowRootPath,\n        execInfoContainer,\n        options,\n      );\n      if (result == null) {\n        return null;\n      }\n      json = parseJSON(args, result.stdout);\n    } catch (e) {\n      logger.warn(e);\n      return null;\n    }\n    return json;\n  }\n\n  formatSource(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    range: atom$Range,\n  ): Promise<?Array<TextEdit>> {\n    throw new Error('Not Yet Implemented');\n  }\n\n  formatEntireFile(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    range: atom$Range,\n  ): Promise<?{\n    newCursor?: number,\n    formatted: string,\n  }> {\n    throw new Error('Not implemented');\n  }\n\n  formatAtPosition(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n    triggerCharacter: string,\n  ): Promise<?Array<TextEdit>> {\n    throw new Error('Not Yet Implemented');\n  }\n\n  findReferences(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n  ): Promise<?FindReferencesReturn> {\n    throw new Error('Not Yet Implemented');\n  }\n\n  getEvaluationExpression(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n  ): Promise<?NuclideEvaluationExpression> {\n    throw new Error('Not implemented');\n  }\n\n  isFileInProject(fileUri: NuclideUri): Promise<boolean> {\n    throw new Error('Not Yet Implemented');\n  }\n}\n\n// FlowSingleProjectLanguageService should satisfy the SingleFileLanguageService interface\n(((null: any): FlowSingleProjectLanguageService): SingleFileLanguageService);\n\nfunction parseJSON(args: Array<any>, value: string): any {\n  try {\n    return JSON.parse(value);\n  } catch (e) {\n    logger.warn(\n      `Invalid JSON result from flow ${args.join(' ')}. JSON:\\n'${value}'.`,\n    );\n    throw e;\n  }\n}\n\n/**\n * Takes an autocomplete item from Flow and returns a valid autocomplete-plus\n * response, as documented here:\n * https://github.com/atom/autocomplete-plus/wiki/Provider-API\n */\nexport function processAutocompleteItem(\n  replacementPrefix: string,\n  flowItem: FlowAutocompleteItem,\n): Completion {\n  // Truncate long types for readability\n  const description =\n    flowItem.type.length < 80\n      ? flowItem.type\n      : flowItem.type.substring(0, 80) + ' ...';\n  let result = {\n    description,\n    displayText: flowItem.name,\n    replacementPrefix,\n  };\n  const funcDetails = flowItem.func_details;\n  if (funcDetails) {\n    // The parameters in human-readable form for use on the right label.\n    const rightParamStrings = funcDetails.params.map(\n      param => `${param.name}: ${param.type}`,\n    );\n    let snippetArgs = `(${getSnippetString(\n      funcDetails.params.map(param => param.name),\n    )})`;\n    let leftLabel = funcDetails.return_type;\n    let rightLabel = `(${rightParamStrings.join(', ')})`;\n    if (!getConfig('functionSnippetShouldIncludeArguments')) {\n      snippetArgs = '';\n      leftLabel = undefined;\n      rightLabel += ` => ${funcDetails.return_type}`;\n    }\n    result = {\n      ...result,\n      leftLabel,\n      rightLabel,\n      snippet: `${flowItem.name}${snippetArgs}`,\n      type: 'function',\n    };\n  } else {\n    result = {\n      ...result,\n      rightLabel: flowItem.type,\n      text: flowItem.name,\n    };\n  }\n  return result;\n}\n\nfunction getSnippetString(paramNames: Array<string>): string {\n  const groupedParams = groupParamNames(paramNames);\n  // The parameters turned into snippet strings.\n  const snippetParamStrings = groupedParams\n    .map(params => params.join(', '))\n    .map((param, i) => `\\${${i + 1}:${param}}`);\n  return snippetParamStrings.join(', ');\n}\n\n/**\n * Group the parameter names so that all of the trailing optional parameters are together with the\n * last non-optional parameter. That makes it easy to ignore the optional parameters, since they\n * will be selected along with the last non-optional parameter and you can just type to overwrite\n * them.\n */\n// Exported for testing\nexport function groupParamNames(\n  paramNames: Array<string>,\n): Array<Array<string>> {\n  // Split the parameters into two groups -- all of the trailing optional paramaters, and the rest\n  // of the parameters. Trailing optional means all optional parameters that have only optional\n  // parameters after them.\n  const [ordinaryParams, trailingOptional] = paramNames.reduceRight(\n    ([ordinary, optional], param) => {\n      // If there have only been optional params so far, and this one is optional, add it to the\n      // list of trailing optional params.\n      if (isOptional(param) && ordinary.length === 0) {\n        optional.unshift(param);\n      } else {\n        ordinary.unshift(param);\n      }\n      return [ordinary, optional];\n    },\n    [[], []],\n  );\n\n  const groupedParams = ordinaryParams.map(param => [param]);\n  const lastParam = groupedParams[groupedParams.length - 1];\n  if (lastParam != null) {\n    lastParam.push(...trailingOptional);\n  } else if (trailingOptional.length > 0) {\n    groupedParams.push(trailingOptional);\n  }\n\n  return groupedParams;\n}\n\nfunction isOptional(param: string): boolean {\n  invariant(param.length > 0);\n  const lastChar = param[param.length - 1];\n  return lastChar === '?';\n}\n\n// This should be immutable, but lacking good immutable data structure implementations, we are just\n// going to mutate it\n// Exported only for testing\nexport type DiagnosticsState = {\n  isInRecheck: boolean,\n  // Stale messages from the last recheck. We still want to display these, but as soon as the\n  // recheck ends we should invalidate them.\n  // invariants: empty if we are not in a recheck, all contained messages have `stale: true`.\n  staleMessages: Map<NuclideUri, Array<FileDiagnosticMessage>>,\n  // All the currently-valid diagnostic messages. During a recheck, incoming messages get\n  // accumulated here.\n  currentMessages: Map<NuclideUri, Array<FileDiagnosticMessage>>,\n  // All the files that need to be updated immediately. May include files that do not exist in\n  // allCurrentMessages, meaning that there are no associated messages and we just need to clear the\n  // previous errors.\n  filesToUpdate: Set<NuclideUri>,\n};\n\n// Exported only for testing\nexport function emptyDiagnosticsState(): DiagnosticsState {\n  return {\n    isInRecheck: false,\n    staleMessages: new Map(),\n    currentMessages: new Map(),\n    filesToUpdate: new Set(),\n  };\n}\n\n// Exported only for testing\nexport function updateDiagnostics(\n  state: DiagnosticsState,\n  // null means we have received a null ide connection (meaning the previous one has gone away)\n  msg: ?PushDiagnosticsMessage,\n): DiagnosticsState {\n  if (msg == null) {\n    return {\n      isInRecheck: false,\n      staleMessages: new Map(),\n      currentMessages: new Map(),\n      filesToUpdate: setUnion(\n        new Set(state.staleMessages.keys()),\n        new Set(state.currentMessages.keys()),\n      ),\n    };\n  }\n  switch (msg.kind) {\n    case 'errors':\n      const newErrors = collateDiagnostics(msg.errors);\n      if (state.isInRecheck) {\n        // Yes we are going to mutate this :(\n        const {currentMessages} = state;\n        for (const [file, newMessages] of newErrors) {\n          let messages = currentMessages.get(file);\n          if (messages == null) {\n            messages = [];\n            currentMessages.set(file, messages);\n          }\n          messages.push(...newMessages);\n        }\n        return {\n          isInRecheck: state.isInRecheck,\n          staleMessages: state.staleMessages,\n          currentMessages,\n          filesToUpdate: new Set(newErrors.keys()),\n        };\n      } else {\n        // Update the files that now have errors, and those that had errors the last time (we need\n        // to make sure to remove errors that no longer exist).\n        const filesToUpdate = setUnion(\n          new Set(newErrors.keys()),\n          new Set(state.currentMessages.keys()),\n        );\n        return {\n          isInRecheck: state.isInRecheck,\n          staleMessages: state.staleMessages,\n          currentMessages: newErrors,\n          filesToUpdate,\n        };\n      }\n    case 'start-recheck':\n      const staleMessages = new Map();\n      for (const [file, oldMessages] of state.currentMessages.entries()) {\n        const messages = oldMessages.map(message => ({\n          ...message,\n          stale: true,\n        }));\n        staleMessages.set(file, messages);\n      }\n      return {\n        isInRecheck: true,\n        staleMessages,\n        currentMessages: new Map(),\n        filesToUpdate: new Set(state.currentMessages.keys()),\n      };\n    case 'end-recheck':\n      return {\n        isInRecheck: false,\n        staleMessages: new Map(),\n        currentMessages: state.currentMessages,\n        filesToUpdate: new Set(state.staleMessages.keys()),\n      };\n    default:\n      // Enforce exhaustiveness\n      (msg.kind: empty);\n      throw new Error(`Unknown message kind ${msg.kind}`);\n  }\n}\n\n// Exported only for testing\nexport function getDiagnosticUpdates(\n  state: DiagnosticsState,\n): Observable<Array<FileDiagnosticMessages>> {\n  const updates = [];\n  for (const file of state.filesToUpdate) {\n    const messages = [\n      ...mapGetWithDefault(state.staleMessages, file, []),\n      ...mapGetWithDefault(state.currentMessages, file, []),\n    ];\n    updates.push({filePath: file, messages});\n  }\n  return Observable.of(updates);\n}\n\nfunction collateDiagnostics(\n  output: FlowStatusOutput,\n): Map<NuclideUri, Array<FileDiagnosticMessage>> {\n  const diagnostics = flowStatusOutputToDiagnostics(output);\n  const filePathToMessages = new Map();\n\n  for (const diagnostic of diagnostics) {\n    const path = diagnostic.filePath;\n    let diagnosticArray = filePathToMessages.get(path);\n    if (!diagnosticArray) {\n      diagnosticArray = [];\n      filePathToMessages.set(path, diagnosticArray);\n    }\n    diagnosticArray.push(diagnostic);\n  }\n  return filePathToMessages;\n}\n"]}