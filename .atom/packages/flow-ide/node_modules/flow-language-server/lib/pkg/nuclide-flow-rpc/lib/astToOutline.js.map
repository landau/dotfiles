{"version":3,"sources":["../../../../src/pkg/nuclide-flow-rpc/lib/astToOutline.js"],"names":["astToOutline","ast","outlineTrees","itemsToTrees","body","items","map","itemToTree","item","extent","getExtent","type","functionOutline","id","name","params","tokenizedText","representativeName","undefined","push","kind","children","paramTokens","value","declarationsTokenizedText","key","exportDeclaration","Boolean","default","topLevelExpressionOutline","typeAliasOutline","variableDeclarationOutline","isDefault","tree","declaration","declarationReducer","textElements","p","index","declarations","properties","obj","elements","left","argument","Error","length","reduce","startPosition","loc","start","line","column","endPosition","end","typeAliasExpression","expressionStatement","expression","specOutline","moduleExportsOutline","assignmentStatement","isModuleExports","right","moduleExportsPropertyOutline","object","property","propName","shorthand","describeOnly","functionName","getFunctionName","callee","isDescribe","isIt","description","getStringLiteralValue","arguments","specBody","getFunctionBody","filter","literal","fn","variableDeclaratorOutline","declarator","init"],"mappings":"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","file":"astToOutline.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport type {Outline, OutlineTree} from 'atom-ide-ui';\n\nimport {Point} from 'simple-text-buffer';\n\nimport {arrayCompact} from 'nuclide-commons/collection';\n\nimport type {TokenizedText} from 'nuclide-commons/tokenized-text';\nimport {\n  keyword,\n  className,\n  method,\n  param,\n  string,\n  whitespace,\n  plain,\n  type,\n} from 'nuclide-commons/tokenized-text';\n\nimport invariant from 'assert';\n\ntype Extent = {\n  startPosition: atom$Point,\n  endPosition: atom$Point,\n};\n\nexport function astToOutline(ast: any): Outline {\n  return {\n    outlineTrees: itemsToTrees(ast.body),\n  };\n}\n\nfunction itemsToTrees(items: Array<any>): Array<OutlineTree> {\n  return arrayCompact(items.map(itemToTree));\n}\n\nfunction itemToTree(item: any): ?OutlineTree {\n  if (item == null) {\n    return null;\n  }\n  const extent = getExtent(item);\n  switch (item.type) {\n    case 'FunctionDeclaration':\n    case 'ArrowFunctionExpression':\n      return functionOutline(\n        item.id != null ? item.id.name : '',\n        item.params,\n        extent,\n      );\n    case 'ClassDeclaration':\n    case 'ClassExpression':\n      const tokenizedText = [keyword('class')];\n      let representativeName = undefined;\n      if (item.id != null) {\n        tokenizedText.push(whitespace(' '), className(item.id.name));\n        representativeName = item.id.name;\n      }\n      return {\n        kind: 'class',\n        tokenizedText,\n        representativeName,\n        children: itemsToTrees(item.body.body),\n        ...extent,\n      };\n    case 'ClassProperty':\n      let paramTokens = [];\n      if (item.value && item.value.type === 'ArrowFunctionExpression') {\n        paramTokens = [\n          plain('('),\n          ...declarationsTokenizedText(item.value.params),\n          plain(')'),\n        ];\n      }\n      return {\n        kind: 'property',\n        tokenizedText: [method(item.key.name), plain('='), ...paramTokens],\n        representativeName: item.key.name,\n        children: [],\n        ...extent,\n      };\n    case 'MethodDefinition':\n      return {\n        kind: 'method',\n        tokenizedText: [\n          method(item.key.name),\n          plain('('),\n          ...declarationsTokenizedText(item.value.params),\n          plain(')'),\n        ],\n        representativeName: item.key.name,\n        children: [],\n        ...extent,\n      };\n    case 'ExportDeclaration':\n    case 'ExportNamedDeclaration':\n      return exportDeclaration(item, extent, Boolean(item.default));\n    case 'ExportDefaultDeclaration':\n      return exportDeclaration(item, extent, true);\n    case 'ExpressionStatement':\n      return topLevelExpressionOutline(item);\n    case 'TypeAlias':\n      return typeAliasOutline(item);\n    case 'VariableDeclaration':\n      return variableDeclarationOutline(item);\n    default:\n      return null;\n  }\n}\n\nfunction exportDeclaration(\n  item: any,\n  extent: Extent,\n  isDefault: boolean,\n): ?OutlineTree {\n  const tree = itemToTree(item.declaration);\n  if (tree == null) {\n    return null;\n  }\n  const tokenizedText = [keyword('export'), whitespace(' ')];\n  if (isDefault) {\n    tokenizedText.push(keyword('default'), whitespace(' '));\n  }\n  // Flow always has tokenizedText\n  invariant(tree.tokenizedText != null);\n  tokenizedText.push(...tree.tokenizedText);\n  return {\n    kind: tree.kind,\n    tokenizedText,\n    representativeName: tree.representativeName,\n    children: tree.children,\n    ...extent,\n  };\n}\n\nfunction declarationReducer(\n  textElements: TokenizedText,\n  p: any,\n  index: number,\n  declarations: Array<any>,\n): TokenizedText {\n  switch (p.type) {\n    case 'Identifier':\n      textElements.push(param(p.name));\n      break;\n    case 'ObjectPattern':\n      textElements.push(plain('{'));\n      textElements.push(\n        ...declarationsTokenizedText(p.properties.map(obj => obj.key)),\n      );\n      textElements.push(plain('}'));\n      break;\n    case 'ArrayPattern':\n      textElements.push(plain('['));\n      textElements.push(...declarationsTokenizedText(p.elements));\n      textElements.push(plain(']'));\n      break;\n    case 'AssignmentPattern':\n      return declarationReducer(textElements, p.left, index, declarations);\n    case 'RestElement':\n      textElements.push(plain('...'));\n      return declarationReducer(textElements, p.argument, index, declarations);\n    default:\n      throw new Error(`encountered unexpected argument type ${p.type}`);\n  }\n  if (index < declarations.length - 1) {\n    textElements.push(plain(','));\n    textElements.push(whitespace(' '));\n  }\n  return textElements;\n}\n\nfunction declarationsTokenizedText(declarations: Array<any>): TokenizedText {\n  return declarations.reduce(declarationReducer, []);\n}\n\nfunction getExtent(item: any): Extent {\n  return {\n    startPosition: new Point(\n      // It definitely makes sense that the lines we get are 1-based and the columns are\n      // 0-based... convert to 0-based all around.\n      item.loc.start.line - 1,\n      item.loc.start.column,\n    ),\n    endPosition: new Point(item.loc.end.line - 1, item.loc.end.column),\n  };\n}\n\nfunction functionOutline(\n  name: string,\n  params: Array<any>,\n  extent: Extent,\n): OutlineTree {\n  return {\n    kind: 'function',\n    tokenizedText: [\n      keyword('function'),\n      whitespace(' '),\n      method(name),\n      plain('('),\n      ...declarationsTokenizedText(params),\n      plain(')'),\n    ],\n    representativeName: name,\n    children: [],\n    ...extent,\n  };\n}\n\nfunction typeAliasOutline(typeAliasExpression: any): OutlineTree {\n  invariant(typeAliasExpression.type === 'TypeAlias');\n  const name = typeAliasExpression.id.name;\n  return {\n    kind: 'interface',\n    tokenizedText: [keyword('type'), whitespace(' '), type(name)],\n    representativeName: name,\n    children: [],\n    ...getExtent(typeAliasExpression),\n  };\n}\n\nfunction topLevelExpressionOutline(expressionStatement: any): ?OutlineTree {\n  switch (expressionStatement.expression.type) {\n    case 'CallExpression':\n      return specOutline(expressionStatement, /* describeOnly */ true);\n    case 'AssignmentExpression':\n      return moduleExportsOutline(expressionStatement.expression);\n    default:\n      return null;\n  }\n}\n\nfunction moduleExportsOutline(assignmentStatement: any): ?OutlineTree {\n  invariant(assignmentStatement.type === 'AssignmentExpression');\n\n  const left = assignmentStatement.left;\n  if (!isModuleExports(left)) {\n    return null;\n  }\n\n  const right = assignmentStatement.right;\n  if (right.type !== 'ObjectExpression') {\n    return null;\n  }\n  const properties: Array<Object> = right.properties;\n  return {\n    kind: 'module',\n    tokenizedText: [plain('module.exports')],\n    children: arrayCompact(properties.map(moduleExportsPropertyOutline)),\n    ...getExtent(assignmentStatement),\n  };\n}\n\nfunction isModuleExports(left: Object): boolean {\n  return (\n    left.type === 'MemberExpression' &&\n    left.object.type === 'Identifier' &&\n    left.object.name === 'module' &&\n    left.property.type === 'Identifier' &&\n    left.property.name === 'exports'\n  );\n}\n\nfunction moduleExportsPropertyOutline(property: any): ?OutlineTree {\n  invariant(property.type === 'Property');\n  if (property.key.type !== 'Identifier') {\n    return null;\n  }\n  const propName = property.key.name;\n\n  if (property.shorthand) {\n    // This happens when the shorthand `{ foo }` is used for `{ foo: foo }`\n    return {\n      kind: 'method',\n      tokenizedText: [string(propName)],\n      representativeName: propName,\n      children: [],\n      ...getExtent(property),\n    };\n  }\n\n  if (\n    property.value.type === 'FunctionExpression' ||\n    property.value.type === 'ArrowFunctionExpression'\n  ) {\n    return {\n      kind: 'method',\n      tokenizedText: [\n        method(propName),\n        plain('('),\n        ...declarationsTokenizedText(property.value.params),\n        plain(')'),\n      ],\n      representativeName: propName,\n      children: [],\n      ...getExtent(property),\n    };\n  }\n\n  return {\n    kind: 'field',\n    tokenizedText: [string(propName), plain(':')],\n    representativeName: propName,\n    children: [],\n    ...getExtent(property),\n  };\n}\n\nfunction specOutline(\n  expressionStatement: any,\n  describeOnly: boolean = false,\n): ?OutlineTree {\n  const expression = expressionStatement.expression;\n  if (expression.type !== 'CallExpression') {\n    return null;\n  }\n  const functionName = getFunctionName(expression.callee);\n  if (functionName == null) {\n    return null;\n  }\n  if (!isDescribe(functionName)) {\n    if (describeOnly || !isIt(functionName)) {\n      return null;\n    }\n  }\n  const description = getStringLiteralValue(expression.arguments[0]);\n  const specBody = getFunctionBody(expression.arguments[1]);\n  if (description == null || specBody == null) {\n    return null;\n  }\n  let children;\n  if (isIt(functionName)) {\n    children = [];\n  } else {\n    children = arrayCompact(\n      specBody\n        .filter(item => item.type === 'ExpressionStatement')\n        .map(item => specOutline(item)),\n    );\n  }\n  return {\n    kind: 'function',\n    tokenizedText: [method(functionName), whitespace(' '), string(description)],\n    representativeName: description,\n    children,\n    ...getExtent(expressionStatement),\n  };\n}\n\n// Return the function name as written as a string. Intended to stringify patterns like `describe`\n// and `describe.only` even though `describe.only` is a MemberExpression rather than an Identifier.\nfunction getFunctionName(callee: any): ?string {\n  switch (callee.type) {\n    case 'Identifier':\n      return callee.name;\n    case 'MemberExpression':\n      if (\n        callee.object.type !== 'Identifier' ||\n        callee.property.type !== 'Identifier'\n      ) {\n        return null;\n      }\n      return `${callee.object.name}.${callee.property.name}`;\n    default:\n      return null;\n  }\n}\n\nfunction isDescribe(functionName: string): boolean {\n  switch (functionName) {\n    case 'describe':\n    case 'fdescribe':\n    case 'ddescribe':\n    case 'xdescribe':\n    case 'describe.only':\n    case 'describe.skip':\n    case 'test.cb':\n    case 'test.serial':\n    case 'test.todo':\n    case 'test.failing':\n    case 'test':\n    case 'test.concurrent':\n    case 'test.only':\n    case 'test.skip':\n    case 'suite':\n    case 'suite.only':\n    case 'suite.skip':\n    case 'xtest':\n    case 'xtest.concurrent':\n    case 'xtest.only':\n    case 'xtest.skip':\n      return true;\n    default:\n      return false;\n  }\n}\n\nfunction isIt(functionName: string): boolean {\n  switch (functionName) {\n    case 'it':\n    case 'fit':\n    case 'iit':\n    case 'pit':\n    case 'xit':\n    case 'it.only':\n    case 'it.skip':\n      return true;\n    default:\n      return false;\n  }\n}\n\n/** If the given AST Node is a string literal, return its literal value. Otherwise return null */\nfunction getStringLiteralValue(literal: ?any): ?string {\n  if (literal == null) {\n    return null;\n  }\n  if (literal.type !== 'Literal') {\n    return null;\n  }\n  const value = literal.value;\n  if (typeof value !== 'string') {\n    return null;\n  }\n  return value;\n}\n\nfunction getFunctionBody(fn: ?any): ?Array<any> {\n  if (fn == null) {\n    return null;\n  }\n  if (\n    fn.type !== 'ArrowFunctionExpression' &&\n    fn.type !== 'FunctionExpression'\n  ) {\n    return null;\n  }\n  return fn.body.body;\n}\n\nfunction variableDeclarationOutline(declaration: any): ?OutlineTree {\n  // If there are multiple var declarations in one line, just take the first.\n  return variableDeclaratorOutline(\n    declaration.declarations[0],\n    declaration.kind,\n    getExtent(declaration),\n  );\n}\n\nfunction variableDeclaratorOutline(\n  declarator: any,\n  kind: string,\n  extent: Extent,\n): ?OutlineTree {\n  if (\n    declarator.init != null &&\n    (declarator.init.type === 'FunctionExpression' ||\n      declarator.init.type === 'ArrowFunctionExpression')\n  ) {\n    return functionOutline(declarator.id.name, declarator.init.params, extent);\n  }\n\n  const {id} = declarator;\n\n  const tokenizedText = [\n    keyword(kind),\n    whitespace(' '),\n    ...declarationsTokenizedText([id]),\n  ];\n  const representativeName = id.type === 'Identifier' ? id.name : undefined;\n  return {\n    kind: kind === 'const' ? 'constant' : 'variable',\n    tokenizedText,\n    representativeName,\n    children: [],\n    ...extent,\n  };\n}\n"]}