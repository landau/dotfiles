{"version":3,"sources":["../../../../src/pkg/nuclide-flow-rpc/lib/diagnosticsParser.js"],"names":["flowStatusOutputToDiagnostics","diagnosticToFix","extractRange","BUILTIN_LOCATION","statusOutput","errors","map","flowMessageToDiagnosticMessage","diagnostic","fixExtractionFunctions","extractionFunction","fix","unusedSuppressionFix","namedImportTypo","trace","length","text","oldRange","range","newText","speculative","traceText","test","regex","match","exec","oldText","extractPath","message","loc","source","undefined","flowMessageToTrace","type","descr","filePath","flowStatusError","flowMessageComponents","mainMessage","path","find","extractedPath","diagnosticMessage","scope","providerName","level","extractTraces","push","slice","operation","operationComponent","extra","flatExtra","concat","start","line","column","end"],"mappings":"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","file":"diagnosticsParser.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport type {\n  DiagnosticFix,\n  DiagnosticTrace,\n  FileDiagnosticMessage,\n} from 'atom-ide-ui';\nimport type {NuclideUri} from 'nuclide-commons/nuclideUri';\n\nimport type {\n  FlowStatusOutput,\n  FlowStatusError,\n  FlowStatusErrorMessageComponent,\n} from './flowOutputTypes';\n\nimport invariant from 'assert';\nimport {Range} from 'simple-text-buffer';\n\n// Flow sometimes reports this as the file path for an error. When this happens, we should simply\n// leave out the location, since it isn't very useful and it's not a well-formed path, which can\n// cause issues down the line.\nconst BUILTIN_LOCATION = '(builtins)';\n\nexport function flowStatusOutputToDiagnostics(\n  statusOutput: FlowStatusOutput,\n): Array<FileDiagnosticMessage> {\n  return statusOutput.errors.map(flowMessageToDiagnosticMessage);\n}\n\n// Exported for testing\nexport function diagnosticToFix(\n  diagnostic: FileDiagnosticMessage,\n): ?DiagnosticFix {\n  for (const extractionFunction of fixExtractionFunctions) {\n    const fix = extractionFunction(diagnostic);\n    if (fix != null) {\n      return fix;\n    }\n  }\n\n  return null;\n}\n\nconst fixExtractionFunctions: Array<\n  (diagnostic: FileDiagnosticMessage) => ?DiagnosticFix,\n> = [unusedSuppressionFix, namedImportTypo];\n\nfunction unusedSuppressionFix(\n  diagnostic: FileDiagnosticMessage,\n): ?DiagnosticFix {\n  // Automatically remove unused suppressions:\n  if (\n    diagnostic.trace != null &&\n    diagnostic.trace.length === 1 &&\n    diagnostic.text === 'Error suppressing comment' &&\n    diagnostic.trace[0].text === 'Unused suppression'\n  ) {\n    const oldRange = diagnostic.range;\n    invariant(oldRange != null);\n    return {\n      newText: '',\n      oldRange,\n      speculative: true,\n    };\n  }\n\n  return null;\n}\n\nfunction namedImportTypo(diagnostic: FileDiagnosticMessage): ?DiagnosticFix {\n  const trace = diagnostic.trace;\n  const text = diagnostic.text;\n  if (trace == null || trace.length !== 1 || text == null) {\n    return null;\n  }\n  const traceText = trace[0].text;\n  if (traceText == null) {\n    return null;\n  }\n\n  if (!/^Named import from module `[^`]*`$/.test(text)) {\n    return null;\n  }\n\n  const regex = /^This module has no named export called `([^`]*)`. Did you mean `([^`]*)`\\?$/;\n  const match = regex.exec(traceText);\n  if (match == null) {\n    return null;\n  }\n\n  const oldText = match[1];\n  const newText = match[2];\n  const oldRange = diagnostic.range;\n  invariant(oldRange != null);\n\n  return {\n    oldText,\n    newText,\n    oldRange,\n    speculative: true,\n  };\n}\n\n/**\n * Currently, a diagnostic from Flow is an object with a \"message\" property.\n * Each item in the \"message\" array is an object with the following fields:\n *     - path (string) File that contains the error.\n *     - descr (string) Description of the error.\n *     - line (number) Start line.\n *     - endline (number) End line.\n *     - start (number) Start column.\n *     - end (number) End column.\n *     - code (number) Presumably an error code.\n * The message array may have more than one item. For example, if there is a\n * type incompatibility error, the first item in the message array blames the\n * usage of the wrong type and the second blames the declaration of the type\n * with which the usage disagrees. Note that these could occur in different\n * files.\n */\n\nfunction extractPath(\n  message: FlowStatusErrorMessageComponent,\n): NuclideUri | void {\n  if (message.loc == null || message.loc.source === BUILTIN_LOCATION) {\n    return undefined;\n  }\n  return message.loc.source;\n}\n\n// A trace object is very similar to an error object.\nfunction flowMessageToTrace(\n  message: FlowStatusErrorMessageComponent,\n): DiagnosticTrace {\n  return {\n    type: 'Trace',\n    text: message.descr,\n    filePath: extractPath(message),\n    range: extractRange(message),\n  };\n}\n\nfunction flowMessageToDiagnosticMessage(flowStatusError: FlowStatusError) {\n  const flowMessageComponents: Array<FlowStatusErrorMessageComponent> =\n    flowStatusError.message;\n\n  const mainMessage = flowMessageComponents[0];\n\n  // The Flow type does not capture this, but the first message always has a path, and the\n  // diagnostics package requires a FileDiagnosticMessage to have a path.\n  const path = flowMessageComponents\n    .map(extractPath)\n    .find(extractedPath => extractedPath != null);\n  invariant(path != null, 'Expected path to not be null or undefined');\n\n  const diagnosticMessage: FileDiagnosticMessage = {\n    scope: 'file',\n    providerName: 'Flow',\n    type: flowStatusError.level === 'error' ? 'Error' : 'Warning',\n    text: mainMessage.descr,\n    filePath: path,\n    range: extractRange(mainMessage),\n    trace: extractTraces(flowStatusError),\n  };\n\n  const fix = diagnosticToFix(diagnosticMessage);\n  if (fix != null) {\n    diagnosticMessage.fix = fix;\n  }\n\n  return diagnosticMessage;\n}\n\nfunction extractTraces(\n  flowStatusError: FlowStatusError,\n): Array<DiagnosticTrace> | void {\n  const flowMessageComponents: Array<FlowStatusErrorMessageComponent> =\n    flowStatusError.message;\n\n  const trace: Array<DiagnosticTrace> = [];\n  // When the message is an array with multiple elements, the second element\n  // onwards comprise the trace for the error.\n  if (flowMessageComponents.length > 1) {\n    trace.push(...flowMessageComponents.slice(1).map(flowMessageToTrace));\n  }\n\n  const operation = flowStatusError.operation;\n  if (operation != null) {\n    const operationComponent = flowMessageToTrace(operation);\n    invariant(operationComponent.text != null);\n    operationComponent.text = 'See also: ' + operationComponent.text;\n    trace.push(operationComponent);\n  }\n  const extra = flowStatusError.extra;\n  if (extra != null) {\n    const flatExtra = [].concat(...extra.map(({message}) => message));\n    trace.push(...flatExtra.map(flowMessageToTrace));\n  }\n\n  if (trace.length > 0) {\n    return trace;\n  } else {\n    return undefined;\n  }\n}\n\n// Use `atom$Range | void` rather than `?atom$Range` to exclude `null`, so that the type is\n// compatible with the `range` property, which is an optional property rather than a nullable\n// property.\nexport function extractRange(\n  message: FlowStatusErrorMessageComponent,\n): atom$Range | void {\n  if (message.loc == null || message.loc.source === BUILTIN_LOCATION) {\n    return undefined;\n  } else {\n    // It's unclear why the 1-based to 0-based indexing works the way that it\n    // does, but this has the desired effect in the UI, in practice.\n    return new Range(\n      [message.loc.start.line - 1, message.loc.start.column - 1],\n      [message.loc.end.line - 1, message.loc.end.column],\n    );\n  }\n}\n"]}