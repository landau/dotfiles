{"version":3,"sources":["../../../../src/pkg/nuclide-flow-rpc/lib/prettyPrintTypes.js"],"names":["prettyPrintTypes","openGroup","closeGroup","separator","last","arr","length","parseGroups","str","rootGroup","elements","start","end","groups","isExact","exactChar","openChar","closeChar","parentGroup","currentGroup","i","pushGroup","group","indexOf","push","currentElement","popGroup","Error","pushElement","lastElement","printGroups","max","getIndent","indent","repeat","printMultiLineGroup","output","forEach","element","printElement","printSingleLineGroupWithoutEnforcingChildren","childGroup","trim","printSingleLineGroup","printGroup","singleLine","singleLinePrint","current","slice","trimLeft","isGroupValid","j"],"mappings":"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","file":"prettyPrintTypes.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\n/**\n * This is a pretty printer that doesn't understand the actual syntax of the\n * language but just enough to figure out what groups and separators are.\n *\n * The idea is that it's going to try and pretty-print all the groups inline,\n * but if the rendered version is more than 40 characters, then write each\n * element on its own line and indent it.\n *\n * For example,\n *\n *   {editor: atom$TextEditor, position: {column: number, row: number}}\n *\n * is pretty printed as\n *\n *   {\n *     editor: atom$TextEditor,\n *     position: {column: number, row: number}\n *   }\n *\n * The group `{column: number, row: number}` is less than 40 characters so is\n * printed inline but the outer group would be more than 40 characters so each\n * element is printed line by line and indented.\n *\n * Note that this is just an heuristic that tends to work well in most cases.\n * It is not going to be perfect all the time!\n *\n * In case an input cannot be parsed based on this grammar, it's going to return\n * the input unchanged.\n */\n\nconst openGroup = '[{(<';\nconst closeGroup = ']})>';\nconst separator = ',;';\n\nfunction last(arr) {\n  return arr[arr.length - 1];\n}\n\ntype Element = {\n  start: number,\n  end: number,\n  groups: Array<Group>,\n};\n\ntype Group = {\n  elements: Array<Element>,\n  openChar: string,\n  closeChar: string,\n  exactChar: '|' | '',\n  isExact: boolean,\n  start: number,\n  end: number,\n  parentGroup: ?Group,\n};\n\nfunction parseGroups(str) {\n  const rootGroup: Group = {\n    elements: [{start: 0, end: -1, groups: []}],\n    isExact: false,\n    exactChar: '',\n    openChar: '',\n    closeChar: '',\n    start: 0,\n    end: str.length - 1,\n    parentGroup: null,\n  };\n\n  let currentGroup: Group = rootGroup;\n  let i = 0;\n\n  function pushGroup(isExact: boolean) {\n    const group = {\n      start: i,\n      end: -1,\n      openChar: str[i],\n      closeChar: closeGroup[openGroup.indexOf(str[i])],\n      exactChar: isExact ? '|' : '',\n      isExact,\n      elements: [],\n      parentGroup: currentGroup,\n    };\n    if (isExact) {\n      i++;\n    }\n    group.elements.push({start: i + 1, end: -1, groups: []});\n    const currentElement = last(currentGroup.elements);\n    currentElement.groups.push(group);\n    currentGroup = group;\n  }\n\n  function popGroup() {\n    const isExact = currentGroup.isExact;\n    const currentElement = last(currentGroup.elements);\n    currentElement.end = isExact ? i - 1 : i;\n    currentGroup.end = i + 1;\n    const parentGroup = currentGroup.parentGroup;\n    if (!parentGroup) {\n      throw new Error(\"parentGroup shouldn't be null\");\n    }\n    currentGroup = parentGroup;\n  }\n\n  function pushElement() {\n    const currentElement = last(currentGroup.elements);\n    currentElement.end = i + 1;\n    currentGroup.elements.push({start: i + 1, end: -1, groups: []});\n  }\n\n  for (; i < str.length; ++i) {\n    if (openGroup.indexOf(str[i]) !== -1) {\n      pushGroup(str[i] === '{' && str[i + 1] === '|');\n    }\n\n    if (\n      closeGroup.indexOf(str[i]) !== -1 &&\n      currentGroup.closeChar === str[i]\n    ) {\n      popGroup();\n    }\n\n    if (currentGroup !== rootGroup && separator.indexOf(str[i]) !== -1) {\n      pushElement();\n    }\n  }\n  const lastElement = last(currentGroup.elements);\n  lastElement.end = i;\n\n  return rootGroup;\n}\n\nfunction printGroups(str, rootGroup, max) {\n  function getIndent(indent) {\n    if (indent < 0) {\n      return '';\n    }\n    return '  '.repeat(indent);\n  }\n\n  function printMultiLineGroup(group, indent) {\n    let output = group.openChar + group.exactChar + '\\n';\n    group.elements.forEach(element => {\n      output += printElement(element, indent + 1, /* singleLine */ false);\n    });\n    output += getIndent(indent) + group.exactChar + group.closeChar;\n    return output;\n  }\n\n  function printSingleLineGroupWithoutEnforcingChildren(group, indent) {\n    let output = group.openChar + group.exactChar;\n    group.elements.forEach(childGroup => {\n      output += printElement(childGroup, indent, /* singleLine */ false).trim();\n    });\n    return output + group.exactChar + group.closeChar;\n  }\n\n  function printSingleLineGroup(group, indent) {\n    let output = group.openChar + group.exactChar;\n    group.elements.forEach(childGroup => {\n      output += printElement(childGroup, indent, /* singleLine */ true);\n    });\n    return output + group.exactChar + group.closeChar;\n  }\n\n  function printGroup(group, indent, singleLine) {\n    const singleLinePrint = printSingleLineGroup(group, indent);\n    if (singleLine || singleLinePrint.length < max) {\n      return singleLinePrint;\n    }\n    if (group.elements.length === 1) {\n      return printSingleLineGroupWithoutEnforcingChildren(group, indent);\n    }\n    return printMultiLineGroup(group, indent);\n  }\n\n  function printElement(element, indent, singleLine) {\n    let output = '';\n    let current = element.start;\n    element.groups.forEach(group => {\n      output += str.slice(current, group.start);\n      current = group.end;\n      output += printGroup(group, indent, singleLine);\n    });\n    output += str.slice(current, element.end);\n    if (singleLine) {\n      return output;\n    }\n    return getIndent(indent) + output.trimLeft() + '\\n';\n  }\n\n  return printMultiLineGroup(rootGroup, -1).slice('\\n'.length, -'\\n'.length);\n}\n\nfunction isGroupValid(group) {\n  if (group.end === -1) {\n    return false;\n  }\n  delete group.parentGroup;\n  for (let i = 0; i < group.elements.length; ++i) {\n    const element = group.elements[i];\n    if (element.end === -1) {\n      return false;\n    }\n    for (let j = 0; j < element.groups.length; ++j) {\n      if (!isGroupValid(element.groups[j])) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nexport default function prettyPrintTypes(\n  str: string,\n  max: number = 40,\n): string {\n  const rootGroup = parseGroups(str);\n  if (!isGroupValid(rootGroup)) {\n    return str;\n  }\n  return printGroups(str, rootGroup, max);\n}\n"]}