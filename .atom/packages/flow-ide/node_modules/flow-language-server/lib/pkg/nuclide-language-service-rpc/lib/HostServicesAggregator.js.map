{"version":3,"sources":["../../../../src/pkg/nuclide-language-service-rpc/lib/HostServicesAggregator.js"],"names":["host","logger","child","HostServicesAggregator","howChildShouldRelayBackToHost","childRegister","initialize","forkHostServices","_childRelays","Map","_counter","parent","_parent","_logger","relay","HostServicesRelay","set","_selfRelay","get","consoleNotification","source","level","text","dialogNotification","dialogRequest","buttonLabels","closeLabel","dispose","_childIsDisposed","next","values","_child","constructor","aggregator","id","_aggregator","_id","refCount","takeUntil","publish","delete"],"mappings":"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","file":"HostServicesAggregator.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport type {ShowNotificationLevel, HostServices} from './rpc-types';\n\nimport invariant from 'assert';\nimport {Subject, ConnectableObservable} from 'rxjs';\n\n// This is how we declare in Flow that a type fulfills an interface.\n(((null: any): HostServicesAggregator): HostServices);\n(((null: any): HostServicesRelay): HostServices);\n\nexport async function forkHostServices(\n  host: HostServices,\n  logger: log4js$Logger,\n): Promise<HostServices> {\n  const child = new HostServicesAggregator();\n  const howChildShouldRelayBackToHost = await host.childRegister(child);\n  child.initialize(howChildShouldRelayBackToHost, logger);\n  return child;\n\n  // Here's an example tree of forked aggregators, with a vertical line to show\n  // client-side objects on the left and server-side objects on the right.\n  //\n  // root            |\n  //   <-> relayR0   |\n  //   <-> relayR1 <-|-> aggregator\n  //                 |    <-> relayA0\n  //                 |    <-> relayA1 <-> child1\n  //                 |    <-> relayA2 <-> child2\n  //\n  // If you call child1.consoleNotification(), it forwards to relayA1, which\n  // forwards it on to relayR1. The buck stops at the root which is responsible\n  // for displaying it.\n  //\n  // We also offer the same HostServices API on aggregator itself.\n  // If you call aggregator.consoleNotification() it just dispatches to relayA0,\n  // which behaves identically to relayA1 above. (We use relayA0 here, rather\n  // than handling the call inside aggregator itself, to avoid code duplication)\n  //\n  // If you dispose child1, it relays news of its disposal via relayA1, which\n  // removes it from aggregator's list of children.\n  //\n  // If you dispose aggregator, it disposes all of its remaining children, and\n  // relays news of its disposal via relayR1, which removes it from root's\n  // list of children.\n  //\n  // The call to 'root.childRegister(aggregator)' is what creates relayR1.\n  // This call might be across nuclide-rpc, which is why childRegister has to\n  // return a promise.\n  //\n  // Why do we use relays? so that each child can relay messages to its parent\n  // aggregator, and so the parent aggregator can know which child that message\n  // was relayed from, and so we can do all this without lots of duplicate\n  // methods in the HostServices interface.\n}\n\nclass HostServicesAggregator {\n  _parent: HostServices;\n  _childRelays: Map<number, HostServicesRelay> = new Map();\n  _counter: number = 0;\n  _logger: log4js$Logger;\n\n  initialize(parent: HostServices, logger: log4js$Logger): void {\n    this._parent = parent;\n    this._logger = logger;\n    const relay = new HostServicesRelay(this, 0, null);\n    this._childRelays.set(0, relay);\n  }\n\n  _selfRelay(): HostServicesRelay {\n    const relay = this._childRelays.get(0);\n    invariant(relay != null);\n    return relay;\n  }\n\n  consoleNotification(\n    source: string,\n    level: ShowNotificationLevel,\n    text: string,\n  ): void {\n    this._selfRelay().consoleNotification(source, level, text);\n  }\n\n  dialogNotification(\n    level: ShowNotificationLevel,\n    text: string,\n  ): ConnectableObservable<void> {\n    return this._selfRelay().dialogNotification(level, text);\n  }\n\n  dialogRequest(\n    level: ShowNotificationLevel,\n    text: string,\n    buttonLabels: Array<string>,\n    closeLabel: string,\n  ): ConnectableObservable<string> {\n    return this._selfRelay().dialogRequest(\n      level,\n      text,\n      buttonLabels,\n      closeLabel,\n    );\n  }\n\n  dispose(): void {\n    // Folks call this \"dispose\" method to dispose of the aggregate and\n    // all of its children.\n    this._selfRelay()._childIsDisposed.next();\n    for (const relay of this._childRelays.values()) {\n      if (relay._child != null) {\n        relay._child.dispose();\n      }\n    }\n    // We'll throw a runtime exception upon any operations after dispose.\n    this._childRelays = ((null: any): Map<number, HostServicesRelay>);\n    this._parent.dispose();\n  }\n\n  async childRegister(child: HostServices): Promise<HostServices> {\n    this._counter++;\n    const relay = new HostServicesRelay(this, this._counter, child);\n    this._childRelays.set(this._counter, relay);\n    return relay;\n  }\n}\n\nclass HostServicesRelay {\n  _aggregator: HostServicesAggregator;\n  _id: number;\n  //\n  _child: ?HostServices;\n  _childIsDisposed: Subject<void> = new Subject(); // signal by sending next().\n\n  constructor(\n    aggregator: HostServicesAggregator,\n    id: number,\n    child: ?HostServices,\n  ) {\n    this._aggregator = aggregator;\n    this._id = id;\n    this._child = child;\n  }\n\n  consoleNotification(\n    source: string,\n    level: ShowNotificationLevel,\n    text: string,\n  ): void {\n    this._aggregator._parent.consoleNotification(source, level, text);\n  }\n\n  dialogNotification(\n    level: ShowNotificationLevel,\n    text: string,\n  ): ConnectableObservable<void> {\n    return this._aggregator._parent\n      .dialogNotification(level, text)\n      .refCount()\n      .takeUntil(this._childIsDisposed)\n      .publish();\n    // If the host is disposed, then the ConnectedObservable we return will\n    // complete without ever having emitted a value. If you .toPromise on it\n    // your promise will complete successfully with value 'undefined'.\n  }\n\n  dialogRequest(\n    level: ShowNotificationLevel,\n    text: string,\n    buttonLabels: Array<string>,\n    closeLabel: string,\n  ): ConnectableObservable<string> {\n    return this._aggregator._parent\n      .dialogRequest(level, text, buttonLabels, closeLabel)\n      .refCount()\n      .takeUntil(this._childIsDisposed)\n      .publish();\n  }\n\n  dispose(): void {\n    // Remember, this is a notification relayed from one of the children that\n    // it has just finished its \"dispose\" method. That's what a relay is.\n    // It is *NOT* a means to dispose of this relay\n    this._childIsDisposed.next();\n    this._aggregator._childRelays.delete(this._id);\n  }\n\n  childRegister(child: HostServices): Promise<HostServices> {\n    invariant(false, 'relay should never be asked to relay childRegister');\n  }\n}\n"]}