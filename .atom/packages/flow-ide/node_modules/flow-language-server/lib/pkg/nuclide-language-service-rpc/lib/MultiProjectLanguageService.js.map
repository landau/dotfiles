{"version":3,"sources":["../../../../src/pkg/nuclide-language-service-rpc/lib/MultiProjectLanguageService.js"],"names":["MultiProjectLanguageService","constructor","_observeDiagnosticsPromise","Promise","resolve","reject","_observeDiagnosticsPromiseResolver","initialize","logger","fileCache","host","projectFileName","fileExtensions","languageServiceFactory","_logger","_resources","_configCache","_processes","value","then","process","dispose","add","configObserver","filePath","getConfigDir","observeConfigs","subscribe","configs","_ensureProcesses","_closeProcesses","observeFileEvents","ignoreElements","undefined","info","findProjectDir","_getLanguageServiceForFile","service","getLanguageServiceForFile","_getLanguageServicesForFiles","filePaths","promises","map","fileServices","all","results","Array","from","projectDir","get","result","delete","configPaths","join","setKeys","keys","clear","observeLanguageServices","observeValues","switchMap","fromPromise","getAllLanguageServices","lsPromises","values","getDiagnostics","fileVersion","hasObservedDiagnostics","observeDiagnostics","mergeMap","trace","refCount","catch","error","empty","publish","getAutocompleteSuggestions","position","activatedManually","prefix","getDefinition","findReferences","getCoverage","getOutline","typeHint","highlight","formatSource","range","formatEntireFile","formatAtPosition","triggerCharacter","getEvaluationExpression","supportsSymbolSearch","directories","serviceDirectories","eligibilities","dirs","some","e","symbolSearch","query","length","getProjectRoot","isFileInProject"],"mappings":"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","file":"MultiProjectLanguageService.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport type {NuclideUri} from 'nuclide-commons/nuclideUri';\nimport type {FileVersion} from '../../nuclide-open-files-rpc/lib/rpc-types';\nimport type {TextEdit} from 'nuclide-commons-atom/text-edit';\nimport type {TypeHint} from '../../nuclide-type-hint/lib/rpc-types';\nimport type {CoverageResult} from '../../nuclide-type-coverage/lib/rpc-types';\nimport type {\n  DefinitionQueryResult,\n  DiagnosticProviderUpdate,\n  FileDiagnosticMessages,\n  FindReferencesReturn,\n  Outline,\n} from 'atom-ide-ui';\nimport type {\n  AutocompleteResult,\n  SymbolResult,\n  LanguageService,\n} from '../../nuclide-language-service/lib/LanguageService';\nimport type {HostServices} from '../../nuclide-language-service-rpc/lib/rpc-types';\nimport type {NuclideEvaluationExpression} from '../../nuclide-debugger-interfaces/rpc-types';\nimport type {ConnectableObservable} from 'rxjs';\n\nimport {FileCache, ConfigObserver} from '../../nuclide-open-files-rpc';\nimport {Cache} from 'nuclide-commons/cache';\nimport {Observable} from 'rxjs';\nimport UniversalDisposable from 'nuclide-commons/UniversalDisposable';\nimport {compact} from 'nuclide-commons/observable';\nimport {arrayCompact, arrayFlatten, collect} from 'nuclide-commons/collection';\nimport {ConfigCache} from 'nuclide-commons/ConfigCache';\nimport {ensureInvalidations, NullLanguageService} from '..';\n\nexport class MultiProjectLanguageService<T: LanguageService = LanguageService> {\n  // Maps project dir => LanguageService\n  _processes: Cache<NuclideUri, Promise<?T>>;\n  _resources: UniversalDisposable;\n  _configCache: ConfigCache;\n  _logger: log4js$Logger;\n  // A promise for when AtomLanguageService has called into this feature\n  _observeDiagnosticsPromise: Promise<void>;\n  _observeDiagnosticsPromiseResolver: () => void;\n\n  constructor() {\n    this._observeDiagnosticsPromise = new Promise((resolve, reject) => {\n      this._observeDiagnosticsPromiseResolver = resolve;\n    });\n  }\n\n  initialize(\n    logger: log4js$Logger,\n    fileCache: FileCache,\n    host: HostServices,\n    projectFileName: string,\n    fileExtensions: Array<NuclideUri>,\n    languageServiceFactory: (projectDir: NuclideUri) => Promise<?T>,\n  ) {\n    this._logger = logger;\n    this._resources = new UniversalDisposable();\n    this._configCache = new ConfigCache([projectFileName]);\n\n    this._processes = new Cache(languageServiceFactory, value => {\n      value.then(process => {\n        if (process != null) {\n          process.dispose();\n        }\n      });\n    });\n\n    this._resources.add(host, this._processes);\n\n    // Observe projects as they are opened\n    const configObserver = new ConfigObserver(\n      fileCache,\n      fileExtensions,\n      filePath => this._configCache.getConfigDir(filePath),\n    );\n    this._resources.add(\n      configObserver,\n      configObserver.observeConfigs().subscribe(configs => {\n        this._ensureProcesses(configs);\n      }),\n    );\n    this._resources.add(() => {\n      this._closeProcesses();\n    });\n\n    // Remove fileCache when the remote connection shuts down\n    this._resources.add(\n      fileCache\n        .observeFileEvents()\n        .ignoreElements()\n        .subscribe(\n          undefined, // next\n          undefined, // error\n          () => {\n            this._logger.info('fileCache shutting down.');\n            this._closeProcesses();\n          },\n        ),\n    );\n  }\n\n  findProjectDir(filePath: NuclideUri): Promise<?NuclideUri> {\n    return this._configCache.getConfigDir(filePath);\n  }\n\n  async _getLanguageServiceForFile(filePath: string): Promise<LanguageService> {\n    const service = await this.getLanguageServiceForFile(filePath);\n    if (service != null) {\n      return service;\n    } else {\n      return new NullLanguageService();\n    }\n  }\n\n  async _getLanguageServicesForFiles(\n    filePaths: Array<string>,\n  ): Promise<Array<[LanguageService, Array<string>]>> {\n    const promises: Array<Promise<?[LanguageService, string]>, > = filePaths.map(async filePath => {\n      const service = await this._getLanguageServiceForFile(filePath);\n      return service ? [service, filePath] : null;\n    });\n\n    const fileServices: Array<?[LanguageService, string]> = await Promise.all(\n      promises,\n    );\n\n    const results: Map<LanguageService, Array<string>> = collect(\n      arrayCompact(fileServices),\n    );\n\n    return Array.from(results);\n  }\n\n  async getLanguageServiceForFile(filePath: string): Promise<?T> {\n    const projectDir = await this.findProjectDir(filePath);\n    if (projectDir == null) {\n      return null;\n    }\n\n    const process = this._processes.get(projectDir);\n    process.then(result => {\n      // If we fail to connect, then retry on next request.\n      if (result == null) {\n        this._processes.delete(projectDir);\n      }\n    });\n    return process;\n  }\n\n  // Ensures that the only attached LanguageServices are those\n  // for the given configPaths.\n  // Closes all LanguageServices not in configPaths, and starts\n  // new LanguageServices for any paths in configPaths.\n  _ensureProcesses(configPaths: Set<NuclideUri>): void {\n    this._logger.info(\n      `MultiProjectLanguageService ensureProcesses. ${Array.from(\n        configPaths,\n      ).join(', ')}`,\n    );\n    this._processes.setKeys(configPaths);\n  }\n\n  // Closes all LanguageServices for this fileCache.\n  _closeProcesses(): void {\n    this._logger.info(\n      'Shutting down LanguageServices ' +\n        `${Array.from(this._processes.keys()).join(',')}`,\n    );\n    this._processes.clear();\n  }\n\n  observeLanguageServices(): Observable<T> {\n    this._logger.info('observing connections');\n    return compact(\n      this._processes\n        .observeValues()\n        .switchMap(process => Observable.fromPromise(process)),\n    );\n  }\n\n  async getAllLanguageServices(): Promise<Array<T>> {\n    const lsPromises: Array<Promise<?T>> = [...this._processes.values()];\n    return arrayCompact(await Promise.all(lsPromises));\n  }\n\n  async getDiagnostics(\n    fileVersion: FileVersion,\n  ): Promise<?DiagnosticProviderUpdate> {\n    return (await this._getLanguageServiceForFile(\n      fileVersion.filePath,\n    )).getDiagnostics(fileVersion);\n  }\n\n  hasObservedDiagnostics(): Promise<void> {\n    return this._observeDiagnosticsPromise;\n  }\n\n  observeDiagnostics(): ConnectableObservable<Array<FileDiagnosticMessages>> {\n    this._observeDiagnosticsPromiseResolver();\n\n    return this.observeLanguageServices()\n      .mergeMap((process: LanguageService) => {\n        this._logger.trace('observeDiagnostics');\n        return ensureInvalidations(\n          this._logger,\n          process.observeDiagnostics().refCount().catch(error => {\n            this._logger.error('Error: observeDiagnostics', error);\n            return Observable.empty();\n          }),\n        );\n      })\n      .publish();\n  }\n\n  async getAutocompleteSuggestions(\n    fileVersion: FileVersion,\n    position: atom$Point,\n    activatedManually: boolean,\n    prefix: string,\n  ): Promise<?AutocompleteResult> {\n    return (await this._getLanguageServiceForFile(\n      fileVersion.filePath,\n    )).getAutocompleteSuggestions(\n      fileVersion,\n      position,\n      activatedManually,\n      prefix,\n    );\n  }\n\n  async getDefinition(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?DefinitionQueryResult> {\n    return (await this._getLanguageServiceForFile(\n      fileVersion.filePath,\n    )).getDefinition(fileVersion, position);\n  }\n\n  async findReferences(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?FindReferencesReturn> {\n    return (await this._getLanguageServiceForFile(\n      fileVersion.filePath,\n    )).findReferences(fileVersion, position);\n  }\n\n  async getCoverage(filePath: NuclideUri): Promise<?CoverageResult> {\n    return (await this._getLanguageServiceForFile(filePath)).getCoverage(\n      filePath,\n    );\n  }\n\n  async getOutline(fileVersion: FileVersion): Promise<?Outline> {\n    return (await this._getLanguageServiceForFile(\n      fileVersion.filePath,\n    )).getOutline(fileVersion);\n  }\n\n  async typeHint(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?TypeHint> {\n    return (await this._getLanguageServiceForFile(\n      fileVersion.filePath,\n    )).typeHint(fileVersion, position);\n  }\n\n  async highlight(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?Array<atom$Range>> {\n    return (await this._getLanguageServiceForFile(\n      fileVersion.filePath,\n    )).highlight(fileVersion, position);\n  }\n\n  async formatSource(\n    fileVersion: FileVersion,\n    range: atom$Range,\n  ): Promise<?Array<TextEdit>> {\n    return (await this._getLanguageServiceForFile(\n      fileVersion.filePath,\n    )).formatSource(fileVersion, range);\n  }\n\n  async formatEntireFile(\n    fileVersion: FileVersion,\n    range: atom$Range,\n  ): Promise<?{\n    newCursor?: number,\n    formatted: string,\n  }> {\n    return (await this._getLanguageServiceForFile(\n      fileVersion.filePath,\n    )).formatEntireFile(fileVersion, range);\n  }\n\n  async formatAtPosition(\n    fileVersion: FileVersion,\n    position: atom$Point,\n    triggerCharacter: string,\n  ): Promise<?Array<TextEdit>> {\n    return (await this._getLanguageServiceForFile(\n      fileVersion.filePath,\n    )).formatAtPosition(fileVersion, position, triggerCharacter);\n  }\n\n  async getEvaluationExpression(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?NuclideEvaluationExpression> {\n    return (await this._getLanguageServiceForFile(\n      fileVersion.filePath,\n    )).getEvaluationExpression(fileVersion, position);\n  }\n\n  async supportsSymbolSearch(directories: Array<NuclideUri>): Promise<boolean> {\n    const serviceDirectories = await this._getLanguageServicesForFiles(\n      directories,\n    );\n    const eligibilities = await Promise.all(\n      serviceDirectories.map(([service, dirs]) =>\n        service.supportsSymbolSearch(dirs),\n      ),\n    );\n    return eligibilities.some(e => e);\n  }\n\n  async symbolSearch(\n    query: string,\n    directories: Array<NuclideUri>,\n  ): Promise<?Array<SymbolResult>> {\n    if (query.length === 0) {\n      return [];\n    }\n    const serviceDirectories = await this._getLanguageServicesForFiles(\n      directories,\n    );\n    const results = await Promise.all(\n      serviceDirectories.map(([service, dirs]) =>\n        service.symbolSearch(query, dirs),\n      ),\n    );\n    return arrayFlatten(arrayCompact(results));\n  }\n\n  async getProjectRoot(filePath: NuclideUri): Promise<?NuclideUri> {\n    return (await this._getLanguageServiceForFile(filePath)).getProjectRoot(\n      filePath,\n    );\n  }\n\n  async isFileInProject(filePath: NuclideUri): Promise<boolean> {\n    return (await this._getLanguageServiceForFile(filePath)).isFileInProject(\n      filePath,\n    );\n  }\n\n  dispose(): void {\n    this._resources.dispose();\n  }\n}\n\n// Enforces that an instance of MultiProjectLanguageService satisfies the LanguageService type\n(((null: any): MultiProjectLanguageService<>): LanguageService);\n"]}