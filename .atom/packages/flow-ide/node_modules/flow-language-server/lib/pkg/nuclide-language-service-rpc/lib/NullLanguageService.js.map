{"version":3,"sources":["../../../../src/pkg/nuclide-language-service-rpc/lib/NullLanguageService.js"],"names":["NullLanguageService","getDiagnostics","fileVersion","Promise","resolve","observeDiagnostics","empty","publish","getAutocompleteSuggestions","position","activatedManually","prefix","getDefinition","findReferences","getCoverage","filePath","getOutline","typeHint","highlight","formatSource","range","formatEntireFile","formatAtPosition","triggerCharacter","getEvaluationExpression","supportsSymbolSearch","directories","symbolSearch","query","getProjectRoot","fileUri","isFileInProject","dispose"],"mappings":";;;;;;;AA+BA;;AAEA;AACA;AAlCA;;;;;;;;;;;;AAmCO,MAAMA,mBAAN,CAA0B;AAC/BC,iBAAeC,WAAf,EAA6E;AAC3E,WAAOC,QAAQC,OAAR,CAAgB,IAAhB,CAAP;AACD;;AAEDC,uBAA2E;AACzE,WAAO,iBAAWC,KAAX,GAAmBC,OAAnB,EAAP;AACD;;AAEDC,6BACEN,WADF,EAEEO,QAFF,EAGEC,iBAHF,EAIEC,MAJF,EAKgC;AAC9B,WAAOR,QAAQC,OAAR,CAAgB,IAAhB,CAAP;AACD;;AAEDQ,gBACEV,WADF,EAEEO,QAFF,EAGmC;AACjC,WAAON,QAAQC,OAAR,CAAgB,IAAhB,CAAP;AACD;;AAEDS,iBACEX,WADF,EAEEO,QAFF,EAGkC;AAChC,WAAON,QAAQC,OAAR,CAAgB,IAAhB,CAAP;AACD;;AAEDU,cAAYC,QAAZ,EAA4D;AAC1D,WAAOZ,QAAQC,OAAR,CAAgB,IAAhB,CAAP;AACD;;AAEDY,aAAWd,WAAX,EAAwD;AACtD,WAAOC,QAAQC,OAAR,CAAgB,IAAhB,CAAP;AACD;;AAEDa,WAASf,WAAT,EAAmCO,QAAnC,EAA6E;AAC3E,WAAON,QAAQC,OAAR,CAAgB,IAAhB,CAAP;AACD;;AAEDc,YACEhB,WADF,EAEEO,QAFF,EAG+B;AAC7B,WAAON,QAAQC,OAAR,CAAgB,IAAhB,CAAP;AACD;;AAEDe,eACEjB,WADF,EAEEkB,KAFF,EAG6B;AAC3B,WAAOjB,QAAQC,OAAR,CAAgB,IAAhB,CAAP;AACD;;AAEDiB,mBACEnB,WADF,EAEEkB,KAFF,EAMG;AACD,WAAOjB,QAAQC,OAAR,CAAgB,IAAhB,CAAP;AACD;;AAEDkB,mBACEpB,WADF,EAEEO,QAFF,EAGEc,gBAHF,EAI6B;AAC3B,WAAOpB,QAAQC,OAAR,CAAgB,IAAhB,CAAP;AACD;;AAEDoB,0BACEtB,WADF,EAEEO,QAFF,EAGyC;AACvC,WAAON,QAAQC,OAAR,CAAgB,IAAhB,CAAP;AACD;;AAEDqB,uBAAqBC,WAArB,EAAuE;AACrE,WAAOvB,QAAQC,OAAR,CAAgB,KAAhB,CAAP;AACD;;AAEDuB,eACEC,KADF,EAEEF,WAFF,EAGiC;AAC/B,WAAOvB,QAAQC,OAAR,CAAgB,IAAhB,CAAP;AACD;;AAEDyB,iBAAeC,OAAf,EAA0D;AACxD,WAAO3B,QAAQC,OAAR,CAAgB,IAAhB,CAAP;AACD;;AAED2B,kBAAgBD,OAAhB,EAAuD;AACrD,WAAO3B,QAAQC,OAAR,CAAgB,KAAhB,CAAP;AACD;;AAED4B,YAAgB,CAAE;AAtGa;QAApBhC,mB,GAAAA,mB","file":"NullLanguageService.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport type {NuclideUri} from 'nuclide-commons/nuclideUri';\nimport type {FileVersion} from '../../nuclide-open-files-rpc/lib/rpc-types';\nimport type {TextEdit} from 'nuclide-commons-atom/text-edit';\nimport type {TypeHint} from '../../nuclide-type-hint/lib/rpc-types';\nimport type {CoverageResult} from '../../nuclide-type-coverage/lib/rpc-types';\nimport type {\n  DefinitionQueryResult,\n  DiagnosticProviderUpdate,\n  FileDiagnosticMessages,\n  FindReferencesReturn,\n  Outline,\n} from 'atom-ide-ui';\nimport type {ConnectableObservable} from 'rxjs';\nimport type {NuclideEvaluationExpression} from '../../nuclide-debugger-interfaces/rpc-types';\nimport type {\n  AutocompleteResult,\n  SymbolResult,\n} from '../../nuclide-language-service/lib/LanguageService';\n\nimport {Observable} from 'rxjs';\n\n// An implementation of LanguageService which always returns no results.\n// Useful for implementing aggregate language services.\nexport class NullLanguageService {\n  getDiagnostics(fileVersion: FileVersion): Promise<?DiagnosticProviderUpdate> {\n    return Promise.resolve(null);\n  }\n\n  observeDiagnostics(): ConnectableObservable<Array<FileDiagnosticMessages>> {\n    return Observable.empty().publish();\n  }\n\n  getAutocompleteSuggestions(\n    fileVersion: FileVersion,\n    position: atom$Point,\n    activatedManually: boolean,\n    prefix: string,\n  ): Promise<?AutocompleteResult> {\n    return Promise.resolve(null);\n  }\n\n  getDefinition(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?DefinitionQueryResult> {\n    return Promise.resolve(null);\n  }\n\n  findReferences(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?FindReferencesReturn> {\n    return Promise.resolve(null);\n  }\n\n  getCoverage(filePath: NuclideUri): Promise<?CoverageResult> {\n    return Promise.resolve(null);\n  }\n\n  getOutline(fileVersion: FileVersion): Promise<?Outline> {\n    return Promise.resolve(null);\n  }\n\n  typeHint(fileVersion: FileVersion, position: atom$Point): Promise<?TypeHint> {\n    return Promise.resolve(null);\n  }\n\n  highlight(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?Array<atom$Range>> {\n    return Promise.resolve(null);\n  }\n\n  formatSource(\n    fileVersion: FileVersion,\n    range: atom$Range,\n  ): Promise<?Array<TextEdit>> {\n    return Promise.resolve(null);\n  }\n\n  formatEntireFile(\n    fileVersion: FileVersion,\n    range: atom$Range,\n  ): Promise<?{\n    newCursor?: number,\n    formatted: string,\n  }> {\n    return Promise.resolve(null);\n  }\n\n  formatAtPosition(\n    fileVersion: FileVersion,\n    position: atom$Point,\n    triggerCharacter: string,\n  ): Promise<?Array<TextEdit>> {\n    return Promise.resolve(null);\n  }\n\n  getEvaluationExpression(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?NuclideEvaluationExpression> {\n    return Promise.resolve(null);\n  }\n\n  supportsSymbolSearch(directories: Array<NuclideUri>): Promise<boolean> {\n    return Promise.resolve(false);\n  }\n\n  symbolSearch(\n    query: string,\n    directories: Array<NuclideUri>,\n  ): Promise<?Array<SymbolResult>> {\n    return Promise.resolve(null);\n  }\n\n  getProjectRoot(fileUri: NuclideUri): Promise<?NuclideUri> {\n    return Promise.resolve(null);\n  }\n\n  isFileInProject(fileUri: NuclideUri): Promise<boolean> {\n    return Promise.resolve(false);\n  }\n\n  dispose(): void {}\n}\n"]}