{"version":3,"sources":["../../../../src/pkg/nuclide-language-service-rpc/lib/ServerLanguageService.js"],"names":["ensureInvalidations","ServerLanguageService","constructor","fileNotifier","service","_fileCache","_service","getSingleFileLanguageService","getDiagnostics","fileVersion","filePath","buffer","observeDiagnostics","publish","getAutocompleteSuggestions","position","activatedManually","prefix","isIncomplete","items","getDefinition","findReferences","getCoverage","getOutline","typeHint","highlight","formatSource","range","formatEntireFile","formatAtPosition","triggerCharacter","getEvaluationExpression","supportsSymbolSearch","directories","Promise","resolve","symbolSearch","query","getProjectRoot","fileUri","isFileInProject","dispose","logger","diagnostics","filesWithErrors","Set","trackedDiagnostics","do","diagnosticArray","diagnostic","messages","length","debug","delete","add","fileInvalidations","defer","of","Array","from","map","file","concat"],"mappings":"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","file":"ServerLanguageService.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport type {NuclideUri} from 'nuclide-commons/nuclideUri';\nimport type {FileVersion} from '../../nuclide-open-files-rpc/lib/rpc-types';\nimport type {TextEdit} from 'nuclide-commons-atom/text-edit';\nimport type {TypeHint} from '../../nuclide-type-hint/lib/rpc-types';\nimport type {CoverageResult} from '../../nuclide-type-coverage/lib/rpc-types';\nimport type {\n  DefinitionQueryResult,\n  DiagnosticProviderUpdate,\n  FileDiagnosticMessages,\n  FindReferencesReturn,\n  Outline,\n} from 'atom-ide-ui';\nimport type {\n  AutocompleteResult,\n  SymbolResult,\n  LanguageService,\n} from '../../nuclide-language-service/lib/LanguageService';\nimport type {FileNotifier} from '../../nuclide-open-files-rpc/lib/rpc-types';\nimport type {ConnectableObservable} from 'rxjs';\nimport type {NuclideEvaluationExpression} from '../../nuclide-debugger-interfaces/rpc-types';\n\nimport invariant from 'assert';\nimport {getBufferAtVersion} from '../../nuclide-open-files-rpc';\nimport {FileCache} from '../../nuclide-open-files-rpc';\nimport {Observable} from 'rxjs';\n\n// This is a version of the LanguageService interface which operates on a\n// single modified file at a time. This provides a simplified interface\n// for LanguageService implementors, at the cost of providing language analysis\n// which can not reflect multiple edited files.\nexport type SingleFileLanguageService = {\n  getDiagnostics(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n  ): Promise<?DiagnosticProviderUpdate>,\n\n  observeDiagnostics(): Observable<Array<FileDiagnosticMessages>>,\n\n  getAutocompleteSuggestions(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n    activatedManually: boolean,\n    prefix: string,\n  ): Promise<?AutocompleteResult>,\n\n  getDefinition(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n  ): Promise<?DefinitionQueryResult>,\n\n  findReferences(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n  ): Promise<?FindReferencesReturn>,\n\n  getCoverage(filePath: NuclideUri): Promise<?CoverageResult>,\n\n  getOutline(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n  ): Promise<?Outline>,\n\n  typeHint(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n  ): Promise<?TypeHint>,\n\n  highlight(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n  ): Promise<?Array<atom$Range>>,\n\n  formatSource(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    range: atom$Range,\n  ): Promise<?Array<TextEdit>>,\n\n  formatEntireFile(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    range: atom$Range,\n  ): Promise<?{\n    newCursor?: number,\n    formatted: string,\n  }>,\n\n  formatAtPosition(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n    triggerCharacter: string,\n  ): Promise<?Array<TextEdit>>,\n\n  getEvaluationExpression(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n  ): Promise<?NuclideEvaluationExpression>,\n\n  getProjectRoot(fileUri: NuclideUri): Promise<?NuclideUri>,\n\n  isFileInProject(fileUri: NuclideUri): Promise<boolean>,\n\n  dispose(): void,\n};\n\nexport class ServerLanguageService<\n  T: SingleFileLanguageService = SingleFileLanguageService,\n> {\n  _fileCache: FileCache;\n  _service: T;\n\n  constructor(fileNotifier: FileNotifier, service: T) {\n    invariant(fileNotifier instanceof FileCache);\n    this._fileCache = fileNotifier;\n    this._service = service;\n  }\n\n  getSingleFileLanguageService(): T {\n    return this._service;\n  }\n\n  async getDiagnostics(\n    fileVersion: FileVersion,\n  ): Promise<?DiagnosticProviderUpdate> {\n    const filePath = fileVersion.filePath;\n    const buffer = await getBufferAtVersion(fileVersion);\n    if (buffer == null) {\n      return null;\n    }\n    return this._service.getDiagnostics(filePath, buffer);\n  }\n\n  observeDiagnostics(): ConnectableObservable<Array<FileDiagnosticMessages>> {\n    return this._service.observeDiagnostics().publish();\n  }\n\n  async getAutocompleteSuggestions(\n    fileVersion: FileVersion,\n    position: atom$Point,\n    activatedManually: boolean,\n    prefix: string,\n  ): Promise<?AutocompleteResult> {\n    const filePath = fileVersion.filePath;\n    const buffer = await getBufferAtVersion(fileVersion);\n    if (buffer == null) {\n      return {isIncomplete: false, items: []};\n    }\n    return this._service.getAutocompleteSuggestions(\n      filePath,\n      buffer,\n      position,\n      activatedManually,\n      prefix,\n    );\n  }\n\n  async getDefinition(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?DefinitionQueryResult> {\n    const filePath = fileVersion.filePath;\n    const buffer = await getBufferAtVersion(fileVersion);\n    if (buffer == null) {\n      return null;\n    }\n    return this._service.getDefinition(filePath, buffer, position);\n  }\n\n  async findReferences(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?FindReferencesReturn> {\n    const filePath = fileVersion.filePath;\n    const buffer = await getBufferAtVersion(fileVersion);\n    if (buffer == null) {\n      return null;\n    }\n    return this._service.findReferences(filePath, buffer, position);\n  }\n\n  getCoverage(filePath: NuclideUri): Promise<?CoverageResult> {\n    return this._service.getCoverage(filePath);\n  }\n\n  async getOutline(fileVersion: FileVersion): Promise<?Outline> {\n    const filePath = fileVersion.filePath;\n    const buffer = await getBufferAtVersion(fileVersion);\n    if (buffer == null) {\n      return null;\n    }\n    return this._service.getOutline(filePath, buffer);\n  }\n\n  async typeHint(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?TypeHint> {\n    const filePath = fileVersion.filePath;\n    const buffer = await getBufferAtVersion(fileVersion);\n    if (buffer == null) {\n      return null;\n    }\n    return this._service.typeHint(filePath, buffer, position);\n  }\n\n  async highlight(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?Array<atom$Range>> {\n    const filePath = fileVersion.filePath;\n    const buffer = await getBufferAtVersion(fileVersion);\n    if (buffer == null) {\n      return [];\n    }\n    return this._service.highlight(filePath, buffer, position);\n  }\n\n  async formatSource(\n    fileVersion: FileVersion,\n    range: atom$Range,\n  ): Promise<?Array<TextEdit>> {\n    const filePath = fileVersion.filePath;\n    const buffer = await getBufferAtVersion(fileVersion);\n    if (buffer == null) {\n      return null;\n    }\n    return this._service.formatSource(filePath, buffer, range);\n  }\n\n  async formatEntireFile(\n    fileVersion: FileVersion,\n    range: atom$Range,\n  ): Promise<?{\n    newCursor?: number,\n    formatted: string,\n  }> {\n    const filePath = fileVersion.filePath;\n    const buffer = await getBufferAtVersion(fileVersion);\n    if (buffer == null) {\n      return null;\n    }\n    return this._service.formatEntireFile(filePath, buffer, range);\n  }\n\n  async formatAtPosition(\n    fileVersion: FileVersion,\n    position: atom$Point,\n    triggerCharacter: string,\n  ): Promise<?Array<TextEdit>> {\n    const filePath = fileVersion.filePath;\n    const buffer = await getBufferAtVersion(fileVersion);\n    if (buffer == null) {\n      return null;\n    }\n    return this._service.formatAtPosition(\n      filePath,\n      buffer,\n      position,\n      triggerCharacter,\n    );\n  }\n\n  async getEvaluationExpression(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?NuclideEvaluationExpression> {\n    const filePath = fileVersion.filePath;\n    const buffer = await getBufferAtVersion(fileVersion);\n    if (buffer == null) {\n      return null;\n    }\n    return this._service.getEvaluationExpression(filePath, buffer, position);\n  }\n\n  supportsSymbolSearch(directories: Array<NuclideUri>): Promise<boolean> {\n    return Promise.resolve(false);\n    // A single-file language service by definition cannot offer\n    // \"project-wide symbol search\". If you want your language to offer\n    // symbols, you'll have to implement LanguageService directly.\n  }\n\n  symbolSearch(\n    query: string,\n    directories: Array<NuclideUri>,\n  ): Promise<?Array<SymbolResult>> {\n    return Promise.resolve(null);\n  }\n\n  getProjectRoot(fileUri: NuclideUri): Promise<?NuclideUri> {\n    return this._service.getProjectRoot(fileUri);\n  }\n\n  async isFileInProject(fileUri: NuclideUri): Promise<boolean> {\n    return this._service.isFileInProject(fileUri);\n  }\n\n  dispose(): void {\n    this._service.dispose();\n  }\n}\n\n// Assert that ServerLanguageService satisifes the LanguageService interface:\n(((null: any): ServerLanguageService<>): LanguageService);\n\nexport function ensureInvalidations(\n  logger: log4js$Logger,\n  diagnostics: Observable<Array<FileDiagnosticMessages>>,\n): Observable<Array<FileDiagnosticMessages>> {\n  const filesWithErrors = new Set();\n  const trackedDiagnostics: Observable<Array<FileDiagnosticMessages>, > = diagnostics.do((diagnosticArray: Array<FileDiagnosticMessages>) => {\n    for (const diagnostic of diagnosticArray) {\n      const filePath = diagnostic.filePath;\n      if (diagnostic.messages.length === 0) {\n        logger.debug(`Removing ${filePath} from files with errors`);\n        filesWithErrors.delete(filePath);\n      } else {\n        logger.debug(`Adding ${filePath} to files with errors`);\n        filesWithErrors.add(filePath);\n      }\n    }\n  });\n\n  const fileInvalidations: Observable<Array<FileDiagnosticMessages>, > = Observable.defer(() => {\n    logger.debug('Clearing errors after stream closed');\n    return Observable.of(\n      Array.from(filesWithErrors).map(file => {\n        logger.debug(`Clearing errors for ${file} after connection closed`);\n        return {\n          filePath: file,\n          messages: [],\n        };\n      }),\n    );\n  });\n\n  return trackedDiagnostics.concat(fileInvalidations);\n}\n"]}