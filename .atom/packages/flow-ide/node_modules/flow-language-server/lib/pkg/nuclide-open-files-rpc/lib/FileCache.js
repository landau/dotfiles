'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FileCache = undefined;

var _asyncToGenerator = require('async-to-generator');

var _asyncToGenerator2 = _interopRequireDefault(_asyncToGenerator);

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @format
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

var _simpleTextBuffer = require('simple-text-buffer');

var _simpleTextBuffer2 = _interopRequireDefault(_simpleTextBuffer);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _rxjs = require('rxjs');

var _FileVersionNotifier = require('./FileVersionNotifier');

var _UniversalDisposable = require('nuclide-commons/UniversalDisposable');

var _UniversalDisposable2 = _interopRequireDefault(_UniversalDisposable);

var _nuclideUri = require('nuclide-commons/nuclideUri');

var _nuclideUri2 = _interopRequireDefault(_nuclideUri);

var _constants = require('./constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class FileCache {
  // Care! update() is the only way you're allowed to update _buffers or _requests
  // or to fire a _fileEvents.next() event. That's to ensure that the three things
  // stay in sync.
  constructor() {
    this._buffers = new Map();
    this._fileEvents = new _rxjs.Subject();
    this._directoryEvents = new _rxjs.BehaviorSubject(new Set());
    this._requests = new _FileVersionNotifier.FileVersionNotifier();

    this._resources = new _UniversalDisposable2.default();
    this._resources.add(this._requests);
  }

  update(updateBufferAndMakeEventFunc) {
    const event = updateBufferAndMakeEventFunc();
    this._requests.onEvent(event);

    // invariant: because the above two lines have updated both _buffers and _requests,
    // then getBufferAtVersion will necessarily return immediately and succesfully.
    // And getBufferForFileEdit will also succeed.
    (0, _assert2.default)(event.kind !== 'edit' || this.getBufferForFileEdit(event));

    this._fileEvents.next(event);
  }

  // If any out of sync state is detected then an Error is thrown.
  // This will force the client to send a 'sync' event to get back on track.
  onFileEvent(event) {
    const filePath = event.fileVersion.filePath;
    const changeCount = event.fileVersion.version;
    const buffer = this._buffers.get(filePath);
    switch (event.kind) {
      case _constants.FileEventKind.OPEN:
        (0, _assert2.default)(buffer == null);
        this._open(filePath, event.contents, changeCount);
        break;
      case _constants.FileEventKind.CLOSE:
        if (buffer != null) {
          this._close(filePath, buffer);
        }
        break;
      case _constants.FileEventKind.EDIT:
        (0, _assert2.default)(buffer != null);
        (0, _assert2.default)(buffer.changeCount === changeCount - 1);
        (0, _assert2.default)(buffer.getTextInRange(event.oldRange) === event.oldText);
        this.update(() => {
          buffer.setTextInRange(event.oldRange, event.newText);
          (0, _assert2.default)(buffer.changeCount === changeCount);
          return event;
        });
        break;
      case _constants.FileEventKind.SYNC:
        if (buffer == null) {
          this._open(filePath, event.contents, changeCount);
        } else {
          this._syncEdit(filePath, buffer, event.contents, changeCount);
        }
        break;
      default:
        throw new Error(`Unexpected FileEvent.kind: ${event.kind}`);
    }
    return Promise.resolve(undefined);
  }

  onDirectoriesChanged(openDirectories) {
    var _this = this;

    return (0, _asyncToGenerator2.default)(function* () {
      _this._directoryEvents.next(openDirectories);
    })();
  }

  _syncEdit(filePath, buffer, contents, changeCount) {
    // messages are out of order
    if (changeCount < buffer.changeCount) {
      return;
    }

    const oldText = buffer.getText();
    const oldRange = buffer.getRange();
    this.update(() => {
      buffer.setText(contents);
      const newRange = buffer.getRange();
      buffer.changeCount = changeCount;
      return createEditEvent(this.createFileVersion(filePath, changeCount), oldRange, oldText, newRange, buffer.getText());
    });
  }

  _open(filePath, contents, changeCount) {
    // We never call setPath on these TextBuffers as that will
    // start the TextBuffer attempting to sync with the file system.
    const newBuffer = new _simpleTextBuffer2.default(contents);
    newBuffer.changeCount = changeCount;
    this.update(() => {
      this._buffers.set(filePath, newBuffer);
      return createOpenEvent(this.createFileVersion(filePath, changeCount), contents);
    });
  }

  _close(filePath, buffer) {
    this.update(() => {
      this._buffers.delete(filePath);
      return createCloseEvent(this.createFileVersion(filePath, buffer.changeCount));
    });
    buffer.destroy();
  }

  dispose() {
    // The _close routine will delete elements from the _buffers map.
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = this._buffers.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        const _ref = _step.value;

        var _ref2 = _slicedToArray(_ref, 2);

        const filePath = _ref2[0];
        const buffer = _ref2[1];

        this._close(filePath, buffer);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    (0, _assert2.default)(this._buffers.size === 0);
    this._resources.dispose();
    this._fileEvents.complete();
    this._directoryEvents.complete();
  }

  // getBuffer: returns whatever is the current version of the buffer.
  getBuffer(filePath) {
    // TODO: change this to return a string, to ensure that no caller will ever mutate
    // the buffer contents (and hence its changeCount). The only modifications allowed
    // are those that come from the editor inside this.onFileEvent.
    return this._buffers.get(filePath);
  }

  // getBufferAtVersion(version): if the stream of onFileEvent gets up to this particular
  // version, either now or in the future, then will return the buffer for that version.
  // But if for whatever reason the stream of onFileEvent won't hit that precise version
  // then returns null. See comments in _requests.waitForBufferAtVersion for
  // the subtle scenarios where it might return null.
  getBufferAtVersion(fileVersion) {
    var _this2 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      // TODO: change this to return a string, like getBuffer() above.
      if (!(yield _this2._requests.waitForBufferAtVersion(fileVersion))) {
        return null;
      }
      const buffer = _this2.getBuffer(fileVersion.filePath);
      return buffer != null && buffer.changeCount === fileVersion.version ? buffer : null;
    })();
  }

  // getBufferForFileEdit - this function may be called immediately when an edit event
  // happens, before any awaits. At that time the buffer is guaranteed to be
  // available. If called at any other time, the buffer may no longer be available,
  // in which case it may throw.
  getBufferForFileEdit(fileEvent) {
    // TODO: change this to return a string, like getBuffer() above.
    const fileVersion = fileEvent.fileVersion;
    (0, _assert2.default)(this._requests.isBufferAtVersion(fileVersion));
    const buffer = this.getBuffer(fileVersion.filePath);
    (0, _assert2.default)(buffer != null && buffer.changeCount === fileVersion.version);
    return buffer;
  }

  getOpenDirectories() {
    return this._directoryEvents.getValue();
  }

  // Returns directory which contains this path if any.
  // Remote equivalent of atom.project.relativizePath()[1]
  // TODO: Return the most nested open directory.
  //       Note that Atom doesn't do this, though it should.
  getContainingDirectory(filePath) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = this.getOpenDirectories()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        const dir = _step2.value;

        if (_nuclideUri2.default.contains(dir, filePath)) {
          return dir;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return null;
  }

  getOpenFiles() {
    return this._buffers.keys();
  }

  observeFileEvents() {
    return _rxjs.Observable.from(Array.from(this._buffers.entries()).map(([filePath, buffer]) => {
      (0, _assert2.default)(buffer != null);
      return createOpenEvent(this.createFileVersion(filePath, buffer.changeCount), buffer.getText());
    })).concat(this._fileEvents);
  }

  observeDirectoryEvents() {
    return this._directoryEvents;
  }

  createFileVersion(filePath, version) {
    return {
      notifier: this,
      filePath,
      version
    };
  }
}

exports.FileCache = FileCache;
function createOpenEvent(fileVersion, contents) {
  return {
    kind: _constants.FileEventKind.OPEN,
    fileVersion,
    contents
  };
}

function createCloseEvent(fileVersion) {
  return {
    kind: _constants.FileEventKind.CLOSE,
    fileVersion
  };
}

function createEditEvent(fileVersion, oldRange, oldText, newRange, newText) {
  return {
    kind: _constants.FileEventKind.EDIT,
    fileVersion,
    oldRange,
    oldText,
    newRange,
    newText
  };
}
//# sourceMappingURL=FileCache.js.map