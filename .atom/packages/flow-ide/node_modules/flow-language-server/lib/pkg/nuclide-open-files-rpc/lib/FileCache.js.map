{"version":3,"sources":["../../../../src/pkg/nuclide-open-files-rpc/lib/FileCache.js"],"names":["FileCache","constructor","_buffers","Map","_fileEvents","_directoryEvents","Set","_requests","_resources","add","update","updateBufferAndMakeEventFunc","event","onEvent","kind","getBufferForFileEdit","next","onFileEvent","filePath","fileVersion","changeCount","version","buffer","get","OPEN","_open","contents","CLOSE","_close","EDIT","getTextInRange","oldRange","oldText","setTextInRange","newText","SYNC","_syncEdit","Error","Promise","resolve","undefined","onDirectoriesChanged","openDirectories","getText","getRange","setText","newRange","createEditEvent","createFileVersion","newBuffer","set","createOpenEvent","delete","createCloseEvent","destroy","dispose","entries","size","complete","getBuffer","getBufferAtVersion","waitForBufferAtVersion","fileEvent","isBufferAtVersion","getOpenDirectories","getValue","getContainingDirectory","dir","contains","getOpenFiles","keys","observeFileEvents","from","Array","map","concat","observeDirectoryEvents","notifier"],"mappings":"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","file":"FileCache.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport type {NuclideUri} from 'nuclide-commons/nuclideUri';\nimport type {\n  FileOpenEvent,\n  FileCloseEvent,\n  FileEditEvent,\n  FileEvent,\n  FileVersion,\n  LocalFileEvent,\n} from './rpc-types';\n\nimport TextBuffer from 'simple-text-buffer';\nimport invariant from 'assert';\nimport {BehaviorSubject, Subject, Observable} from 'rxjs';\nimport {FileVersionNotifier} from './FileVersionNotifier';\nimport UniversalDisposable from 'nuclide-commons/UniversalDisposable';\nimport nuclideUri from 'nuclide-commons/nuclideUri';\n\nimport {FileEventKind} from './constants';\n\nexport class FileCache {\n  _buffers: Map<NuclideUri, simpleTextBuffer$TextBuffer>;\n  _requests: FileVersionNotifier;\n  _fileEvents: Subject<LocalFileEvent>;\n  // Care! update() is the only way you're allowed to update _buffers or _requests\n  // or to fire a _fileEvents.next() event. That's to ensure that the three things\n  // stay in sync.\n  _directoryEvents: BehaviorSubject<Set<NuclideUri>>;\n  _resources: UniversalDisposable;\n\n  constructor() {\n    this._buffers = new Map();\n    this._fileEvents = new Subject();\n    this._directoryEvents = new BehaviorSubject(new Set());\n    this._requests = new FileVersionNotifier();\n\n    this._resources = new UniversalDisposable();\n    this._resources.add(this._requests);\n  }\n\n  update(updateBufferAndMakeEventFunc: () => LocalFileEvent) {\n    const event = updateBufferAndMakeEventFunc();\n    this._requests.onEvent(event);\n\n    // invariant: because the above two lines have updated both _buffers and _requests,\n    // then getBufferAtVersion will necessarily return immediately and succesfully.\n    // And getBufferForFileEdit will also succeed.\n    invariant(event.kind !== 'edit' || this.getBufferForFileEdit(event));\n\n    this._fileEvents.next(event);\n  }\n\n  // If any out of sync state is detected then an Error is thrown.\n  // This will force the client to send a 'sync' event to get back on track.\n  onFileEvent(event: FileEvent): Promise<void> {\n    const filePath = event.fileVersion.filePath;\n    const changeCount = event.fileVersion.version;\n    const buffer = this._buffers.get(filePath);\n    switch (event.kind) {\n      case FileEventKind.OPEN:\n        invariant(buffer == null);\n        this._open(filePath, event.contents, changeCount);\n        break;\n      case FileEventKind.CLOSE:\n        if (buffer != null) {\n          this._close(filePath, buffer);\n        }\n        break;\n      case FileEventKind.EDIT:\n        invariant(buffer != null);\n        invariant(buffer.changeCount === changeCount - 1);\n        invariant(buffer.getTextInRange(event.oldRange) === event.oldText);\n        this.update(() => {\n          buffer.setTextInRange(event.oldRange, event.newText);\n          invariant(buffer.changeCount === changeCount);\n          return event;\n        });\n        break;\n      case FileEventKind.SYNC:\n        if (buffer == null) {\n          this._open(filePath, event.contents, changeCount);\n        } else {\n          this._syncEdit(filePath, buffer, event.contents, changeCount);\n        }\n        break;\n      default:\n        throw new Error(`Unexpected FileEvent.kind: ${event.kind}`);\n    }\n    return Promise.resolve(undefined);\n  }\n\n  async onDirectoriesChanged(openDirectories: Set<NuclideUri>): Promise<void> {\n    this._directoryEvents.next(openDirectories);\n  }\n\n  _syncEdit(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    contents: string,\n    changeCount: number,\n  ): void {\n    // messages are out of order\n    if (changeCount < buffer.changeCount) {\n      return;\n    }\n\n    const oldText = buffer.getText();\n    const oldRange = buffer.getRange();\n    this.update(() => {\n      buffer.setText(contents);\n      const newRange = buffer.getRange();\n      buffer.changeCount = changeCount;\n      return createEditEvent(\n        this.createFileVersion(filePath, changeCount),\n        oldRange,\n        oldText,\n        newRange,\n        buffer.getText(),\n      );\n    });\n  }\n\n  _open(filePath: NuclideUri, contents: string, changeCount: number): void {\n    // We never call setPath on these TextBuffers as that will\n    // start the TextBuffer attempting to sync with the file system.\n    const newBuffer = new TextBuffer(contents);\n    newBuffer.changeCount = changeCount;\n    this.update(() => {\n      this._buffers.set(filePath, newBuffer);\n      return createOpenEvent(\n        this.createFileVersion(filePath, changeCount),\n        contents,\n      );\n    });\n  }\n\n  _close(filePath: NuclideUri, buffer: simpleTextBuffer$TextBuffer): void {\n    this.update(() => {\n      this._buffers.delete(filePath);\n      return createCloseEvent(\n        this.createFileVersion(filePath, buffer.changeCount),\n      );\n    });\n    buffer.destroy();\n  }\n\n  dispose(): void {\n    // The _close routine will delete elements from the _buffers map.\n    // Per ES6 this is safe to do even while iterating.\n    for (const [filePath, buffer] of this._buffers.entries()) {\n      this._close(filePath, buffer);\n    }\n    invariant(this._buffers.size === 0);\n    this._resources.dispose();\n    this._fileEvents.complete();\n    this._directoryEvents.complete();\n  }\n\n  // getBuffer: returns whatever is the current version of the buffer.\n  getBuffer(filePath: NuclideUri): ?simpleTextBuffer$TextBuffer {\n    // TODO: change this to return a string, to ensure that no caller will ever mutate\n    // the buffer contents (and hence its changeCount). The only modifications allowed\n    // are those that come from the editor inside this.onFileEvent.\n    return this._buffers.get(filePath);\n  }\n\n  // getBufferAtVersion(version): if the stream of onFileEvent gets up to this particular\n  // version, either now or in the future, then will return the buffer for that version.\n  // But if for whatever reason the stream of onFileEvent won't hit that precise version\n  // then returns null. See comments in _requests.waitForBufferAtVersion for\n  // the subtle scenarios where it might return null.\n  async getBufferAtVersion(\n    fileVersion: FileVersion,\n  ): Promise<?simpleTextBuffer$TextBuffer> {\n    // TODO: change this to return a string, like getBuffer() above.\n    if (!await this._requests.waitForBufferAtVersion(fileVersion)) {\n      return null;\n    }\n    const buffer = this.getBuffer(fileVersion.filePath);\n    return buffer != null && buffer.changeCount === fileVersion.version\n      ? buffer\n      : null;\n  }\n\n  // getBufferForFileEdit - this function may be called immediately when an edit event\n  // happens, before any awaits. At that time the buffer is guaranteed to be\n  // available. If called at any other time, the buffer may no longer be available,\n  // in which case it may throw.\n  getBufferForFileEdit(fileEvent: FileEditEvent): simpleTextBuffer$TextBuffer {\n    // TODO: change this to return a string, like getBuffer() above.\n    const fileVersion = fileEvent.fileVersion;\n    invariant(this._requests.isBufferAtVersion(fileVersion));\n    const buffer = this.getBuffer(fileVersion.filePath);\n    invariant(buffer != null && buffer.changeCount === fileVersion.version);\n    return buffer;\n  }\n\n  getOpenDirectories(): Set<NuclideUri> {\n    return this._directoryEvents.getValue();\n  }\n\n  // Returns directory which contains this path if any.\n  // Remote equivalent of atom.project.relativizePath()[1]\n  // TODO: Return the most nested open directory.\n  //       Note that Atom doesn't do this, though it should.\n  getContainingDirectory(filePath: NuclideUri): ?NuclideUri {\n    for (const dir of this.getOpenDirectories()) {\n      if (nuclideUri.contains(dir, filePath)) {\n        return dir;\n      }\n    }\n    return null;\n  }\n\n  getOpenFiles(): Iterator<NuclideUri> {\n    return this._buffers.keys();\n  }\n\n  observeFileEvents(): Observable<LocalFileEvent> {\n    return Observable.from(\n      Array.from(this._buffers.entries()).map(([filePath, buffer]) => {\n        invariant(buffer != null);\n        return createOpenEvent(\n          this.createFileVersion(filePath, buffer.changeCount),\n          buffer.getText(),\n        );\n      }),\n    ).concat(this._fileEvents);\n  }\n\n  observeDirectoryEvents(): Observable<Set<NuclideUri>> {\n    return this._directoryEvents;\n  }\n\n  createFileVersion(filePath: NuclideUri, version: number): FileVersion {\n    return {\n      notifier: this,\n      filePath,\n      version,\n    };\n  }\n}\n\nfunction createOpenEvent(\n  fileVersion: FileVersion,\n  contents: string,\n): FileOpenEvent {\n  return {\n    kind: FileEventKind.OPEN,\n    fileVersion,\n    contents,\n  };\n}\n\nfunction createCloseEvent(fileVersion: FileVersion): FileCloseEvent {\n  return {\n    kind: FileEventKind.CLOSE,\n    fileVersion,\n  };\n}\n\nfunction createEditEvent(\n  fileVersion: FileVersion,\n  oldRange: atom$Range,\n  oldText: string,\n  newRange: atom$Range,\n  newText: string,\n): FileEditEvent {\n  return {\n    kind: FileEventKind.EDIT,\n    fileVersion,\n    oldRange,\n    oldText,\n    newRange,\n    newText,\n  };\n}\n"]}