{"version":3,"sources":["../../../../src/pkg/nuclide-open-files-rpc/lib/FileVersionNotifier.js"],"names":["FileVersionNotifier","constructor","_versions","Map","_requests","onEvent","event","filePath","fileVersion","changeCount","version","kind","OPEN","set","CLOSE","delete","EDIT","Error","_checkRequests","dispose","values","request","reject","createRejectError","getVersion","get","isBufferAtVersion","currentVersion","waitForBufferAtVersion","Promise","resolve","Request","add","promise","requests","Array","from","resolves","filter","rejects","remaining","forEach"],"mappings":"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","file":"FileVersionNotifier.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport type {NuclideUri} from 'nuclide-commons/nuclideUri';\nimport type {LocalFileEvent, FileVersion} from './rpc-types';\n\nimport {FileEventKind} from './constants';\nimport {Deferred} from 'nuclide-commons/promise';\nimport {MultiMap} from 'nuclide-commons/collection';\n\nexport class FileVersionNotifier {\n  _versions: Map<NuclideUri, number>;\n  _requests: MultiMap<NuclideUri, Request>;\n\n  constructor() {\n    this._versions = new Map();\n    this._requests = new MultiMap();\n  }\n\n  // If any out of sync state is detected then an Error is thrown.\n  // This will force the client to send a 'sync' event to get back on track.\n  onEvent(event: LocalFileEvent): void {\n    const filePath = event.fileVersion.filePath;\n    const changeCount = event.fileVersion.version;\n    switch (event.kind) {\n      case FileEventKind.OPEN:\n        this._versions.set(filePath, changeCount);\n        break;\n      case FileEventKind.CLOSE:\n        this._versions.delete(filePath);\n        break;\n      case FileEventKind.EDIT:\n        this._versions.set(filePath, changeCount);\n        break;\n      default:\n        throw new Error(`Unexpected LocalFileEvent.kind: ${event.kind}`);\n    }\n    this._checkRequests(filePath);\n  }\n\n  dispose(): void {\n    for (const request of this._requests.values()) {\n      request.reject(createRejectError());\n    }\n  }\n\n  getVersion(filePath: NuclideUri): ?number {\n    return this._versions.get(filePath);\n  }\n\n  isBufferAtVersion(fileVersion: FileVersion): boolean {\n    const filePath = fileVersion.filePath;\n    const version = fileVersion.version;\n    const currentVersion = this._versions.get(filePath);\n    return currentVersion === version;\n  }\n\n  // waitForBufferAtVersion:\n  // Asynchronously waits until a FileEdit has passed through fileNotifier.onEvent\n  // for this particular version of the file. If for whatever reason this precise version\n  // doesn't get passed through onEvent then returns false as soon as we discover that.\n  //\n  // Fast-typing scenario where it might return false:\n  // (1) File is at version N\n  // (2) User types to version N+1 which invokes onEvent for N+1\n  // (3) It also invoked autocomplete (which needs N+1 buffer to do its job right)\n  // (4) User quickly types to version N+2 which invokes onEvent for N+2\n  // (5) Autocomplete gets around to requesting N+1\n  // At step 5 we know we will never be able to deliver buffer at version N+1, so we return false.\n  //\n  // Network-connectivity scenario where it might return false:\n  // (1) File is at version N\n  // (2) User types to version N+1 which invokes autocomplete (which needs N+1 to do its job right)\n  // (3) Network goes down before the onEvent for N+1 can be dispatched\n  // (4) Network goes back up\n  // (5) User types to version N+2 which invokes onEvent for N+2\n  // At step 5 we know we will never be able to deliver buffer at version N+1, so we return false.\n  waitForBufferAtVersion(fileVersion: FileVersion): Promise<boolean> {\n    const filePath = fileVersion.filePath;\n    const version = fileVersion.version;\n    const currentVersion = this._versions.get(filePath);\n    if (currentVersion === version) {\n      return Promise.resolve(true);\n    } else if (currentVersion != null && currentVersion > version) {\n      return Promise.resolve(false);\n    }\n    const request = new Request(filePath, version);\n    this._requests.add(filePath, request);\n    return request.promise;\n  }\n\n  _checkRequests(filePath: NuclideUri): void {\n    const currentVersion = this._versions.get(filePath);\n    if (currentVersion == null) {\n      return;\n    }\n\n    const requests = Array.from(this._requests.get(filePath));\n    const resolves = requests.filter(\n      request => request.changeCount === currentVersion,\n    );\n    const rejects = requests.filter(\n      request => request.changeCount < currentVersion,\n    );\n    const remaining = requests.filter(\n      request => request.changeCount > currentVersion,\n    );\n    this._requests.set(filePath, remaining);\n\n    resolves.forEach(request => request.resolve(true));\n    rejects.forEach(request => request.resolve(false));\n  }\n}\n\nfunction createRejectError(): Error {\n  return new Error('File modified past requested change');\n}\n\nclass Request extends Deferred<boolean> {\n  filePath: NuclideUri;\n  changeCount: number;\n\n  constructor(filePath: NuclideUri, changeCount: number) {\n    super();\n\n    this.filePath = filePath;\n    this.changeCount = changeCount;\n  }\n}\n"]}