{"version":3,"sources":["../../src/utils/util.js"],"names":["toURI","hasFlowPragma","flowSeverityToLSPSeverity","lspPositionToAtomPoint","atomPointToLSPPosition","atomRangeToLSPRange","lspRangeToAtomRange","compareLspPosition","compareLspRange","FlowSeverity","Error","Warning","flowSeverityToLSPSeverityMap","filePath","file","content","hasPragma","startsWith","test","flowSeverity","lspPosition","line","character","atomPoint","row","column","atomRange","start","end","lspRange","a","b"],"mappings":";;;;;QAqCgBA,K,GAAAA,K;QAIAC,a,GAAAA,a;QASAC,yB,GAAAA,yB;QAYAC,sB,GAAAA,sB;QAIAC,sB,GAAAA,sB;QAOAC,mB,GAAAA,mB;QAOAC,mB,GAAAA,mB;QAOAC,kB,GAAAA,kB;QAIAC,e,GAAAA,e;;AAzEhB;;AAEA;;AACA;;;;AACA;;;;AACA;;;;;;AAvBA;;;;;;;;;;;;AAyBA,MAAMC,eAAe;AACnBC,SAAO,OADY;AAEnBC,WAAS;AAFU,CAArB;;AAKA,MAAMC,+BAEF;AACF,GAACH,aAAaC,KAAd,GAAsB,8CAAmBA,KADvC;AAEF,GAACD,aAAaE,OAAd,GAAwB,8CAAmBA;AAFzC,CAFJ;;AAOO,SAASX,KAAT,CAAea,QAAf,EAAsC;AAC3C,SAAO,oBAAIC,IAAJ,CAASD,QAAT,CAAP;AACD;;AAEM,SAASZ,aAAT,CAAuBc,OAAvB,EAAwC;AAC7C,QAAMC,YACJD,QAAQE,UAAR,CAAmB,aAAnB,KACAF,QAAQE,UAAR,CAAmB,YAAnB,CADA,IAEA,6BAA6BC,IAA7B,CAAkCH,OAAlC,CAFA,IAGA,wBAAwBG,IAAxB,CAA6BH,OAA7B,CAJF;AAKA,SAAOC,SAAP;AACD;;AAEM,SAASd,yBAAT,CACLiB,YADK,EAEmB;AACxB,wBACEA,iBAAiBV,aAAaE,OAA9B,IACEQ,iBAAiBV,aAAaC,KAFlC,EAGE,+BAHF;;AAMA,SAAO,0BAAWE,6BAA6BO,YAA7B,CAAX,CAAP;AACD;;AAEM,SAAShB,sBAAT,CAAgCiB,WAAhC,EAAoE;AACzE,SAAO,4BAAUA,YAAYC,IAAtB,EAA4BD,YAAYE,SAAxC,CAAP;AACD;;AAEM,SAASlB,sBAAT,CAAgCmB,SAAhC,EAAwE;AAC7E,SAAO;AACLF,UAAME,UAAUC,GADX;AAELF,eAAWC,UAAUE;AAFhB,GAAP;AAID;;AAEM,SAASpB,mBAAT,CAA6BqB,SAA7B,EAA4D;AACjE,SAAO;AACLC,WAAOvB,uBAAuBsB,UAAUC,KAAjC,CADF;AAELC,SAAKxB,uBAAuBsB,UAAUE,GAAjC;AAFA,GAAP;AAID;;AAEM,SAAStB,mBAAT,CAA6BuB,QAA7B,EAAiE;AACtE,SAAO;AACLF,WAAOxB,uBAAuB0B,SAASF,KAAhC,CADF;AAELC,SAAKzB,uBAAuB0B,SAASD,GAAhC;AAFA,GAAP;AAID;;AAEM,SAASrB,kBAAT,CAA4BuB,CAA5B,EAAyCC,CAAzC,EAA8D;AACnE,SAAOD,EAAET,IAAF,GAASU,EAAEV,IAAX,IAAmBS,EAAER,SAAF,GAAcS,EAAET,SAA1C;AACD;;AAEM,SAASd,eAAT,CAAyBsB,CAAzB,EAAoCC,CAApC,EAAuD;AAC5D,SACExB,mBAAmBuB,EAAEH,KAArB,EAA4BI,EAAEJ,KAA9B,KAAwCpB,mBAAmBuB,EAAEF,GAArB,EAA0BG,EAAEH,GAA5B,CAD1C;AAGD","file":"util.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport type {\n  DiagnosticSeverityType,\n  IPosition,\n  IRange,\n} from 'vscode-languageserver-types';\n\nimport {Point} from 'simple-text-buffer';\n\nimport {DiagnosticSeverity} from 'vscode-languageserver-types';\nimport invariant from 'assert';\nimport nullthrows from 'nullthrows';\nimport URI from 'vscode-uri';\n\nconst FlowSeverity = {\n  Error: 'Error',\n  Warning: 'Warning',\n};\n\nconst flowSeverityToLSPSeverityMap: {\n  [string]: DiagnosticSeverityType,\n} = {\n  [FlowSeverity.Error]: DiagnosticSeverity.Error,\n  [FlowSeverity.Warning]: DiagnosticSeverity.Warning,\n};\n\nexport function toURI(filePath: string): URI {\n  return URI.file(filePath);\n}\n\nexport function hasFlowPragma(content: string) {\n  const hasPragma =\n    content.startsWith('/* @flow */') ||\n    content.startsWith('// @flow\\n') ||\n    /^\\s*\\/\\*+\\s*@flow\\s*\\*+\\//m.test(content) ||\n    /^\\s*\\/\\/\\s*@flow\\s*$/m.test(content);\n  return hasPragma;\n}\n\nexport function flowSeverityToLSPSeverity(\n  flowSeverity: string,\n): DiagnosticSeverityType {\n  invariant(\n    flowSeverity === FlowSeverity.Warning ||\n      flowSeverity === FlowSeverity.Error,\n    'must be a valid flow severity',\n  );\n\n  return nullthrows(flowSeverityToLSPSeverityMap[flowSeverity]);\n}\n\nexport function lspPositionToAtomPoint(lspPosition: IPosition): atom$Point {\n  return new Point(lspPosition.line, lspPosition.character);\n}\n\nexport function atomPointToLSPPosition(atomPoint: atom$PointObject): IPosition {\n  return {\n    line: atomPoint.row,\n    character: atomPoint.column,\n  };\n}\n\nexport function atomRangeToLSPRange(atomRange: atom$Range): IRange {\n  return {\n    start: atomPointToLSPPosition(atomRange.start),\n    end: atomPointToLSPPosition(atomRange.end),\n  };\n}\n\nexport function lspRangeToAtomRange(lspRange: IRange): atom$RangeObject {\n  return {\n    start: lspPositionToAtomPoint(lspRange.start),\n    end: lspPositionToAtomPoint(lspRange.end),\n  };\n}\n\nexport function compareLspPosition(a: Position, b: Position): number {\n  return a.line - b.line || a.character - b.character;\n}\n\nexport function compareLspRange(a: IRange, b: IRange): number {\n  return (\n    compareLspPosition(a.start, b.start) || compareLspPosition(a.end, b.end)\n  );\n}\n"]}